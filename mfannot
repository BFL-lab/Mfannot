#!/usr/bin/perl -w -- -*-Perl-*-

##############################################################################
#
#                                 mfannot.pl
#
# DESCRIPTION:
# Attempts to do a quick first pass at annotating a masterfile
# with meaningfull start/stop lines by calling blast on collections
# of known genes. Manual intervention is still required to check/adjust
# the new annotations.
#
# Known issues: - Annotations for START/STOP introns are interleaved (they
#                 are at the correct position, though).
#
##############################################################################

##############################################################################
#                                                                            #
#                       CONFIDENTIAL & PROPRIETARY                           #
#       Nothing herein is to be disclosed in any way without the prior       #
#           express written permission of Pierre Rioux                       #
#                                                                            #
#          Copyright 2004 Pierre Rioux, All rights reserved.                 #
#                                                                            #
##############################################################################
#
#    $Id: mfannot,v 1.12 2005/05/05 16:00:06 thomash Exp $
#
#    $Log: mfannot,v $
#    Revision 1.12  2005/05/05 16:00:06  thomash
#    Disallow, 2 annotations for the same gene, by default
#    Allows 2 annotations if option -f.
#    Give, too non coresponding ORF (it means, with no
#    corresponding gene after running blast) with a
#    specific cutoff size
#
#    Revision 1.10  2005/04/28 19:10:55  thomash
#    Comment added,
#    Options problemes fixed by allowing
#    setting parameters
#    This mfannot version runs with the new
#    MAsterfile.pir object that allows the user
#    to load annotation from a Masterfile
#    having the same name
#
#    Revision 1.8  2005/04/13 20:06:07  thomash
#    New Version of Mfannot
#    Input : A masterfile (-m) and a peplibrary (-p)
#    First step : Give the pepfile from the peplibrary corresponding to
#    the closest Organism.
#    Second step : Doing annotation of the Masterfile with the pepfile
#    Annotation is made with translation (in the 6 frames) of the
#    Masterfile
#    and blasting the results with the pepfile.
#
#    Revision 1.6  2005/03/16 14:52:49  dto
#    Added correct location of perl
#
#    Revision 1.5  2005/03/15 20:36:22  thomash
#    Add tRNAscanSE for prediction
#
#    Revision 1.4  2005/03/04 20:47:29  dto
#    New version provided by Pierre
#    Modified by Hoellinger T. 2005/03/14
#
#

##########################
# Initialization section #
##########################

require 5.00;
use strict;
use vars qw( $VERSION $RCS_VERSION );
use IO::File;                             
use PirObject;                                        #  Pir module treatment 
use Bio::SearchIO;                                    #  Bioperl (used for parsing blast outout)
use Bio::SeqUtils;                          
   

#---General Objects
PirObject->LoadDataModel("Masterfile");               #  Masterfile object
PirObject->LoadDataModel("MfAnnotConfig");            #  Configuration object
PirObject->LoadDataModel("tRNAscanSEparser");         #  Parser for tRNAscanSE output

#---Objects for annotation 
PirObject->LoadDataModel("FlipBlastProt");            #  Objects for storing ORFs predicted by Flip and kept with blast
PirObject->LoadDataModel("Orf");                      #  ORF (belong to FlipBlastProt)
PirObject->LoadDataModel("Hsp");                      #  High Scoring Pair (belong to Orf)
PirObject->LoadDataModel("HypProt");                  #  Hypothetical protein : We believe its a protein after flip, blast an
                                                      #  Organization of the results     
PirObject->LoadDataModel("Exon");                     #  Exons : belongs to Hypothetical proteins
PirObject->LoadDataModel("Option");                   #  A module for options gestion

PirObject->LoadDataModel("EmptyOrf");                 #  Object containing Orfs having no corresponding genes

# Default umask
umask 027;

# Program's name and version number.
$RCS_VERSION='$Id: mfannot,v 1.12 2005/05/05 16:00:06 thomash Exp $';
($VERSION) = ($RCS_VERSION =~ m#,v ([\w\.]+)#);
my ($BASENAME) = ($0 =~ /([^\/]+)$/);

# Get login name.
my $USER=getpwuid($<) || getlogin || die "Can't find USER from environment!\n";

##################################
# Global variables and constants #
##################################

# Command-line args

#--No more used
my $AUTOMATIC=0;
my $TAGNAME=undef;                              #  Tag : is presnt in masterfile within the annotations made with Mfannot
my $FORCEANNOT=0;
my $HOMECONFIGFILE = ($ENV{"HOME"} || ".") . "/.mfannotconfig.xml";
my $BLASTALL_DNA_OPTIONS  = "-e 1.0e-15" .      #  e-value
                            "";
my $BLASTALL_PROT_OPTIONS = "-e 1.0e-15" .      #  e-value
                            "";
my $ANNOT_STATS = {
    'Added'        => {},                       #  It means, never see it before
    'Rediscovered' => {},                       #  Means exist at the same place (not added into the file)
};
my $EMPTYORFS = [];                             #  An array containing, EmptyOrf object. It means ORFs having
                                                #  no corresponding genes
my $ANNOTSEEN = {};                             #  An array storing annotations that have been seen before
my $FIRSTTIME = 1;                              #  A global variable for annotation process (used in AddAnnotFrompirmaster)		


#--General options
my $DEBUG;                                      #  Debug mode. If true, display message on the screen
my $GENCODE=undef;                              #  Genetique code
my $TMPDIR = "/tmp/mfannot.$$";                 #  Temporary directory
my $LOGFILE;                                    #  log file : store all the information about run
my $SIMILARITYSEARCH;                           #  Usefull for running similaritie gene process for annot.
my $ISLOGFILE=0;                                #  Just to know if the $LOGFILE is not empty (0 or 1)
my $PEPLIBRARY;                                 #  Path for peplibrary directory
my $MASTERFILE;                                 #  Path for Masterfile
my $PEPFILE;                                    #  Path for the peptide file used
my $TAKEINPUTFILE;
my $FLIPBLASTPROTS = [];                        #  Array containing the Proteins predicted by Blast and Flip
my $HYPPROTS = [];                              #  Array containing the Proteins predicted by Blast and Flip and reprocessed after
my $OUTPUTFILE;                                 #  Path for the new
my $USETRNASCANSE;                              #  T or F : use of tRNAscanSE in the annotation 

#--Specific for finding the closest organism
my $BLASTOUTFORFINDINGCLOSESTORGANISM;          #  The blast output used to find closest organism 
my $MINLENGTHORFFORFINDINGCLOSESTORGANISM;      #  Minimum ORF size generated with flip
my $BLASTEVALUECUTOFFFORFINDINGCLOSESTORGANISM; #  Minimum blast e-value thresold
$BLASTOUTFORFINDINGCLOSESTORGANISM =  $TMPDIR . "/blastout1";


#--Specific for the annotation (parameters for flip, blastall and organization)
my $BLASTOUTPUT                   ;             #  The path for blast file results	
my $BLASTEVALUECUTOFF = 0.0001;			#  Cutoff value for the blast
my $MINLENGTHORF = 30;				#  This is the minimum length for creating an ORF with flip
my $MAXLENGTHFORGROUPINGORF = 1000;		#  Minimum size of a gap between 2 ORf. If 2 same ORF
$BLASTOUTPUT = "blastout2";


#############################
# Environment Verifications #
#############################
# Added by David To 11th February 2005
$ENV{"BLASTMAT"} = "/share/supported/apps/ncbi/data";

die "Please make sure the BLASTMAT environment variable is set\n" .
    "to point to a directory where the blast matrices are stored.\n"
    unless defined($ENV{"BLASTMAT"}) && (-d $ENV{"BLASTMAT"}) &&
           (-f ($ENV{"BLASTMAT"} . "/PAM30"));

die "Please make sure that the 'blastall' executable is in your\n" .
    "current command search path.\n"
    unless grep(-x ($_ . "/blastall"),split(/:/,$ENV{"PATH"})) > 0;
    
    
    ############  THINGS TO PUT IN VERIFICATION ########
     #      - Check if tRNAscanSE is installed
     #      - Check if flip is installed
     #      - Check if formatdb is installed
     
#####################################################
# Command-Line Arguments Processing and verification#
#####################################################

##------------------------------------------------##
&GetOptions ;

##################
# HELP AND USAGE #
##################

sub GoOut {
	print "----------------\n";
	#&Usage;
	exit 0;

}

sub Help {

print "Help for mfannot.pl\n";
print "-------------------\n";
#&Usage;

}


################
# Trap Signals #
################

sub SigCleanup { # private
     die "\nExiting: received signal \"" . $_[0] . "\".\n";
     # Note that some cleanup will be performed in the END block at this point.
}
$SIG{'INT'}  = \&SigCleanup;
$SIG{'TERM'} = \&SigCleanup;
$SIG{'HUP'}  = \&SigCleanup;
$SIG{'QUIT'} = \&SigCleanup;
$SIG{'PIPE'} = \&SigCleanup;
$SIG{'ALRM'} = \&SigCleanup;

###############################
#   M A I N   P R O G R A M   #
###############################


open (LOGFILE, ">$LOGFILE") if $ISLOGFILE;


my $header = "######################################################################\n".
             "MFANNOT, ORGANELLAR GENOME ANNOTATION PROGRAMM                        \n".
             "VERSION $VERSION                                                      \n".
	     "Programmed by david To, Thomas Hoellinger, Pierre Rioux and Franz Lang\n".
	     "######################################################################\n\n";
print $header if $DEBUG;
print LOGFILE $header if $ISLOGFILE;    

##--OPTIONS OF THE PROGRAM
my $options ="----------------------------------\n".
             "        General Options	        \n".
             "----------------------------------\n";
$options .= "new Masterfile created : $OUTPUTFILE\n";
$options .= "Genetic code : $GENCODE\n";
$options .= "Tag for annotation : $TAGNAME\n";

if ($SIMILARITYSEARCH) {
  if ($TAKEINPUTFILE == 0) {
    $options .= "Look in the peptide library\n";
    $options .= "Directory : $PEPLIBRARY\n";	     
  }
  else {
    $options .= "Peptide file : $PEPFILE\n";
  }
}
else {
   $options .=  "Any search in gene similarity for annotation\n";
}

if ($USETRNASCANSE == 0) {
  $options .= "No usage of tRNAscanSE\n";
}
else {
  $options .= "Usage of tRNAscanSE\n";
}

print LOGFILE $options if $ISLOGFILE;           #Print options in the logfile
print $options if $DEBUG;                       #Print the options on the screen 

  
mkdir($TMPDIR,0700) || die "Error: can't create work directory '$TMPDIR': $!\n";

if ($TAKEINPUTFILE == 0 && $SIMILARITYSEARCH) {  
  print "----------------------------------\n",  # First print : debug
        "  Look For The Closest Organism   \n",
        "----------------------------------\n" if $DEBUG;
  print LOGFILE "----------------------------------\n",  # First print : debug
                "  Look For The Closest Organism   \n",
                "----------------------------------\n" if $ISLOGFILE;
  my $optionsforlooking;                         # options, 
  $optionsforlooking = "Minimum size ORF, for flip running : $MINLENGTHORFFORFINDINGCLOSESTORGANISM\n";
  $optionsforlooking .= "Blast e-value cutoff : $BLASTEVALUECUTOFFFORFINDINGCLOSESTORGANISM\n";
  print "options :\n$optionsforlooking" if $DEBUG;
  print LOGFILE "options :\n$optionsforlooking" if $ISLOGFILE;
  $PEPFILE = &FindClosestOrganism;               # Look for the closest Organism
  if (not defined ($PEPFILE)) {
    die "Peptide file not found in pep directory\n";
  }
  $PEPFILE = $PEPLIBRARY. "/" . $PEPFILE;
  print "The closest Organism is : $PEPFILE\n" if $DEBUG;
  print LOGFILE "The closest Organism is : $PEPFILE\n" if $ISLOGFILE;
}

if ((not -r  $PEPFILE) && $SIMILARITYSEARCH) {
  die "Unable to read $PEPFILE\n";
}

print "----------------------------------\n",
      "           Annotation             \n",
      "----------------------------------\n" if $DEBUG;
print LOGFILE "----------------------------------\n",
              "           Annotation             \n",
              "----------------------------------\n" if $ISLOGFILE;
my $step=1;
print "$step) Parsing masterfile...\n" if $DEBUG;
$step += 1; 
my $pirmaster = PirObject::Masterfile->ObjectFromMasterfile($MASTERFILE);
my $contigs = $pirmaster->get_contigs();
my $numbercontigs = 0;                              # Number of contigs in the masterfile
my $numberannot = 0;                                # Number of annotations detected in the program

$numbercontigs += scalar (@$contigs);
foreach my $contig ( @$contigs) {
    my $annotations = $contig-> get_annotations();
    $numberannot += scalar (@$annotations);
    #foreach my $annot ( @$annotations) {
    #    print "annot : ";
    #	print  "name ", $annot->get_genename, " ", if defined($annot->get_genename);
    #	print  "start ", $annot->get_startpos, " ", if defined($annot->get_startpos);
    #	print  "end ", $annot->get_endpos, if defined($annot->get_endpos);
    #    print "\n";
    #}
}

print "Number of contigs in Masterfile : $numbercontigs\n",
      "Number of annotations (or commentaries) detected : $numberannot\n" if $DEBUG;

print LOGFILE "Number of contigs in Masterfile : $numbercontigs\n",
              "Number of annotations (or commentaries) detected : $numberannot\n" if $ISLOGFILE;
      
      	      
if ($SIMILARITYSEARCH) {
  $options = "Options : \n";                  # Options & parameters used for the blast
  $options .= "Minimum size ORF, for flip running $MINLENGTHORF\n";
  $options .= "Blast e-value cutoff : $BLASTEVALUECUTOFF\n";
  print $options if $DEBUG;
  print LOGFILE $options if $ISLOGFILE;

                                 # Run the programm step by, to know the right step            
  print "$step) Run Flip...\n" if $DEBUG;
  $step += 1; 
  &RunFlip;

  print "$step) Run Blast...\n" if $DEBUG;
  $step += 1;  
  &BlastFlipVSGene;

  print "$step) Parse Information From Blast Results...\n" if $DEBUG;
  $step += 1;
  &ParseInformationFromBlastResult ($pirmaster, $TAGNAME);

  print "$step) Fill Hyp prot Array With FLIPBLASTPROTSArray...\n" if $DEBUG;
  $step += 1; 
  &FillHYPPROTSArrayWithFLIPBLASTPROTSArray;

  print "$step) Organise Prot Array...\n" if $DEBUG; 
  $step += 1; 
  &OrganiseHYPPROTSArray ($pirmaster);

  print "$step) Annotate from Hyp Prots Array...\n" if $DEBUG;
  $step += 1; 
  &AnnotateMfFromHYPPROTSArray ($pirmaster);
  
  print "$step) Process Empty ORFs...\n" if $DEBUG; 
  $step += 1; 
  &AnnotateEmptyOrfs ($pirmaster);
}
  
if ($USETRNASCANSE) {
    print "$step) Annotate with tRNAscanSE...\n" if $DEBUG;
    $step += 1; 
    &AddGeneFeatureUsingtRNAscanSE ($pirmaster, "trnascanSE");
}    
    
print "----------------------------------\n",
      "       End of the Programm        \n",
      "----------------------------------\n" if $DEBUG;  

my $cntigs = $pirmaster->contigs();
my $annotations = $cntigs->[0]->annotations();

     
      
#system ("rm $TMPDIR -f -r") || print "problem for cleaning; 


&LogInfo ($pirmaster);
print "Dumping new masterfile in $OUTPUTFILE...\n" if  $DEBUG;
$pirmaster->ObjectToMasterfile("$OUTPUTFILE");

 

if ($ISLOGFILE == 1) {
        print "close Logfile : $LOGFILE\n" if $DEBUG;
	close LOGFILE || print "Logfile not closed\n";
}
exit 0;

#############################
#   S U B R O U T I N E S   #
#############################

##############################
# Parse command-line options #
##############################

sub GetOptions {          # this function is here to manipulate options

    my $option = new PirObject::Option ();   #  buil a new option model
    $option->FillOption ();                  #  This one buil with the default option and look for a rc file
    
    ### Now The object contains all the options
    
    
    #--General options
    $DEBUG = $option->debug;                     #  Debug mode. If true, display message on the screen
    $GENCODE = $option->genetic;                 #  Genetique code
    $LOGFILE = $option->logfile;                 #  log file : store all the information about run
    $SIMILARITYSEARCH = $option->similarity;     #  Usefull for running similaritie gene process for annot.
    $ISLOGFILE= $option->islogfile;              #  Just to know if the $LOGFILE is not empty (0 or 1)
    $PEPLIBRARY = $option->pepdirectory;         #  Path for peplibrary directory
    $MASTERFILE = $option->masterfile;           #  Path for Masterfile
    $PEPFILE = $option->inputfile;               #  Path for the peptide file used
    $OUTPUTFILE = $option->outputfile;           #  Path for the new
    $USETRNASCANSE = $option->tRNAscanSE;        #  T or F : use of tRNAscanSE in the annotation 
    $TAKEINPUTFILE = $option->takeinputfile;     #  A boolean saying if programme is taking an input file
    $TAGNAME = $option->tagname;                 #  Adds a tag  
    $FORCEANNOT = $option->force;                #  Force the annotation when 2 annotations have the same name
        
    #--Specific for finding the closest organism
    $MINLENGTHORFFORFINDINGCLOSESTORGANISM = $option->flip1;       #  Minimum ORF size generated with flip
    $BLASTEVALUECUTOFFFORFINDINGCLOSESTORGANISM = $option->blast1; #  Minimum blast e-value thresold
   

    #--Specific for the annotation (parameters for flip, blastall and organization)	
    $BLASTEVALUECUTOFF = $option->blast2;            #  Cutoff value for the blast
    $MINLENGTHORF = $option->flip2;                #  This is the minimum length for creating an ORF with flip
    $MAXLENGTHFORGROUPINGORF = $option->intronsize; #  Minimum size of a gap between 2 ORf. If 2 same ORF

    
}

sub FindClosestOrganism    # This function is regarding into the PEPLIBRARY if what is the file having
{                          # the
	
    my $directory = $PEPLIBRARY;                     # Data directory
    my $pepfile = "$TMPDIR/Pep.txt";
    my $peplib = "$TMPDIR/Peplib";
    my $flipcutoff = $MINLENGTHORFFORFINDINGCLOSESTORGANISM;
    my $blastoutput = $BLASTOUTFORFINDINGCLOSESTORGANISM;
    my $blastcutoff = $BLASTEVALUECUTOFFFORFINDINGCLOSESTORGANISM;
	
    opendir (DIR, $directory) or die 'can not open directory\n';        # Open the directory
    my @files = grep {/\.pep$/ && -f "$directory/$_"} readdir (DIR);    # Keep the existing *.pep files
    close (DIR);
	
	
    if (-f $pepfile) {
        system ("rm -f $pepfile");
    }
    foreach (@files) {
        system ("cat $directory/$_ | sed 's/^>.*/>$_/' >> $pepfile")	
    }	
	
	
    #########	FIRST RUN FORMATDB	###################
	
    my $cmdformatdb = "formatdb -p T -i $pepfile -n $peplib";
    print "$cmdformatdb\n" if $DEBUG;
    my $resformatdb = system("$cmdformatdb");
    #print $resformatdb if $DEBUG;
	
    #########	THEN RUN FLIP	###################	
    my $cmdflip = "flip -l $flipcutoff $MASTERFILE > $TMPDIR/flip1.output";
    my $resflip =  system $cmdflip;
    print "$cmdflip\n" if $DEBUG;
    #print "$resflip\n" if $DEBUG;		

    #########	THEN RUN BLAST	###################		

    my $cmdblast = "blastall -p blastp -d $peplib -i prot.lst -o $blastoutput";  #  -p programm
                                                                                 #  -d database
                                                                                 #  -i input
                                                                                 #  -o output
    print "$cmdblast\n" if $DEBUG;                                                             
    my $resblast = system("$cmdblast");
    #print $resblast if $DEBUG;
	
    #########	THEN PARSE THE BLAST ###############	
	
    my %bestresults;
    if (! -r $blastoutput) { # it's supposed to be here at this point.
        die "Error: can't find report from blastall ?!?\n";
    }
    my $searchio = new Bio::SearchIO (
                                       -format => 'blast',
                                       -file   => $blastoutput,
                                      );
   RESULT : while (my $result = $searchio->next_result() ) {
                my $contigname = $result->query_name()        || "Unknown ID";
                my $rdesc      = $result->query_description() || "Unknown Query Description";
                my $dbname     = $result->database_name()     || "Unknown DB name";
                my @hits       = $result->hits();             # Bio::Search::Hit::HitI		
                my $numhits    = scalar(@hits);               # normally, only one! 
                next RESULT if $numhits < 1;
                my $hit=$hits[0];
                my $hypprotein   = $hit->name();              # returns the name of the Hit sequence
                my $desc         = $hit->description();       # Get the description of the query sequence
                my $score        = $hit->score();             # Get the blast score
                my $evalue	 = $hit->significance();      # Get the e-value

                if ($evalue < $blastcutoff) {                 # Keep only if evalue is good
                    $bestresults {$hypprotein} += 1; 
                }		 
	   }
	
    ##########   THEN LOOK FOR THE BEST : THE MAX OCCURENCES IN THE ARRAY  #######
	
    my @bestresultskeys = keys(%bestresults);
	
    if (scalar(@bestresultskeys) < 1) {                       # If there is no file
        return "";
    } 
	
    my $bestfile = $bestresultskeys[0];
    foreach (@bestresultskeys) {
        if ($bestresults {$_} > $bestresults {$bestfile}) {
            $bestfile = $_;
        }
        else {
            next;
        }
    }
	
    undef (%bestresults);
    return $bestfile || undef;
}

sub AnnotateEmptyOrfs {   #  This function takes the empty array of ORF and annotate it as ORFs

     my $pirmaster = shift; 

     EMPTYORF : foreach my $emptyorf (@$EMPTYORFS) {   #  process each non corresponding orf
     
	 my $contigname = $emptyorf->contigname;
	 
	 my $start = $emptyorf->start;
         my $end = $emptyorf->end;
	 my $strand = $emptyorf->strand;
	 my $arrow = ($strand == 1 ? '==>' : '<==');
	 
	 my $overlappingcutoff = 0.1;                 #  authorized overlapping  
	 my $minimumlengthorf = 500;                  #  minimum Orf size
	 
	 my $contig = $pirmaster->GetContigByName($contigname) || die "Can't get contig by name in AnnotateEmptyOrfs\n";
         my $annotations = $contig->get_annotations;
	 
	 next EMPTYORF if (abs($start - $end) < $minimumlengthorf);   
	 
	 #print "--------------------------\n";
	 #print "ORF  $start  $end  $strand\n";
	  
         ANNOT : foreach my $annotation (@$annotations) {
	     
	    #print "verification";
	   # print "ca tourne \n"; 
	    
	     #print "type",  $annotation->type, "\n" if (defined($annotation->type));
	     
	     
	     next ANNOT if ((not defined($annotation->type)) or ($annotation->type ne 'G'));       
	     
	     #  process only if it's a gene, 
	     
	     
	     #print "c dedans qd meme\n";
	     
	     
	     my $annotstart = $annotation->startpos;
	     my $annotend = $annotation->endpos;
	     my $annotarrow = $annotation->direction;
	     my $annotstrand;
	     if ($annotarrow =~ /\.*==>\.*/) { $annotstrand = -1; }  #  We get the strand
	     else                            { $annotstrand = 1;  }
	     
	     
	     
	     
	     # SIZE CHECK
	     
	     
	     if ($strand == $annotstrand) {           #  Gene and empty orf must be on the same strand
	                                              #  For calculation
		
		#### Case were it seems to work
	        next ANNOT if (($strand == -1) && (($start <= $annotend) or ($end >= $annotstart)));
		next ANNOT if (($strand == 1) && (($start >= $annotend) or ($end <= $annotstart)));
		
		#### Case were it doesn't work
		
		######## FOUR CASES
						      
		####  1) ORF is inside the gene and longer than the gene
		####         |___________________|      ORF
		####            |______________|        GENE
		
		if ($strand == -1 && $start >= $annotstart && $end <= $annotend ) {
		    #print "ca merde ds 1a\n";
		    next EMPTYORF;
		}
		if ($strand == 1 && $start <= $annotstart && $end >= $annotend) {
		    #print "ca merde ds 1b\n";
		    next EMPTYORF;    
		}				       
		
		
		####  2) ORF is inside the gene and smaller than the gene
		####            |_____________|        ORF
		####         |___________________|     GENE
		
		if ($strand == -1 && $start <= $annotstart && $end >= $annotend ) {
		    #print "ca merde ds 2a\n";
		    next EMPTYORF;
		}
		if ($strand == 1 && $start >= $annotstart && $end <= $annotend) {
		    #print "ca merde ds 2b\n";
		    next EMPTYORF;    
		}
		
		####  3) ORF is overlapping the gene
		####                        |___________|        ORF
		####         |____________________|              GENE
		
		if ($start >= $annotstart && $end >= $annotend) {
		    
		    my $overlapping=0;                           #  Overlapping calculation
		    $overlapping += abs($annotstart-$end) if ($strand == -1);
		    $overlapping += abs($annotend-$start) if ($strand == 1);
		    
		    $overlapping = $overlapping / abs ($end - $start);
		    
		    if ($overlapping > $overlappingcutoff) {
		        #print "ca merde ds 3\n";
			#print "ANNOT $annotstart $annotend $annotstrand\n";
			next EMPTYORF;
	            }
		     
		}
		
		####  4) ORF is overlapping the gene
		####        |__________|              ORF
		####              |________________|  GENE
		
		if ($start <= $annotstart && $end <= $annotend) {
		
		    my $overlapping=0;                        #  Overlapping calculation
		    $overlapping += abs($end-$annotstart) if ($strand == -1);
		    $overlapping += abs($start-$annotend) if ($strand == 1);
		    
		    $overlapping = $overlapping / abs ($end - $start);
		    
		    if ($overlapping > $overlappingcutoff) {
		       #print "ca merde ds 4\n";
		       #print "ANNOT $annotstart $annotend $annotstrand\n";
		       next EMPTYORF;
	            }
		}
		
		
	    }	
	
	    	
						                                        
	     
	}
	
	#print "bon ques ce quon ajoute ?\n"; 
	
	 #####  If all the annotation has been parsed without founding something 
	 #####  To unallow annotation of ORF, -> Empty orf annotation
	 
	 #print "SIZE OF ANNOT ORF : ", abs ($start-$end), "\n";
	 
	 my $orfannot = new PirObject::AnnotPair (
	                        type      => "G",  
              			genename  => "ncOrf",
                        	startpos  => $start,
                        	endpos    => $end,
                        	direction => $arrow,
                        	startline => ";     G-ncOrf $arrow start ;; MFFEAT=$TAGNAME",
                        	endline   => ";     G-ncOrf $arrow end ;; MFFEAT=$TAGNAME",
                    	);
    
         &AddAnnotToPirMaster($pirmaster,$contigname,$orfannot);
     
     }  #  END OF FOR EACH EMPTY ORFS


}

sub AnnotateMfFromHYPPROTSArray {	#	This function annotates the masterfile from the blast results


	my $pirmaster = shift;

	foreach my $hyprot (@$HYPPROTS)
	{
		my $name = $hyprot->name;
		my $contigname = $hyprot->contigname;
		my $start = $hyprot->start;
		my $end = $hyprot->end;
		my $arrow = ($hyprot->strand == -1 ? '<==' : '==>');
		my $tag = $hyprot->remark;
		
	
		my $protannot = new PirObject::AnnotPair (
		                type      => "G", 
              			genename  => "$name",
                        	startpos  => $start,
                        	endpos    => $end,
                        	direction => $arrow,
                        	startline => ";     G-$name $arrow start ;; MFFEAT=$TAGNAME ;; $tag",
                        	endline   => ";     G-$name $arrow end ;; MFFEAT=$TAGNAME ;;$tag",
                    	);
        	&AddAnnotToPirMaster($pirmaster,$contigname,$protannot);
	
		my $exons =  $hyprot->exons;
		
				
		my $number = 1;
		foreach my $exon (@$exons) {
			
			#my $exonstart = ($hyprot->strand == 1 ? $exon->start + $start : $start - $exon->start);
			#my $exonend =   ($hyprot->strand == 1 ? $exon->end + $start : $start - $exon->end );
			my $exonstart = $exon->start;
			my $exonend = $exon->end;
			my $exonstrand = $exon->strand;
			
			#print "Exons $name $exonstart $exonend $exonstrand\n";
			
			my $exonannotstart = new PirObject::AnnotPair (
			        type      => "C",
              			genename  => "comment",
                        	startpos  => $exonstart,
                        	direction => $arrow,
                        	startline => ";;     possible G-$name-E$number $arrow start ;; MFFEAT=$TAGNAME",
			);
			my $exonannotend = new PirObject::AnnotPair (
			        type      => "C",
              			genename  => "comment",
                        	startpos  => $exonend,
                        	direction => $arrow,
                        	startline => ";;     possible G-$name-E$number $arrow end ;; MFFEAT=$TAGNAME",
			);
			$number++;	
			&AddAnnotToPirMaster($pirmaster,$contigname,$exonannotstart);
			&AddAnnotToPirMaster($pirmaster,$contigname,$exonannotend);		
		
		}
	
	
	}


}

sub OrganiseHYPPROTSArray {	#	this function is supposing to find the real start and recreating exon if necessary

	my $pirmaster = shift;
	my $possiblestarts = ['ATG', 'AUG'];

	#################   The first thing is to look for the new start #########################
	foreach my $hypprot (@$HYPPROTS) {
	
		my $oldstartpos = $hypprot->start;					#	Get the old start position
		my $newstartpos = $hypprot->start;
		my $currentpos  = $hypprot->start; 
		my $found = 0;
		my $contig =  $pirmaster->GetContigByName ($hypprot->contigname);	#	Get the contig
		my $seq = $contig->sequence;						#	Get sequence
		$seq =~ s/!//g;
		my $end = $hypprot->end;
		
		####	Two cases
		if ($hypprot->strand == 1)						#	Right strand
		{
			CODON : while (not ($found) and ($currentpos < $hypprot->end))
			{
				my $codon = uc (substr($seq, $currentpos-1, 3));
				#print $hypprot->name, " $codon $currentpos\n";
				
				if (ValueIsIn($possiblestarts, $codon) == 1)
				{
					$found = 1;
					$newstartpos = $currentpos;
					next CODON;
				}
				else {
					$currentpos += 1;
					next CODON;
				}
			}		
		}
		else 									#	Complementary strand
		{
			CODON : while (not ($found) and ($currentpos-3 > $hypprot->end))
			{
				my $codon = uc (substr($seq, $currentpos-3-1, 3));
				$codon =~ tr/ATUGCatugc/TAACGtTAACG/;
				$codon = reverse ($codon);				#	Reverse and complementary
				
				if (ValueIsIn($possiblestarts, $codon) == 1)
				{
					$found = 1;
					$newstartpos = $currentpos-1;
					next CODON;
				}
				else {
					$currentpos -= 1;
					next CODON;
				}
			}
		}
		
		#print $hypprot->name, " ", $newstartpos, " ", $oldstartpos, "\n";
		
		#	Now we have found the new start codon
		#	Exons have to be reorganized
		my $exons =  $hypprot->exons;
		@$exons = sort {							
				if ($hypprot->strand == 1) {
				
					$a->start <=> $b->start;
				}
				elsif ($hypprot->strand == -1){
				 
					
					$b->start <=> $a->start;
				}
		} @$exons;	#	Exons are sorted
		
		my $newexons = [];
		EXON : foreach my $exon (@$exons) {
		
			if ($hypprot->strand == 1) {
				if ($exon->start < $newstartpos) { #	2 case Or the exon changes his first start or it doesnt belong anymore to the prot
					if ($exon->end <  $newstartpos)	{	#	it doesnt belong anymore to the prot
						next EXON;
					}
					else {					# 	it belongs but start has changed
						$exon->set_start ($newstartpos);
						push (@$newexons, $exon);
					}
				}
				else {
					push (@$newexons, $exon);
				}
			}	#	End strand == 1
			else {
				if ($exon->start > $newstartpos) { #	2 case Or the exon changes his first start or it doesnt belong anymore to the prot
					if ($exon->end >  $newstartpos)	{	#	it doesnt belong anymore to the prot
						next EXON;
					}
					else {					# 	it belongs but start has changed
						$exon->set_start ($newstartpos);
						push (@$newexons, $exon);
					}
				}
				else {
					push (@$newexons, $exon);
				}	 
			}
		
		}
		
		undef (@$exons);	# 	unreferencing the array
		$hypprot->set_start ($newstartpos);
		$hypprot->set_exons ($newexons);
		
		
	}	#	End for each prot

}	#	End function

sub ValueIsIn {		# check if a value is in an array

	my $array = shift;
	my $value = shift;
	
	foreach (@$array)
	{
		if ($value eq $_)
		{
			return 1;
		}
	}
	
	return -1;

}

sub RunFlip { # This function run flip with the mf
	
    my $cmdflip = "flip -s ATG -m -l $MINLENGTHORF -g $GENCODE $MASTERFILE > $TMPDIR/flip2.output";
    my $resultat = system ($cmdflip);	
    print "$cmdflip\n" if $DEBUG;
    # print "$resultat\n" if $DEBUG || defined $resultat;
    # After that flip will create files in the local directory wich are called prot.lst, and prot.src

} 



sub BlastFlipVSGene {	# it runs blast with the flip results against file containing genes 


    my $file = $PEPFILE;                                # undef should never happen in fact.
    my $escaped_file = $file;
    $escaped_file =~ s#'#'\\'#g;         
    my $command = "formatdb -p 'T' -t banque -i $escaped_file -n $TMPDIR/mf -l fdb.log";
    print "$command\n" if $DEBUG;
    my $resformatdb = system($command);
    #print "$resformatdb\n" if $DEBUG;

    #RUN FOR BLAST : run blast with the db created and the flip results		
    my $cmdblast = "blastall -p blastp -d $TMPDIR/mf -i prot.lst -D $GENCODE -o $BLASTOUTPUT";
    print "$cmdblast\n" if $DEBUG;
    my $resblast = system ($cmdblast);
    #print "$resblast\n" if $DEBUG;
	
}

sub ParseInformationFromBlastResult {

    my $pirmaster   = shift;
    my $tag         = shift || "aVwXyZ";
    
    # This loop goes through the different fasta input files that
    # are currently defined in MfAnnotConfig.pir
   
        
    my $type = 'PROT';
    my $file = $PEPFILE;
    my $blastoutput = $BLASTOUTPUT;
    if (! -r $blastoutput) { # it's supposed to be here at this point.
        die "Error: can't find $type report from blastall ?!?\n";
    }
    my $searchio = new Bio::SearchIO (
                                       -format => 'blast',
                                       -file   => $blastoutput,
                                     );
    while (my $result = $searchio->next_result() ) {
        &FillFLIPBLASTPROTArrayFromBlastResult($pirmaster,$type,$result,$tag);
    }
}

sub FillFLIPBLASTPROTArrayFromBlastResult {
    my $pirmaster = shift;	#	Pirmaster Object
    my $type      = shift;  	# 	'DNA' or 'PROT'
    my $result    = shift; 	# 	an object implementing Bio::SearchIO::Result::ResultI
    my $tag       = shift || "bVwXyZ";
    
    if (!$result) {return;}

    my $contigname = $result->query_name()        || "Unknown ID";
    $contigname =~ s/\;//g;	#	Delete false caracter			
    my $rdesc      = $result->query_description() || "Unknown Query Description";
    my $dbname     = $result->database_name()     || "Unknown DB name";
    my @hits       = $result->hits();# Bio::Search::Hit::HitI		
    my $numhits    = scalar(@hits);  # normally, only one! 
    return if $numhits < 1;
    #print "description : $rdesc\n";
    #print "Found result: ID=$contigname DESC=$rdesc DBNAME=$dbname with $numhits hits\n" if $DEBUG;
    #print "Found result: ID=$contigname DESC=$rdesc DBNAME=$dbname with $numhits hits\n";
    #my $contigus = $pirmaster->get_contigs();

          
    # We have an hypothetical protein and we want to know if it'real
    my ($strand, $start, $end) = ($rdesc =~ /(orig|compl).\s+(\d+)\s+to\s+(\d+)\s+;\s+[\w\.\!]+$/);
    #print "ligne 376 $strand, $start, $end \n";
    my $debut = ($start < $end ? $start : $end);
    my $fin = ($start < $end ? $end : $start);
    
    #sort (@hits)
    my $arrow = ($strand eq 'orig' ? '==>' : '<==');
    
    #foreach my $hit (@hits) {
    my $hit=$hits[0];
    #my $hypprotein   = $hit->name();		#	returns the name of the Hit sequence
    my $desc         = $hit->description();	#	Get the description of the query sequence
    #print "description $desc\n"; 
    my ($hypprotein) = ($desc =~ /\s*([\w]*)\s*;/); 
    my $score        = $hit->score();		#	Get the blast score
    my $evalue	 = $hit->significance();	#	Get the e-value
    my @hsps = $hit->hsps;			# 	High Scoring pairs : Bio::Search::HSP::BlastHSP
    
    $strand = ($strand eq 'orig' ? 1 : -1);
    
    ###--------------------QUIT THE FUNCTION IF EVALUE IS TOO  WEAK-----------------------------#
    if ($evalue > $BLASTEVALUECUTOFF) {	        # If the e-value is not enough for these ORF you can
                                                # It creates an Empty ORF 
    	my $newemptyorf = new PirObject::EmptyOrf (start   => $start,
                                                   end    => $end,
				                   strand => $strand,
				                   score  => $evalue,
						   contigname => $contigname,
				                   );
	push (@$EMPTYORFS, $newemptyorf);       # Put into the array, to be processed after   
	return;
    }
    ###-----------------------------------------------------------------------------------------#
    
    if (scalar(@hsps) == 0) {
    	return;				#	An ORF that has a good evalue but no HSP => impossible but ...
    }
    elsif (scalar(@hsps) == 1) {
    		
    }	
    
    #----	Creating a new ORF object	---
    my $neworf = new PirObject::Orf (start   => $start,
                                      end    => $end,
				      strand => $strand,
				      score  => $evalue,
				      hsps   => []);
    my $refhsparray = $neworf->hsps;	#	An array reference,					      
    foreach (@hsps) {
    	my $newhsp = new PirObject::Hsp (start  => $_->start,
					 end    => $_->end,
					 strand => $_->strand);
	push (@$refhsparray, $newhsp);
	}
    
				      			      
    my $newflipblastprot = GetFlipBlastProtByNAmeAndContigName ($hypprotein, $contigname);
    #	Two case
    if (defined $newflipblastprot) {	#	Wether the prot is already defined
    	my $reforfarray = $newflipblastprot->orfs;
	push (@$reforfarray, $neworf);	#	Annd we just add a new orf
    }
    else {
    	my $newflipblastprot = new PirObject::FlipBlastProt (name        => $hypprotein,	#	First we create the flipblast prot
							     contigname => $contigname,
							     orfs       => []);
	my $reforfarray = $newflipblastprot->orfs;
	push (@$reforfarray, $neworf);	#	Annd we just add a new orf
	push (@$FLIPBLASTPROTS, $newflipblastprot);
    }	
    
    
    
    #print scalar(@hsps),"hsp pour $hypprotein\n";
	
        
}

sub FillHYPPROTSArrayWithFLIPBLASTPROTSArray {	#	This function fill the HYPPROTS array (array of hypothetical proteins with
						#	FLIPBLASTPROTS array (array of ORF and hsp)

	#	This is mainly the algorithm given by Franz
	foreach my $flipblastprot (@$FLIPBLASTPROTS) {		#	For each fliup blast protein
		my $name = $flipblastprot->name;
		my $contigname = $flipblastprot->contigname;
		
		
		
		my $orfs = $flipblastprot->orfs;
		my $numberorfs = scalar (@$orfs);
		
		# print "$name,  $contigname $numberorfs\n";
		
		if ($numberorfs < 1) {
			return;			#	Impossible but ...
		}
		elsif ($numberorfs == 1) {	#	Most of the case where there is no introns
			my $hsps = @$orfs[0]->hsps;
			
			#Two case : Are the HSP in a same frame or not
			my $starthsps = [];	#	All of the start of the hsp
			my $strandhsps = [];	#	All of the strand in the HSP
			
			foreach my $hsp (@$hsps)
			{
				push (@$starthsps, $hsp->start);
				push (@$strandhsps, $hsp->strand);
			}
			
			
			if (IsSameFrame($starthsps) ==- 1) {
				#-------------------------------------------#
				#THE PROTEIN HAS INTRON OR THERE IS A SEQUENCING PROBLEM
				
				# 1) creating the new hypothetical protein
				my $newhypprot = new PirObject::HypProt (name       => $name,
									 contigname => $contigname,
									 start      => @$orfs[0]->start,
									 end        => @$orfs[0]->end,
									 strand     => @$orfs[0]->strand,
									 exons      => [],
									 remark     => "One Reading Frame but HSP not in the same frame. protein seems to have introns, or sequencing problem"
									 );
				
				# 2) creating the potential exon
				my $exons = $newhypprot->exons;
				foreach my $hsp_exon (@$hsps)
				{
					my $exonstart = (@$orfs[0]->strand == 1 ? @$orfs[0]->start + $hsp_exon->start : @$orfs[0]->start - $hsp_exon->start);
					my $exonend = (@$orfs[0]->strand == 1 ? @$orfs[0]->start + $hsp_exon->end : @$orfs[0]->start - $hsp_exon->end);
					
					my $exon = new PirObject::Exon (start  => $exonstart, 
									end    => $exonend,
									strand => @$orfs[0]->strand
									);
					push (@$exons, $exon);
				}
				
				push (@$HYPPROTS, $newhypprot);		#	Don't forgett to put the hyp prot. in the array
			
			}
			else {
				#-------------------------------------------#
				#THE PROTEIN HAS NO INTRON IN THE SEQUENCE BECAUSE ALL THE HSP ARE IN THE SAME FRAME
			
				my $newhypprot = new PirObject::HypProt (name       => $name,
									 contigname => $contigname,
									 start      => @$orfs[0]->start,
									 end        => @$orfs[0]->end,
									 strand     => @$orfs[0]->strand,
									 remark     => "One Reading Frame. Protein seems to have no introns, all hsp are on the same frame"
									 );
			
				push (@$HYPPROTS, $newhypprot);		#	Don't forgett to put the hyp prot. in the array
			
			}
			
			
			
			
			
			
		}
		else{	# 	On the case you have many ORFs
			
			my $neworfs = [];
			
			@$orfs = sort {		#	The ORFs are classified and sorted by starnd and start, stop positions
				my $stranda = $a->strand;
				my $strandb = $b->strand;
				if ($stranda != $strandb) {
				
					$a->strand <=> $b->strand;
				}
				else {
				 
					if ($stranda == 1) {
						$a->start <=> $b->start;
					}
					else {
						$a->end <=> $b->end;
					}	
				}
				} @$orfs;
				
			
			my $newhypprot = undef;		#	This is the current hyp. prot
			
			ORF : foreach my $orf(@$orfs)
			{
				
			
				#	Now the thing is to create a new hyp prot if the conditions are not required
				#	First : if the $currentprot is not defined
				
				#------------	case	 1 : first ORF
				if (not defined($newhypprot)) {
				#	Here we create a new protein
				
					$newhypprot = new PirObject::HypProt (name       => $name,
									      contigname => $contigname,
									      start      => $orf->start,
									      end        => $orf->end,
								              strand     => $orf->strand,
									      exons      => [],
									      remark	 => "" 
									 );
					my $exons = $newhypprot->exons;
					my $hsps = $orf->hsps;
					foreach my $hsp_exon (@$hsps)
					{
						my $exonstart = ($orf->strand == 1 ? $orf->start + $hsp_exon->start : $orf->start - $hsp_exon->start);
						my $exonend = ($orf->strand == 1 ? $orf->start + $hsp_exon->end : $orf->start - $hsp_exon->end);
					
						my $exon = new PirObject::Exon (start  => $exonstart, 
										end    => $exonend,
										strand => $orf->strand
										);
						push (@$exons, $exon);
					}
									 
					next ORF; 
					
				}
				
				
				
				#------------	case	 2 : not the same strand
				if ($newhypprot->strand !=  $orf->strand)
				{
					#+++++++++++BEFORE PUSHING AN HYP PROT, CHECK+++++++++++++++++++++
					if ($newhypprot->remark eq "")				#	++
					{							#	++	
						my $exons = $newhypprot->exons;			#	++
						my $startexons = [];				#	++
						foreach my $exon (@$exons)			#	++
						{						#	++
							push (@$startexons, $exon->start);	#	++	
						}						#	++
						if (IsSameFrame($startexons) ==- 1)	#	++
						{						#	++
							$newhypprot->set_remark ("One Reading Frame but HSP not in the same frame. Protein may have introns, or sequencing errors");	#	++
						} else 						#	++
						{						#	++	
							$newhypprot->set_remark ("One Reading Frame and all HSP are in the same frame=>probably no introns");				#	++
						}						#	++
					}							#	++	
					push (@$HYPPROTS,  $newhypprot);			#	++
					#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
					
			
					$newhypprot = new PirObject::HypProt (name       => $name,
									      contigname => $contigname,
									      start      => $orf->start,
									      end        => $orf->end,
								              strand     => $orf->strand,
									      exons      => [],
									      remark     => ""	 
									 );
					my $exons = $newhypprot->exons;
					my $hsps = $orf->hsps;
					foreach my $hsp_exon (@$hsps)
					{
						my $exonstart = ($orf->strand == 1 ? $orf->start + $hsp_exon->start : $orf->start - $hsp_exon->start);
						my $exonend = ($orf->strand == 1 ? $orf->start + $hsp_exon->end : $orf->start - $hsp_exon->end);
					
						my $exon = new PirObject::Exon (start  => $exonstart, 
										end    => $exonend,
										strand => $orf->strand
										);
						push (@$exons, $exon);
					}				 
									 
					next ORF;
				}
				
				#print "On arrive desfois ici \n";
				
				#------------	case	 3-4 : Check space between 2 ORFs, including overlapping
				if ($orf->strand == 1)	#	Two case : right strand or opposite strand
				{
					#print "Mais on rentre la qd meme $name\n"; 
					if (($newhypprot->end > $orf->start) or (abs ($orf->start - $newhypprot->end) < $MAXLENGTHFORGROUPINGORF)) {
						#print "On rentre la dedans un jour $name\n"; 
						my $newstart = ($orf->start < $newhypprot->start ? $orf->start : $newhypprot->start);
						my $newend = ($orf->end > $newhypprot->end ? $orf->end : $newhypprot->end); 
					
						$newhypprot->set_start ($newstart);
						$newhypprot->set_end ($newend);
						$newhypprot->set_remark("Many ORFs. These proteins seems to have introns or sequencing problems");
					
						my $exons = $newhypprot->exons;
						my $hsps = $orf->hsps;
						foreach my $hsp_exon (@$hsps)
						{
							my $exonstart = ($orf->strand == 1 ? $orf->start + $hsp_exon->start : $orf->start - $hsp_exon->start);
							my $exonend = ($orf->strand == 1 ? $orf->start + $hsp_exon->end : $orf->start - $hsp_exon->end);
						
							my $exon = new PirObject::Exon (start  => $exonstart, 
											end    => $exonend,
											strand => $orf->strand
											);
							push (@$exons, $exon);
						}				 
										
						next;
					}
					else {
						#+++++++++++++++++++CHECK AND PUSH++++++++++++++++++++++++++++++++
						if ($newhypprot->remark eq "")				#	++
						{							#	++	
							my $exons = $newhypprot->exons;			#	++
							my $startexons = [];				#	++
							foreach my $exon (@$exons)			#	++
							{						#	++
								push (@$startexons, $exon->start);	#	++	
							}						#	++
							if (IsSameFrame($startexons) ==- 1)	#	++
							{						#	++
								$newhypprot->set_remark ("One Reading Frame but HSP not in the same frame. Protein may have introns, or sequencing errors");	#	++
							} else 						#	++
							{						#	++	
								$newhypprot->set_remark ("One Reading Frame and all HSP are in the same frame=>probably no introns");				#	++
							}						#	++
						}							#	++	
						push (@$HYPPROTS,  $newhypprot);			#	++
						#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
						$newhypprot = new PirObject::HypProt (name       => $name,
									      contigname => $contigname,
									      start      => $orf->start,
									      end        => $orf->end,
								              strand     => $orf->strand,
									      exons      => [],
									      remark     => ""	 
									 );
						my $exons = $newhypprot->exons;
						my $hsps = $orf->hsps;
						foreach my $hsp_exon (@$hsps)
						{
							my $exonstart = ($orf->strand == 1 ? $orf->start + $hsp_exon->start : $orf->start - $hsp_exon->start);
							my $exonend = ($orf->strand == 1 ? $orf->start + $hsp_exon->end : $orf->start - $hsp_exon->end);
						
							my $exon = new PirObject::Exon (start  => $exonstart, 
											end    => $exonend,
											strand => $orf->strand
											);
							push (@$exons, $exon);
						}				 
										
						next;	
					}
				}	
				else {			#	Opposite strand
				
					if (($newhypprot->start > $orf->end) or (abs ($orf->end - $newhypprot->start) < $MAXLENGTHFORGROUPINGORF)) {
						my $newstart = ($orf->start > $newhypprot->start ? $orf->start : $newhypprot->start);
						my $newend = ($orf->end < $newhypprot->end ? $orf->end : $newhypprot->end); 
					
						$newhypprot->set_start ($newstart);
						$newhypprot->set_end ($newend);
						$newhypprot->set_remark("Many ORFs. These proteins seems to have introns or sequencing problems");
					
						my $exons = $newhypprot->exons;
						my $hsps = $orf->hsps;
						foreach my $hsp_exon (@$hsps)
						{
							my $exonstart = ($orf->strand == 1 ? $orf->start + $hsp_exon->start : $orf->start - $hsp_exon->start);
							my $exonend = ($orf->strand == 1 ? $orf->start + $hsp_exon->end : $orf->start - $hsp_exon->end);
						
							my $exon = new PirObject::Exon (start  => $exonstart, 
											end    => $exonend,
											strand => $orf->strand
											);
							push (@$exons, $exon);
						}				 
										
						next;
					}
					else {
						#+++++++++++++++++++CHECK AND PUSH++++++++++++++++++++++++++++++++
						if ($newhypprot->remark eq "")				#	++
						{							#	++	
							my $exons = $newhypprot->exons;			#	++
							my $startexons = [];				#	++
							foreach my $exon (@$exons)			#	++
							{						#	++
								push (@$startexons, $exon->start);	#	++	
							}						#	++
							if (IsSameFrame($startexons) ==- 1)	#	++
							{						#	++
								$newhypprot->set_remark ("One Reading Frame but HSP not in the same frame. Protein may have introns, or sequencing errors");	#	++
							} else 						#	++
							{						#	++	
								$newhypprot->set_remark ("One Reading Frame and all HSP are in the same frame=>probably no introns");				#	++
							}						#	++
						}							#	++	
						push (@$HYPPROTS,  $newhypprot);			#	++
						#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
						$newhypprot = new PirObject::HypProt (name       => $name,
									      contigname => $contigname,
									      start      => $orf->start,
									      end        => $orf->end,
								              strand     => $orf->strand,
									      exons      => [],
									      remark     => ""	 
									 );
						my $exons = $newhypprot->exons;
						my $hsps = $orf->hsps;
						foreach my $hsp_exon (@$hsps)
						{
							my $exonstart = ($orf->strand == 1 ? $orf->start + $hsp_exon->start : $orf->start - $hsp_exon->start);
							my $exonend = ($orf->strand == 1 ? $orf->start + $hsp_exon->end : $orf->start - $hsp_exon->end);
						
							my $exon = new PirObject::Exon (start  => $exonstart, 
											end    => $exonend,
											strand => $orf->strand
											);
							push (@$exons, $exon);
						}				 
										
						next;	
					}
				
				
				}	
			}	#	End of foreach ORFs
			
			#+++++++++++++++++++CHECK AND PUSH++++++++++++++++++++++++++++++++
			if ($newhypprot->remark eq "")				#	++
			{							#	++	
				my $exons = $newhypprot->exons;			#	++
				my $startexons = [];				#	++
				foreach my $exon (@$exons)			#	++
				{						#	++
					push (@$startexons, $exon->start);	#	++	
				}						#	++
				if (IsSameFrame($startexons) ==- 1)	#	++
				{						#	++
					$newhypprot->set_remark ("One Reading Frame but HSP not in the same frame. Protein may have introns, or sequencing errors");	#	++
				} else 						#	++
				{						#	++	
					$newhypprot->set_remark ("One Reading Frame and all HSP are in the same frame=>probably no introns");				#	++
				}						#	++
			}							#	++	
			push (@$HYPPROTS,  $newhypprot);			#	++
			#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
			
		}	#	End of case you have many ORFS	
	}	#	End for each flipblastprot									
}	#	End function

sub IsSameFrame {	#	Check if the positions in the array are on the same frame

	my $tab = shift;	#	It's an array reference
	
	my $frame = @$tab[0] % 3;
	foreach (@$tab)
	{
		if (($_ % 3) ==  $frame) {
			next;	#	If it's still the same frame continue
		}
		else {
			return -1;	
		}
	}
	
	return 1;
}

sub IsSameStrand {	#	Check if the data in the array are on the same strand

	my $tab = shift;	#	It's an array reference
	
	my $strand = @$tab[0];
	foreach (@$tab)
	{
		if ($ ==  $strand) {
			next;	#	If it's still the same frame continue
		}
		else {
			return -1;	
		}
	}
	
	return 1;
}
		

sub GetFlipBlastProtByNAmeAndContigName {	
				# 	this function gives a FlipBlastProt with his name and contig name
	my $name = shift;	#	This the name of the GetFlipBlastProt
	my $contigname = shift;	#	This is the contigname of the FlipBlastProt
	
	foreach (@$FLIPBLASTPROTS) {
		if ($_->name eq $name and $_->contigname eq $contigname) {
			return $_;
		}
	}
	
	return undef;		# 	in the case where any object has been found
	
}


sub ParseCommandLineOptions {
    my $config = shift; # A PirObject::MfAnnotConfig
    my $argv = shift;

    $config->SetCurrentConfigToAllUnset();
    my $inputs = PirObject::MfAnnotConfig->InputFiles();

    my $concatswitches = "";
    my %switch2key = ();
    for (my $n=0;$n<@$inputs;$n+=3) {
        my ($switch,$key,$desc) = @$inputs[$n,$n+1,$n+2]; # array slice
        $switch2key{$switch}=$key;
        $concatswitches .= $switch;
    }

    for (;@$argv;) {
        my ($opt,$arg) = ($argv->[0] =~ /^-([\@agtf$concatswitches])(.*)$/o);
        last if ! defined $opt;
        if ($opt =~ /[gt$concatswitches]/ && $arg eq "") {
            if (@$argv < 2) {
                print "Argument required for option \"$opt\".\n";
                exit 1;
            }
            shift @$argv;
            $arg=$argv->[0];
        }

        $DEBUG=($arg ? $arg : 1)                     if $opt eq '@';
        $AUTOMATIC=1                                 if $opt eq 'a';
        $GENCODE=$arg                                if $opt eq 'g';
        $TAGNAME=$arg                                if $opt eq 't';
        $FORCEANNOT=1                                if $opt eq 'f';

        if ($switch2key{$opt}) {
            my $key = $switch2key{$opt};
            $config->StoreConfigValue($key,$arg);
        }

        shift @$argv;
    }
}




sub AddGeneFeatureUsingtRNAscanSE {

	#Description of the sub
	#1st : put the dna sequence into a temporary fastafile
	#2nd : run tRNAscanSE with the temporary fasta file  
	#3rd : parse the blast output
	#4th : annotate with the output
	
	#1st : put the dna sequence into a temporary fastafile
	
	my $pirmaster   = shift;			#get the masterfile object
	my $contigs = [];				#create a reference to a config file
	my $tag = shift;		
	
	$contigs = $pirmaster->get_contigs();		#get the masterfiles contigs
	
	my $contig=undef;
	foreach $contig (@$contigs)			#parse all the contig
	{
		my $name=$contig->get_name();		#get the name for the contig
		my $seq=$contig->get_sequence();	#get the sequence for each contig
		$seq =~ s/[^atcgATCG]//g;
		
		#2nd : run tRNAscanSE with the temporary fasta file
		
		my $fastatmp = "$TMPDIR/fasta.tmp";	#temporary fasta file
		my $outputtrnascansetmp = "$TMPDIR/tRNAscanSEoutput.tmp";	#tRNAscanSE output temporary file
		 
		open (FASTATMP, ">$fastatmp")
		or die "can't open fasta tmp file\n";	#put into a temporary fasta file	
		print FASTATMP ">$name\n$seq";		#put the sequence into the temporary file with fasta format
		close FASTATMP;				#close the temporary file	
	
		#2nd : run tRNAscanSE with the temporary fasta file
		if (! -r "$fastatmp")
		{
			die "
			can't open fasta tmp file\n";
			
		}
		my $tRNAscanSEcmd = "tRNAscan-SE -O -o $outputtrnascansetmp $fastatmp  > $TMPDIR/tRNAscanSE.output 2>&1";
		print "$tRNAscanSEcmd\n" if $DEBUG;
		my $restRNAscanSE = system ($tRNAscanSEcmd);	#-O for searching tRNA in organellar
                                                                #-C for unsing coves
                                                                #-o to write the result in a output file	
		my $parser = new PirObject::tRNAscanSEparser;					#Open the parser for tRNAscanSE
		$parser->loadObjectfromFile("$outputtrnascansetmp");				#Parse the file with the file and fill the object
		
		my @annotat = $parser->get_annotations;
		
		
		my $table = $parser->get_annotations; #this is a reference to an array
		
		
		foreach (@$table)	#Correspond to the tRNAscanSE annotation 
		{								
			my $start;
			my $end;
			my $arrow = ($_->get_begin > $_->get_end ? "<=="   : "==>");
			
			if ($arrow eq "==>") {			
				$start = ($_->get_begin > $_->get_end ? $_->get_end   : $_->get_begin);
				$end =   ($_->get_begin > $_->get_end ? $_->get_begin : $_->get_end);
			}
			else {			
				$start = ($_->get_begin > $_->get_end ? $_->get_begin : $_->get_end);
				$end =   ($_->get_begin > $_->get_end ? $_->get_end : $_->get_begin);
			}		
			
			my $type = $_->get_type;
			my $acodon = $_->get_anti_codon;
			my $score = $_->get_score;
			
			my %CodonTable = Bio::SeqUtils->valid_aa(2);			#get the amino acide code
			
			my $aaSymbol= uc(substr($type, 0, 1)).lc(substr($type, 1, 2));	#case treatment
			if ($aaSymbol = $CodonTable{$type})				#change the amino acid in one to 3 letter
			{}
			else {$aaSymbol=$type;}
			#if ($aaSymbol) {
			#		$aaSymbol='?';
			#}
			
										
			my $annot = new PirObject::AnnotPair (
              			type      => "G", 
				genename  => "trn$aaSymbol($acodon)",                     # Before : genename  => "tRNA-$type($acodon)",
                        	startpos  => $start,
                        	endpos    => $end,
                        	direction => $arrow,
                        	startline => ";     G-trn$aaSymbol($acodon) $arrow start ;; MFFEAT=$tag score=$score",
                        	endline   => ";     G-trn$aaSymbol($acodon) $arrow end ;; MFFEAT=$tag",
                    	);
        		&AddAnnotToPirMaster($pirmaster,$name,$annot);

			
			
		}
		
	}	
	
}



my $GeneNameToAnnot_Cache = undef;  # just a hash used for efficiency

sub AddAnnotToPirMaster {
    my $pirmaster  = shift;
    my $contigname = shift;
    my $annot      = shift;
    my $contig = $pirmaster->GetContigByName($contigname) || die "Can't get contig by name\n";
    my $annotations = $contig->get_annotations;
    
    if ($FIRSTTIME) {             # if it's the first time => fill $ANNOTSEEN
        foreach my $annotation (@$annotations){
	   	     if ($annotation->type eq "G") {
		$ANNOTSEEN->{$annotation->genename} = 'defined'; 
	    }
	
	}
	$FIRSTTIME = 0;
     }
     
    ANNOTATION : foreach my $annotation (@$annotations){
        my $annotname = $annotation->genename;
	my $annottype = $annotation->type || "C";
	my $annotstart = $annotation->startpos;
	my $annotend = $annotation->endpos;
	$annotname = "comment" if (!defined  $annotname);
	$annotstart = -1 if (!defined  $annotstart);
	$annotend = -1 if (!defined  $annotend);
	
	
	##--First case : if both are same comment on the same line 
	if (($annottype eq "C") && ($annot->type eq "C") && ($annot->startpos == $annotstart) && $annot->startline eq $annotation->startline) {
	    #Nothing is done in this case,
	    #print "On est bien dans ce cas\n";
	    #print "Annot : ",  $annot->startline, " Courante : ", $annotation->startline, " $annotstart ", $annot->startpos, "\n" ;
	    return;
	}
	
	##--Second case : No comment, both have same start end, and genename;
	if (($annottype ne "C") && ($annotname eq $annot->genename) && ($annotstart == $annot->startpos) && ($annotend == $annot->endpos)) {
            $ANNOT_STATS->{'Rediscovered'}->{$annot->genename} ||= {   'I' => 0, 'E' => 0, };
	    return;
	}
		
    }
    
    if ($FORCEANNOT) {       #   If no Force annot, you can add a new one 
        $ANNOT_STATS->{'Added'}->{$annot->genename} ||= {  'I' => 0, 'E' => 0, } if ($annot->genename ne "comment");
        push (@$annotations, $annot);
    }
    else {                       #   If force annot exists
    
        if ($annot->type eq "C") {
	    push (@$annotations, $annot);
	    return;
	}
    
	if (defined $ANNOTSEEN->{$annot->genename}) {     #  It mean,, this annotation has already been seen
            $ANNOT_STATS->{'Rediscovered'}->{$annot->genename} ||= {  'I' => 0, 'E' => 0, } if ($annot->genename ne "comment");
            #$ANNOTSEEN->{$annot->genename} = 'defined';
	}
	else {                                            #  It means, force annot but this annotations doesn't seems to have an other copy    
 	    $ANNOT_STATS->{'Added'}->{$annot->genename} ||= {  'I' => 0, 'E' => 0, } if ($annot->genename ne "comment");
            $ANNOTSEEN->{$annot->genename} = 'defined';	    
	    push (@$annotations, $annot);
	}
    }    #    end of if forceannot .......
    
}

sub GetRunTimeParameters {
    my $pirconfig = shift;
    my $inputs = PirObject::MfAnnotConfig->InputFiles();
    my $welcomed = 0;
    for (my $n=0;$n<@$inputs;$n+=3) {
        my ($switch,$key,$desc) = @$inputs[$n,$n+1,$n+2];
        my $path = $pirconfig->GetConfigValue($key);
        if (defined $path) { # Already set on command-line.
             next if -f $path && -r _;
             die "Error: file '$path' supplied with option -$switch doesn't exist or is not readable.\n";
        }
        if ($AUTOMATIC) {
            $pirconfig->StoreConfigValue($key,'none');  # means we do not do this processing.
            next;
        }
        # Alright then, let's ask for the value interactively.
        if (!$welcomed++) {
            print "\nHello, welcome to $BASENAME $VERSION !\n\n",
                  "You will be asked to supply some filenames; these can be either\n",
                  "absolute paths or relative paths, or the keyword 'none' if you\n",
                  "do not want to perform a particular analysis. Sometimes you will\n",
                  "also be provided with a choice of values based on previous answers;\n",
                  "you can select the value by entering its number in the list.\n\n";
        }
        my $history = $pirconfig->$key() || [];
        print "--------------------------------------------------------------------\n";
        print "\nData file needed: '$desc'\n",
              "   (hint: this option can be supplied with '-$switch' on the command-line)\n\n";
        if (@$history > 1) {
            print "Choices:\n";
            for (my $n=1;$n<@$history;$n++) {
                printf "  %2d- %s\n",$n,$history->[$n];
            }
            print "\n";
        }
        for (;;) {
            print "Enter filename: ";
            my $val = scalar(<STDIN>);
            die "Error: no input?\n" unless defined $val;  # eof ?!?
            $val =~ s/^\s*//;
            $val =~ s/\s*$//;
            next if $val eq "";
            if ($val =~ m#^(\d+)$#) {
                my $number = $1;
                if (@$history < 2) {
                     print "Error: there are no numbered choices available right now. Try again.\n";
                     next;
                }
                if ($number < 1 || $number >= @$history) {
                     print "Error: list number out of range. Try again.\n";
                     next;
                }
                $val = $history->[$number];
            }
            if ($val eq 'none') {
                $pirconfig->StoreConfigValue($key,$val);
                last;
            }
            if (! -f $val || ! -r _ ) {
                print "Error: file '$val' doesn't exist or is not readable. Check and try again.\n";
                next;
            }
            $pirconfig->StoreConfigValue($key,$val);
            last;
        }
    }

    # Other question start here.
    if (!$AUTOMATIC && (!$GENCODE || !$TAGNAME) && !$welcomed++) {
        print "\nHello, welcome to $BASENAME $VERSION !\n\n";
    }

    if ($AUTOMATIC) {
         $GENCODE=1 if ! $GENCODE;   # default gencode
         $TAGNAME=$USER . " " . scalar(localtime(time));          # default tagname
         return;
    }

    # Ask for genetic code
    if (! $GENCODE) {
        print "--------------------------------------------------------------------\n";
        print "\nGenetic code to use:\n",
              "   (hint: this option can be supplied with '-g' on the command-line)\n\n";

        # The following table should actually be constructed by reading NCBI's gc.prt...
        my %HARDCODED_GENCODES = (
             1 => "Standard",
             2 => "Vertebrate Mitochondrial",
             3 => "Yeast Mitochondrial",
             4 => "Mold Mitochondrial; Protozoan Mitochondrial; Coelenterate Mitochondrial; Mycoplasma; Spiroplasma",
             5 => "Invertebrate Mitochondrial",
             6 => "Ciliate Nuclear; Dasycladacean Nuclear; Hexamita Nuclear",
             9 => "Echinoderm Mitochondrial; Flatworm Mitochondrial",
            10 => "Euplotid Nuclear",
            11 => "Bacterial and Plant Plastid",
            12 => "Alternative Yeast Nuclear",
            13 => "Ascidian Mitochondrial",
            14 => "Alternative Flatworm Mitochondrial",
            15 => "Blepharisma Macronuclear",
            16 => "Chlorophycean Mitochondrial",
            21 => "Trematode Mitochondrial",
            22 => "Scenedesmus Obliquus Mitochondrial",
            23 => "Thraustochytrium Mitochondrial",
            99 => "OGMP: TAG-Leu (previously 16)",
            98 => "OGMP: TGA-Trp with GTG-initiation (previously 17)",
            97 => "OGMP: TGA-Trp (previously 18)",
            96 => "OGMP: Tetrahymena Mitochondrial (previously 19)",
            95 => "OGMP: Basic Mitochondrial (previously 20)",
            93 => "OGMP: TTA-stop (previously 22)",

        );

        foreach my $num (sort { $a <=> $b } keys %HARDCODED_GENCODES) {
            printf "  %2s- %s\n",$num,$HARDCODED_GENCODES{$num};
        }
        print "\n";

        for (;;) {
            print "Enter genetic code number: ";
            my $val = scalar(<STDIN>);
            die "Error: no input?\n" unless defined $val;  # eof ?!?
            $val =~ s/^\s*//;
            $val =~ s/\s*$//;
            next if $val eq "";
            if ($val !~ m#^\d+$# || !defined($HARDCODED_GENCODES{$val})) {
                print "Please enter a number from the list above.\n";
                next;
            }
            $GENCODE=$val;
            last;
        }
    }

    # Ask for tag name
    if (! $TAGNAME) {
        print "--------------------------------------------------------------------\n";
        print "\nEnter a short identifier or reminder, such as 'ABCD' or 'myrun1';\n",
              "this identifier will be used on all newly inserted annotations in your masterfile.\n",
              "   (hint: this option can be supplied with '-t' on the command-line)\n\n";
        print "Enter identifier or reminder: ";
        $TAGNAME=scalar(<STDIN>) || "";
        $TAGNAME =~ s/^\s*//;
        $TAGNAME =~ s/\s*$//;
        if ($TAGNAME eq "") {
            $TAGNAME=$USER . " " . scalar(localtime(time));
            print "Since you did not supply anything, we'll use '$TAGNAME'.\n";
        }
    }
    # Done with questions.
}


sub LogInfo {
    my $pirmaster = shift;
    my $header = $pirmaster->header() || [];

    my @report = ();
    my $added  = $ANNOT_STATS->{'Added'};
    my $redisc = $ANNOT_STATS->{'Rediscovered'};

    my @added  = sort keys %$added;
    my @redisc = sort keys %$redisc;

    push(@report,
        ";;    - Gene Totals: " . scalar(@added) . " added; " . scalar(@redisc) . " rediscovered.",
    );

    push(@report,
        ";;    - List of genes added:",
    ) if @added;

    #foreach my $genename (@added) {
    #    my ($e,$i) = ($added->{$genename}->{'E'},$added->{$genename}->{'I'});
    #    push(@report,
    #    ";;        $genename" . ($e > 1 ? " ($e exons)" : ""),
    #    );
    #}

    my $COLS=3;
    my $cnt=0;
    my $rep = "";
    print "Added : ", scalar(@added), "\n" if $DEBUG;
    print LOGFILE "Added : ", scalar(@added), "\n" if $ISLOGFILE;
    foreach my $genename (@added) {
        my ($e,$i) = ($added->{$genename}->{'E'},$added->{$genename}->{'I'});
        $rep = ";;     " if !$cnt;
        $rep .= sprintf(" %-20s", ("$genename" . ($e > 1 ? " ($e exons)" : "")));
        $cnt++;
        if ($cnt >= $COLS) {
            push(@report, $rep);
            $cnt=0;
        }
    }
    push(@report, $rep) if $cnt;

    push(@report,
        ";;    - List of genes rediscovered:",
    ) if @redisc;

    $cnt=0;
    $rep = "";
    print "Rediscovered : ", scalar(@redisc), "\n" if $DEBUG;
    print LOGFILE "Rediscovered : ", scalar(@redisc), "\n" if $ISLOGFILE;
    foreach my $genename (@redisc) {
        my ($e,$i) = ($redisc->{$genename}->{'E'},$redisc->{$genename}->{'I'});
        $rep = ";;     " if !$cnt;
        $rep .= sprintf(" %-20s", ("$genename" . ($e > 1 ? " ($e exons)" : "")));
        $cnt++;
        if ($cnt >= $COLS) {
            push(@report, $rep);
            $cnt=0;
        }
    }
    push(@report, $rep) if $cnt;

    unshift(@$header,
        ";; Masterfile modified automatically by $BASENAME version $VERSION",
        ";;    - New annotations labeled with: MFFEAT=$TAGNAME",
        @report,
        ";;",
    );

    $pirmaster->set_header($header);
}

END {              # With exit, programm will go here
                   # Cleanup temp directory when program exits.

    return unless defined($TMPDIR) && $TMPDIR =~ m#^/tmp/#;
    #if (defined($DEBUG) && $DEBUG > 0) {
    #    print STDERR "Debug mode warning: temporary work directory '$TMPDIR' not cleaned up.\n";
    #    return;
    #}
    
    print "temporary work directory $TMPDIR cleaned up ...\n" if $DEBUG; 
    system("/bin/rm","-rf",$TMPDIR) if -d $TMPDIR;
    
}

# End Of File. Or is it? What's beyond? Maybe the lost characters of all the sentences that were trunca
