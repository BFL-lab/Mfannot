#!/usr/bin/perl -w -- -*-Perl-*-

##############################################################################
#
#                                 mfannot.pl
#
# DESCRIPTION:
# Attempts to do a quick first pass at annotating a masterfile
# with meaningfull start/stop lines by calling blast on collections
# of known genes. Manual intervention is still required to check/adjust
# the new annotations.
#
# Known issues: - Annotations for START/STOP introns are interleaved (they
#                 are at the correct position, though).
#
##############################################################################

##############################################################################
#                                                                            #
#                       CONFIDENTIAL & PROPRIETARY                           #
#       Nothing herein is to be disclosed in any way without the prior       #
#           express written permission of Franz Lang                         #
#                                                                            #
#          Copyright 2004 Franz Lang lab, All rights reserved.               #
#                                                                            #
##############################################################################
#
#    $Id: mfannot,v 1.91 2008/03/20 20:20:20 riouxp Exp $
#
#    $Log: mfannot,v $
#    Revision 1.91  2008/03/20 20:20:20  riouxp
#    Fixed tiny bug in support of multiple GeneNames args.
#
#    Revision 1.90  2008/03/20 20:10:32  riouxp
#    Added support for multiple genenames supplied on the GeneName
#    directive of the external programs configuration file. The
#    directive can now also be rewritten as "GeneNames" (with an S).
#
#    Revision 1.89  2008/03/19 21:49:58  riouxp
#    Added ability to run external programs in multiple distinct blocks
#    of commands, where the first one that returns a useful result is
#    taken. This required extending the format of the external programs
#    config file, and adjusting its parser and execution methods.
#
#    Revision 1.88  2008/03/18 21:40:47  nbeck
#    Add annotation of Intron using external programs.
#    Fixed bug for annotation of ORF.
#
#    Revision 1.87  2008/03/06 20:59:09  nbeck
#    Adding an option to choose which external programs to run.
#
#    Revision 1.86  2008/03/04 19:47:26  nbeck
#    Fixed bug : set a default value for evalue in subroutine ChoiceORF.
#
#    Revision 1.85  2008/03/03 16:56:26  nbeck
#    Fixed protein name for exonerate.
#
#    Revision 1.84  2008/02/27 21:26:19  nbeck
#    Improved mechanism for executing external programs (API).
#
#    Revision 1.83  2008/02/26 20:12:00  riouxp
#    Made endpos optional for AnnotPairs returned by external programs.
#
#    Revision 1.82  2008/02/22 21:26:47  riouxp
#    Added ability to trust the fields of the AnnotPairs obtained
#    from an AnnotPairCollection generated by external programs.
#    Default is still to recreate fields as needed.
#
#    Revision 1.81  2007/08/10 19:37:20  nbeck
#    Added support for calling external anlasys programs
#
#    Revision 1.80  2007/07/26 19:28:53  nbeck
#    fixed bug for Exonerate
#
#    Revision 1.79  2007/07/25 14:10:57  nbeck
#    Add safe of Exonerate Output in temporary file
#
#    Revision 1.78  2007/07/24 19:52:13  riouxp
#    Fixed attributions.
#
#    Revision 1.77  2007/07/24 19:07:38  nbeck
#    fixed bug for annotation of intronical ORF
#
#    Revision 1.76  2007/07/24 17:01:06  nbeck
#    Support annotation of intronical ORF
#
#    Revision 1.75  2007/07/10 13:38:11  nbeck
#    Add comment for annotation of transpliced genes.
#
#    Revision 1.74  2007/06/29 19:36:07  nbeck
#    Fixed bug for annotation of intronic ORF in circular genome
#
#    Revision 1.73  2007/06/19 19:10:14  nbeck
#    Supported intronic ORF
#
#    Revision 1.72  2007/06/18 21:53:41  riouxp
#    Removed all references to the old %ANNOTSEEN hash; adjusted naming
#    of orfs to not include the stop codon.
#
#    Revision 1.70  2007/06/18 18:52:19  riouxp
#    Commented out all the old %ANNOTSEEN-based renumbering mechanism
#    which was interfering with the new one.
#
#    Revision 1.69  2007/06/18 17:33:00  nbeck
#    New subroutine for annotation of ORF
#
#    Revision 1.68  2007/06/15 21:31:14  riouxp
#    Fixed gene renumbering routine.
#
#    Revision 1.67  2007/06/07 18:00:17  riouxp
#    Added a subroutine &WhatOverlapsThis() to be used later by
#    the ORF decision code.
#
#    Revision 1.66  2007/06/01 20:53:56  riouxp
#    Added post processing step to renumber duplicate genes and genes
#    in fragments with unique extension numbers (_1, _2 etc); priority
#    is given to numbering already supplied in the input masterfile.
#
#    Revision 1.65  2007/05/30 18:53:56  nbeck
#    Fixed bugs for Exonerate, and use startBlast to define start of protein without introns.
#
#    Revision 1.64  2007/05/02 18:24:09  nbeck
#    *** empty log message ***
#
#    Revision 1.63  2007/05/01 21:04:55  nbeck
#    Support for external program 'exonerate' for exon annotation (replaces
#    Genewise); tRNAscanSE is now disabled
#
#    Revision 1.62  2007/03/09 21:50:20  riouxp
#    Masterfile now copied into tmp directory and stripped of
#    all carriage returns before running 'flip' (otherwise,
#    flip's report is all wrong).
#
#    Revision 1.61  2007/03/05 20:28:29  nbeck
#    Support anticodon identification with '!'s; fixed bug with start positions
#    of genes.
#
#    Revision 1.60  2007/02/13 22:29:16  nbeck
#    Fixed tRNA location calculations.
#
#    Revision 1.59  2007/02/13 22:18:49  riouxp
#    Improved handling of stderr and stdout on system() calls;
#    makes a copy of the tRNA model file for RNAweasel.
#
#    Revision 1.58  2007/02/13 21:41:10  nbeck
#    Use RNAweasel for tRNAs; adjusted codon start calculations.
#
#    Revision 1.57  2005/11/09 18:56:10  dto
#    Fixed path to Wise
#
#    Revision 1.56  2005/08/11 17:17:10  thomash
#    a bug fixed about overlapping
#
#    Revision 1.55  2005/08/11 15:58:16  thomash
#    Overlapping cutoff interval [0-1] => [0-100]
#
#    Revision 1.54  2005/08/10 21:03:05  dto
#    Added error checking for production of files
#
#    Revision 1.53  2005/08/10 18:39:05  dto
#    Fixed comments - removed card, put in map
#
#    Revision 1.52  2005/08/10 18:03:43  thomash
#    an other way of saying the produced map is..
#    Remove comments on generating map
#
#    Revision 1.51  2005/08/10 16:21:17  thomash
#    Delete the map option.
#    Map is generating with withmap option
#
#    Revision 1.50  2005/08/10 15:14:29  thomash
#    Map creating bug fixed
#
#    Revision 1.49  2005/08/09 21:47:34  thomash
#    A map generating option is avaliable
#
#    Revision 1.48  2005/08/09 20:37:56  dto
#    Fixed map creation
#
#    Revision 1.47  2005/08/09 19:49:56  thomash
#    check the genetic code
#
#    Revision 1.44  2005/08/09 18:15:51  thomash
#    a short mistake in masterfile spelling fixed
#
#    Revision 1.43  2005/08/09 18:13:52  thomash
#    name of the masterfile added in run
#
#    Revision 1.42  2005/08/05 21:41:09  thomash
#    add introns prediction
#
#    Revision 1.41  2005/07/28 21:12:45  thomash
#    Give name to the libraries in displaying
#    Bug fixed in reg exp, in blast parse function
#
#    Revision 1.40  2005/07/26 19:32:34  thomash
#    # If syntax changed
#    # Unused parts removed
#    # Formatdb put as a global variable in command line
#    # Print Steps on screen during application runnning
#
#    Revision 1.39  2005/07/26 12:49:39  dto
#    Added more tags for Thomas to fix
#    Fix BLASTOUTPUT line
#
#    Revision 1.38  2005/07/25 23:16:15  dto
#    Added more tags for Thomas
#
#    Revision 1.37  2005/07/25 21:18:47  dto
#    Removed non-required loop tags
#
#    Revision 1.36  2005/07/25 20:59:54  dto
#    Added tags for Thomas to fix
#    Fixed style
#    Fixed system commands - used Perl commands if possible
#
#    Revision 1.35  2005/07/25 20:40:43  dto
#    Fixed style and removed code that was not needed
#    Added comments for Thomas
#
#    Revision 1.34  2005/07/22 21:20:10  dto
#    Fixed up path locations of external cli programmes
#
#    Revision 1.33  2005/07/22 20:29:16  dto
#    Removed "..." at end of output file name (allows selecting of file by double clicking mouse)
#
#    Revision 1.32  2005/07/22 20:27:43  dto
#    Updated flip - now runs in the temporary directory
#
#    Revision 1.31  2005/07/22 18:21:39  dto
#    Removed commented code that was not required
#
#    Revision 1.30  2005/07/22 15:22:55  thomash
#    problem fixed with Line appearing  (*** ANnotation...***) without debug mode
#
#    Revision 1.29  2005/07/21 21:07:58  thomash
#    bug fixed about loading many libraries
#     - memory problems fixed
#     - some options changed
#
#    Revision 1.28  2005/07/18 20:57:43  thomash
#    The new mfannot version that allows to run
#    on many pepfiles, and many libraries.
#    Make sur you have the collection (directories)
#    dataorfcollection and datagenecollection,
#
#    Revision 1.27  2005/07/14 14:15:13  thomash
#    Variables in the programme update to fit with the new version
#    - variable matrix, added for genewise
#    - parameters for finding closest organism, removed
#    - other parameters such as exon and intron size updated
#
#    An function to create a genetic table from the genetic id code
#    created, to work with genewise
#
#    Revision 1.25  2005/06/29 19:24:37  thomash
#    little bug fixed
#
#    Revision 1.24  2005/06/29 18:55:39  thomash
#    bugs with trna scan solved
#    (Contig name)
#
#    Revision 1.21  2005/06/15 15:59:54  thomash
#    ORF size corrected
#
#    Revision 1.20  2005/06/13 21:04:54  thomash
#    - orf size changed : nucleotides => amino acids
#    - grouping of exons
#    - add a number for each gene (if the number of copies is more than
#    - 1)),
#      to the normal genes and trna genes
#    - change exons : comments => real annotations
#    - Exon problems corrected
#
#    Revision 1.19  2005/05/20 21:56:28  thomash
#    Contains, orf modifications.
#    Now, overlapping is calculated on the both strands
#
#    Revision 1.17  2005/05/11 21:22:43  thomash
#    The multiples annotations for a same frame function has been improved
#    Before, all the significant annotation were taken for the same ORF.
#    It could have a sense if a protein contains two functionnal domains
#    derived from 2 different protein.
#    The most of the time, an ORF having more than one annotation,
#    comes when two similar proteins correspond to the annotation
#    In this case we just want one annotation.
#    This has been done (but not tested one real fusion protein)
#    And work on proteins present in masterfiles used
#
#    Revision 1.14  2005/05/09 15:00:30  thomash
#    Problems fixed (Exons problems)
#
#    Revision 1.13  2005/05/05 19:41:33  thomash
#    mfannot modified in order to have more than one annotation
#    per ORF;
#    if option -m is in line command it will active the multi
#    annotation per ORF option
#
#    Revision 1.12  2005/05/05 16:00:06  thomash
#    Disallow, 2 annotations for the same gene, by default
#    Allows 2 annotations if option -f.
#    Give, too non coresponding ORF (it means, with no
#    corresponding gene after running blast) with a
#    specific cutoff size
#
#    Revision 1.10  2005/04/28 19:10:55  thomash
#    Comment added,
#    Options problemes fixed by allowing
#    setting parameters
#    This mfannot version runs with the new
#    MAsterfile.pir object that allows the user
#    to load annotation from a Masterfile
#    having the same name
#
#    Revision 1.8  2005/04/13 20:06:07  thomash
#    New Version of Mfannot
#    Input : A masterfile (-m) and a peplibrary (-p)
#    First step : Give the pepfile from the peplibrary corresponding to
#    the closest Organism.
#    Second step : Doing annotation of the Masterfile with the pepfile
#    Annotation is made with translation (in the 6 frames) of the
#    Masterfile
#    and blasting the results with the pepfile.
#
#    Revision 1.6  2005/03/16 14:52:49  dto
#    Added correct location of perl
#
#    Revision 1.5  2005/03/15 20:36:22  thomash
#    Add tRNAscanSE for prediction
#
#    Revision 1.4  2005/03/04 20:47:29  dto
#    New version provided by Pierre
#    Modified by Hoellinger T. 2005/03/14
#
#

##########################
# Initialization section #
##########################

require 5.00;
require "/share/supported/apps/ogmp/lib/perl/ogmp/gc.pl";
use strict;
use vars qw( $VERSION $RCS_VERSION );
use IO::File;
use IO::Dir;
use Cwd;
use File::Basename;
use File::Path;
use PirObject;                                        #  Pir module treatment 
use Bio::SearchIO;                                    #  Bioperl (used for parsing blast outout)
use Bio::SeqUtils;                                    #  Some biological tools
use Bio::Tools::CodonTable;                           #  To create a codon table, to be used with genewise 
use List::Util qw(max);
use List::Util qw(min);
use File::Copy;
use Term::ANSIColor;
use PirObject qw( MfAnnotExternalProgs AnnotPairCollection );

BEGIN {
#---General Objects
PirObject->LoadDataModel("Masterfile");               #  Masterfile object
PirObject->LoadDataModel("MfAnnotConfig");            #  Configuration object
PirObject->LoadDataModel("tRNAscanSEparser");         #  Parser for tRNAscanSE output
PirObject->LoadDataModel("RNAweaselparser");          #  Parser for RNAweasel output
PirObject->LoadDataModel("ExonerateOutput");          #  Parser for Exonerate output


#---Objects for annotation 
PirObject->LoadDataModel("FlipBlastProt");            #  Objects for storing ORFs predicted by Flip and kept with blast
PirObject->LoadDataModel("Orf");                      #  ORF (belong to FlipBlastProt)
PirObject->LoadDataModel("Hsp_query_sbjct");          #  High Scoring Pair (belong to Orf)
PirObject->LoadDataModel("HypProt");                  #  Hypothetical protein : We believe its a protein after flip, blast an
                                                      #  Organization of the results     
PirObject->LoadDataModel("Exon");                     #  Exons : belongs to Hypothetical proteins
PirObject->LoadDataModel("Intron");                   #  Intron : belongs to Hypothetical proteins
PirObject->LoadDataModel("Option");                   #  A module for options gestion
PirObject->LoadDataModel("EmptyOrf");                 #  Object containing Orfs having no corresponding genes
}

# Default umask
umask 027;

# Program's name and version number.
$RCS_VERSION='$Id: mfannot,v 1.91 2008/03/20 20:20:20 riouxp Exp $';
($VERSION) = ($RCS_VERSION =~ m#,v ([\w\.]+)#);
my ($BASENAME) = ($0 =~ /([^\/]+)$/);

# Get login name.
my $USER=getpwuid($<) or getlogin or die "Can't find USER from environment!\n";

##################################
# Global variables and constants #
##################################

# Command-line args (first, original program)

my $TAGNAME          = undef;                   #  Tag : is present in masterfile within the annotations made with Mfannot
my $FORCEANNOT       = 0;
my $ANNOT_STATS      = {
                         'Added'        => {},  #  It means, never see it before
                         'Rediscovered' => {},  #  Means exist at the same place (not added into the file)
                       };
my $EMPTYORFS;                                  #  An array containing, EmptyOrf object. It means ORFs having
                                                #  no corresponding genes
my %PENAMEDISPLAY;                              #  An hash array, containing the name to display, associate with peplibraries and pepfiles


# Command line Program's paths    
my $BLASTPATH        = "/share/supported/apps/ncbi/bin/blastall";
my $FORMATDBPATH     = "/share/supported/apps/ncbi/bin/formatdb";
my $FLIPPATH         = "/share/supported/apps/ogmp/bin/flip";
my $GENEWISEPATH     = "/share/supported/apps/wise_2.2.0/src/bin/genewise";
my $TRNASCANPATH     = "/share/supported/apps/tRNAscan-SE/bin/tRNAscan-SE";
my $RNAWEASELPATH    = "/share/supported/bin/RNAweasel_cl";
my $MF2XMLPATH       = "/share/supported/apps/mf2xml/bin/mf2xml";
my $CGVIEWPATH       = "/share/supported/apps/cgview/bin/cgview";
my $EXONERATEPATH    = "/share/supported/bin/exonerate";

# General options
my $DEBUG;                                      #  Debug mode. If true, display message on the screen
my $GENCODE          = undef;                   #  Genetique code
my $TMPDIR           = "/tmp/mfannot.$$";       #  Temporary directory
my $LOGFILE;                                    #  log file : store all the information about run
my $SIMILARITYSEARCH;                           #  Usefull for running similaritie gene process for annot.
my $ISLOGFILE        = 0;                       #  Just to know if the $LOGFILE is not empty (0 or 1)
my $MASTERFILE       = undef;                   #  Path for Masterfile
my $PEPFILE;                                    #  Path for the peptide file used
my $TAKEINPUTFILE;                              
my $FLIPBLASTPROTS;                             #  Array containing the Proteins predicted by Blast and Flip
my @PROT_FOR_EXONERATE;				#  Array with homolog protein for Exonerate
my $HYPPROTS;                                   #  Array containing the Proteins predicted by Blast and Flip and reprocessed after
my $OUTPUTFILE;                                 #  Path for the new
my $USETRNASCANSE;                              #  T or F : use of tRNAscanSE in the annotation 
my $MULTIORFS;                                  #  0 or 1 allows many gene annotations for 1 ORF 
my $NEWRCFILE;                                  #  0 or 1 : print if a new rcfile is generated
my $NORCFILE;                                   #  0 or 1, if a rcfile has been used for loading data
my $RCFILE;                                     #  The rcfile used for loading options
my $ORFPROCESS;                                 #  Allows ORF appearing in the masterfile as annotations
my $LOADSTRICT;                                 #  Load strict Masterfile
my $ADDCOMMENTS;                                #  Add comments into masterfile (0 or 1) as mfeat=.....
my $CHECKORFS;                                  #  Say if yes or not have to check for orf, if no all orfs appears in mf                                   
my $PEPLIBRARIES;                               #  The libraries, in input, by default datagenescollection and dataorfcollection
my $INPUTPEPFILES;                              #  the input files
my @PEPFILES;                                   #  the pepfiles, used in the programm. They come from $PEPLIBRARIES and $INPUTPEPFILES
my $WITHMAP;                                    #  the allowed extension for the map. Png or svg
my $SIZE;					#  The sensitivite of warning for the long protein, it's a pourcentage 
my $STARTBEFORE;				#  The distance who is use in order to define the really start position before blast
my $STARTAFTER;					#  The distance who is use in order to define the really start position after blast
my $EXTCONFIGFILE;				#  The path for configuration file, it's use for annotation of rnpB, rnl and rns;
my $EXTSELECTPROG;				#  List of name for external programs.
# Specific for the annotation (parameters for flip, blastall and organization)
my $BLASTOUTPUT       = "";                     #  The path for blast file results
my $BLASTEVALUECUTOFF;                          #  Cutoff value for the blast
my $MINLENGTHORF;                               #  This is the minimum length for creating an ORF with flip
my $MAXLENGTHFORGROUPINGORF;                    #  Minimum size of a gap between 2 ORf. If 2 same ORF
my $MINLENEMPTYORF;                             #  Minimum length for ORF empty orfs (non corresponding orfs)
my $OVERLAPPINGCUTOFF;                          #  Overlapping cutoff for ORFs 
my $TRNACUTOFF;                                 #  The cutoff for the tRNAs annotation
my $MININTRONSIZE;                              #  opposite of MAXLENGTHFORGROUPINGORF. Minimum size for intron
my $MINEXONSIZE;                                #  Minimum exon size for intron. In genewise.
my $MATRIX;                                     #  The matrix used in genewise alignement
my %CODE_GEN;			                #  Hashtable with genetic code
my $NBCONTIGS=0;                                #  The number of contigs

my $RNAweasel_training  = "/share/supported/data/RNAmodels/tRNA.epn"; # training set for RNAweasel
my $RNAweasel_parameter = "-1,19 -add 1 17 18 -add 11 12 14 -add 2 3 5 7 -logzero -5 -cutoff 2.9 8 20";	# parameter for RNAweasel
my $Exonerate_parameter = "--model protein2genome --showcigar T --useaatla F --showquerygff T --showtargetgff T --minintron 142 --nosplicesignal T"; 

#############################
# Environment Verifications #
#############################
# Added by David To 11th February 2005
$ENV{"BLASTMAT"} = "/share/supported/apps/ncbi/data";

die "Please make sure the BLASTMAT environment variable is set\n" .
    "to point to a directory where the blast matrices are stored.\n"
    unless defined($ENV{"BLASTMAT"}) and (-d $ENV{"BLASTMAT"}) and (-f ($ENV{"BLASTMAT"} . "/PAM30"));

# Check if the programmes exist!
TestFile($BLASTPATH);
TestFile($FORMATDBPATH);
TestFile($FLIPPATH);
TestFile($GENEWISEPATH);
TestFile($TRNASCANPATH);
TestFile($RNAWEASELPATH);
TestFile($EXONERATEPATH);

################
# Trap Signals #
################

sub SigCleanup 
{    # private
     die "\nExiting: received signal \"" . $_[0] . "\".\n";
     # Note that some cleanup will be performed in the END block at this point.
}
$SIG{'INT'}  = \&SigCleanup;
$SIG{'TERM'} = \&SigCleanup;
$SIG{'HUP'}  = \&SigCleanup;
$SIG{'QUIT'} = \&SigCleanup;
$SIG{'PIPE'} = \&SigCleanup;
$SIG{'ALRM'} = \&SigCleanup;

###############################
#   M A I N   P R O G R A M   #
###############################

&GetOptions ;     # get the different options and put them into global variables

open (LOGFILE, ">$LOGFILE") if $ISLOGFILE;
#----------HEADER PRINTED OUT----------------------------------------------------------
my $header = "\n".
             "######################################################################\n".
             "MFANNOT, ORGANELLAR GENOME ANNOTATION PROGRAMME                       \n".
             "VERSION $VERSION                                                      \n".
             "Programmed by P. Rioux, T. Hoellinger, D. To and N. Beck              \n".
             "######################################################################\n\n";

print $header;
print LOGFILE $header if $ISLOGFILE;
my $add_text_in_header = "";

##---------------OPTIONS OF THE PROGRAM------------------------------------------------
my $options ="----------------------------------\n".
             "        General Options           \n".
             "----------------------------------\n";

if ($NORCFILE) 
{
    $options .= "No rcfile used for options\n";
}
else 
{
    $options .= "$RCFILE used for loading options\n";
}
$options .= "Masterfile used : $MASTERFILE\n";
$options .= "new Masterfile created : $OUTPUTFILE\n";
$options .= "the map $OUTPUTFILE.$WITHMAP will be generated\n" if ($WITHMAP ne "");
$options .= "Genetic code : $GENCODE\n";
$options .= "Tag for annotation : $TAGNAME\n" if $ADDCOMMENTS;
$options .= "Logfile : $LOGFILE\n" if $ISLOGFILE;
$options .= "New rcfile generated in .mfannotrc\n" if $NEWRCFILE;
$options .= "Add comments in Masterfile\n" if $ADDCOMMENTS;
$options .= "Usage of RNAweasel\n";
$options .= "Search of start $STARTBEFORE aa before the start of blast match\n";
$options .= "Search of start $STARTAFTER aa after the start of blast match\n";
$options .= "Warning if the protein make +/- $SIZE pourcent of homologous protein\n";
$options .= "The Path of configfile is : $EXTCONFIGFILE";

if ($SIMILARITYSEARCH) 
{
    foreach my $pep (@$PEPLIBRARIES) 
    {
        $options .= "Look in the peptide library $pep\n";
    }
    foreach my $pep (@$INPUTPEPFILES) 
    {
        $options .= "Peptide file $pep\n";
    }
}
else 
{
    $options .=  "Any search in gene similarity for annotation\n";
}


if ($USETRNASCANSE == 0) 
{
    $options .= "No usage of tRNAscanSE\n";
}
else 
{
    $options .= "Usage of tRNAscanSE\n";
}

print LOGFILE $options if $ISLOGFILE;           #Print options in the logfile
print $options if $DEBUG;                       #Print the options on the screen 


##---------------CREATE THE TMPDIR---------------------------------------  
mkdir($TMPDIR,0700) or die "Error: can't create work directory '$TMPDIR': $!\n";


#-----------------PEPFILES CREATION--------------------------------------
          #  Fill the variable @PEPFILES
          #  A list of pepfiles, and run mfannot for each of them

#  1) first, create the list of the pepfiles with the libraries
my $count = 1;  

foreach my $library (@$PEPLIBRARIES) 
{
    next if (not -d $library);

    my $namefile = "$TMPDIR/library_" . $count;
    $count++;
    my $tmppepfile = &CreatePepfileWithLibrary ($library, $namefile);       # call the function 
    push (@PEPFILES ,$namefile);
    $PENAMEDISPLAY{"$namefile"} = $library;                                 # associate, the name of the library for each peplibraries

}    
#  2) second, push the input pepfiles in the pepfile array
foreach my $file (@$INPUTPEPFILES) 
{
       push (@PEPFILES, $file);
       $PENAMEDISPLAY{"$file"} = $file;                                    # associate the same name, 
}

#-----------ANNOTATION -------------------------------------------

# - print option of the annotation
print "----------------------------------\n",
      "         Gene Annotation          \n",
      "----------------------------------\n";
print LOGFILE "----------------------------------\n",
              "         Gene Annotation          \n",
              "----------------------------------\n" if $ISLOGFILE;

if ($SIMILARITYSEARCH) 
{
    $options  = "Options : \n";                  # Options & parameters used for the blast
    $options .= "Minimum size ORF, for flip running $MINLENGTHORF\n";
    $options .= "Blast e-value cutoff : $BLASTEVALUECUTOFF\n";
    $options .= "Minimum exon size : $MINEXONSIZE\n";
    $options .= "Maximum intron size : $MAXLENGTHFORGROUPINGORF\n";
    $options .= "Minimum intron size : $MININTRONSIZE\n";
    $options .= "Force annotation\n" if ($FORCEANNOT);
    $options .= "Matrix : $MATRIX\n";
    $options .= "Minimum length for non corresponding ORFs : $MINLENEMPTYORF\n";
    $options .= "Overlapping cutoff for non corresponding ORFs: $OVERLAPPINGCUTOFF\n";
    $options .= "trna cutoff : $TRNACUTOFF\n" if ($USETRNASCANSE);

    print $options if $DEBUG;
    print LOGFILE $options if $ISLOGFILE;
}

# - create a masterfile object
#      - load the annotations
#      - load the sequence of each contig 

print "Parsing masterfile $MASTERFILE...\n";
my $pirmaster     = PirObject::Masterfile->ObjectFromMasterfile($MASTERFILE, $LOADSTRICT);
my $contigs       = $pirmaster->get_contigs();
my $numbercontigs = 0;                         # Number of contigs in the masterfile
my $numberannot   = 0;                         # Number of annotations detected in the program

$numbercontigs += scalar (@$contigs);
foreach my $contig ( @$contigs) 
{
    my $annotations = $contig-> get_annotations();
    $numberannot += scalar (@$annotations);
}

print "Number of contigs in Masterfile : $numbercontigs\n",
      "Number of annotations (or comments) detected : $numberannot\n" if $DEBUG;

print LOGFILE "Number of contigs in Masterfile : $numbercontigs\n",
              "Number of annotations (or comments) detected : $numberannot\n" if $ISLOGFILE;

#-------------------START THE PROCESS----------------------#

if ($SIMILARITYSEARCH) 
{
    my $step;
    $count = 1;

    foreach my $file (@PEPFILES) 
    { # Each pepfile
      # The input pepfiles
      # + the pepfiles created from the libraries

        # Create a reference for the different general arrays
        $FLIPBLASTPROTS = [];                        #  Array containing the Proteins predicted by Blast and Flip
        $HYPPROTS = [];                              #  Array for the hypothetical proteins  
        $EMPTYORFS = [];                             #  Array containing the emptys ORF
        $step = 1; 


        ## Print the name of each pepfile###
        ##  if it's a library, name begin with libarary....
        $PEPFILE = $file;
        my $displayfile = $PENAMEDISPLAY{"$file"} || "$file";    # Get the associate name, so if it's a library, get the name of the library         
        my @tabname = split ("/", $displayfile);
        my $tringprint = "\n****** Annotation from " . $tabname [$#tabname] . " ******";
        print $tringprint, "\n";

        ## check the existenz ##
        if ((not -r  $PEPFILE) and $SIMILARITYSEARCH) 
	{
            print "Unable to read $PEPFILE\n";
            next;
        }                          

        # --------   HEART --------#

        # Run the programm step by, to know the right step  

        # Flip running, generate ORFS
        print "$step) Run Flip...\n";
        $step += 1; 
        &RunFlip ($count);

        # Blast the flip result with the blast
        print "$step) Run Blast...\n";
        $step += 1;  
        &BlastFlipVSGene ($count);

        # Parse the blast result, create a flipblastprot object
        print "$step) Parse Information From Blast Results...\n";
        $step += 1;
        &ParseInformationFromBlastResult ($pirmaster, $TAGNAME);

     	#selection of protein
     	print "$step) Select hypotetical protein for identification of protein with Exon/Intron (In order to run Exonerate)...\n";
        $step += 1; 
        &Select_protein;

        # Create Hypothetical proteins  
        print "$step) Identify similar ORFs...\n";
        $step += 1; 
        &FillHYPPROTSArrayWithFLIPBLASTPROTSArray;

        # Make the alignement and give the exons
        print "$step) Internal structure prediction...\n"; 
        $step += 1; 
        &FindExonsInHypProtArray ($pirmaster, $count);

	# Organise the hypothetical proteins (find the real start)
        print "$step) Process ORFs => genes...\n"; 
        $step += 1; 
        &OrganiseHYPPROTSArray ($pirmaster);     #  Find the start codon.

        # Annotate -> change hypothetical proteins into an object annotation
        print "$step) Annotation in the masterfile...\n";
        $step += 1; 
        &AnnotateMfFromHYPPROTSArray ($pirmaster);
	
	# Annotate tRNA -> Use RNAweasel
	#print "$step) Annotate of tRNA with RNAweasel...\n";
	#$step += 1; 
	#&Old_UseRNAweasel ($pirmaster);
	
	# Annotate rRNA -> Use RNAweasel for 5SrRNA and rnpB, Use HMMweasel for rns and rnl
	print "$step) Annotation with external programs...\n"; 
        $step += 1; 
        &Annotate_Using_external_programs($pirmaster);
	
	# Process empty orfs, -> annotate empty ORFs in the masterfile (whose who correspond to something good)
        if ($ORFPROCESS) 
	{
            print "$step) Process Empty ORFs...\n"; 
            $step += 1; 
            &AnnotateEmptyOrfs ($pirmaster);
        }
	
	# Process intronical ORF -> annotate intronicale ORF not detected by Blast
	print "$step) Process intronic ORFs...\n"; 
        $step += 1; 
        &AnnotateIntronicOrfs ($pirmaster);
  
        $count++;  # next pepfile

    }  #  End of each pepfile

}


#-------------PROGRAMME ENDING---------------


print "----------------------------------\n",
      "       End of the Programme       \n",
      "----------------------------------\n";  

#  unreferencing 
undef $FLIPBLASTPROTS;
undef $HYPPROTS;
undef $EMPTYORFS;

# Renumber genes with _1, _2 etc correctly this time.
&RenumberFeatures($pirmaster);

# Add informations in the masterfile     
&LogInfo ($pirmaster);

# Dump it
print "Dumping new masterfile in $OUTPUTFILE\n";
$pirmaster->ObjectToMasterfile("$OUTPUTFILE");

if (($WITHMAP ne "") and ($numbercontigs==1)) 
{
    &CreateMap;
    print "Genetic map: $OUTPUTFILE.$WITHMAP\n";
}
elsif (($WITHMAP ne "") and ($numbercontigs!=1)) 
{
   print "$numbercontigs contigs. Impossible to generate the map./n";
}

if ($ISLOGFILE == 1) 
{
    print "close Logfile : $LOGFILE\n" if $DEBUG;
    close LOGFILE or print "Logfile not closed\n";
}
exit 0;

#############################
#   S U B R O U T I N E S   #
#############################

sub GetOptions 
{          # this function is here to manipulate options
    my $option = new PirObject::Option ();      #  buil a new option model
    $option->FillOption ();                     #  This one buil with the default option and look for a rc file

    ### Now The object contains all the options


    #--General options
    $DEBUG             = $option->debug;         #  Debug mode. If true, display message on the screen
    $GENCODE           = $option->genetic;       #  Genetique code
    $STARTBEFORE       = $option->startbefore;
    $STARTAFTER        = $option->startafter;
    $SIZE              = $option->size;

    my $gentable = Bio::Tools::CodonTable->new();
    if   (not $gentable->id($GENCODE)) 
    {
       die "Unexisting genetic id\n";
    }
    $SIMILARITYSEARCH  = $option->similarity;    #  Usefull for running similaritie gene process for annot.
    if($option->islogfile and defined($option->logfile)) 
    {
      if(-w (dirname($option->logfile))) 
      {
        $ISLOGFILE       = $option->islogfile;     #  Just to know if the $LOGFILE is not empty (0 or 1)
        $LOGFILE         = $option->logfile;       #  log file : store all the information about run
      }
      else 
      {
        print "\nThe path to your logfile \"" . ($option->logfile). "\" is not writable by you.\n";
	print "No file logging will be performed\n";
        $ISLOGFILE       = 0;
        $LOGFILE         = undef;
      }
    }
    $PEPLIBRARIES      = $option->pepdirectory;  #  List of Path for peplibrary directory
    $MASTERFILE        = $option->masterfile;    #  Path for Masterfile
    $INPUTPEPFILES     = $option->inputfile;     #  Path for the peptide file used
    $OUTPUTFILE        = $option->outputfile;    #  Path for the new
    $EXTCONFIGFILE     = $option->ext_config;    #  Path for configfile
    $EXTSELECTPROG     = $option->ext_select;    #  List of names for external prog
    my $count = "";
    my $name = $OUTPUTFILE;
    # Checking to see if the path to the output file is writable
    if(!-w (dirname($name))) 
    {
       die "\nThe path to where your outputfile will be produced is not writable by you ($name).\nPlease resolve this problem before running again\n";
    }

    # Determing new name of output file if file already exists
    chomp ($name);
    $name =~ s/\d*$//; 
    while (-r ("$name"."$count")) 
    {
       if ($count eq "") {$count = 1;}
       else              {$count++;} 
    }      
    $OUTPUTFILE = "$name"."$count";

    $USETRNASCANSE     = $option->tRNAscanSE;    #  T or F : use of tRNAscanSE in the annotation

    if ($USETRNASCANSE) 
    {         
    die "The current version of MFANNOT do not support any more tRNA-scan, it was replace by RNAweasel who is called automatically \n";			  	                                     # find the trna genes
    #print "\nAnnotate with tRNAscanSE...\n";	       		     # by running trnascanSE
    #&AddGeneFeatureUsingtRNAscanSE ($pirmaster, "trnascanSE");       # limited with a score for each case
    }    

    $TAKEINPUTFILE     = $option->takeinputfile; #  A boolean saying if programme is taking an input file
    $TAGNAME           = $option->tagname;       #  Adds a tag  
    $FORCEANNOT        = $option->force;         #  Force the annotation when 2 annotations have the same name
    $MULTIORFS         = $option->multiorfs;     #  Permit 2 annotations for an ORF
    $NEWRCFILE         = $option->newrcfile;     #  Just used to be printed. Indiquates that a new rcfile will be created
    $NORCFILE          = $option->norcfile;      #  0 or 1, if a rcfile has been used for loading data
    $RCFILE            = $option->rcfile;        #  The rcfile used for loading options
    if(!-w (dirname($RCFILE))) 
    {
      die "\nThe path to where your rcfile will be produced is not writable by you ($RCFILE).\nPlease resolve this problem before running again\n";
    }

    $ORFPROCESS        = $option->orf;           #  For Orf process, allowing presence or not in the masterfile
    $LOADSTRICT        = $option->loadstrict;    #  Load strict masterfile
    $ADDCOMMENTS       = $option->addcomments;   #  Add comments in the masterfile
    my $allorfs        = $option->allorfs;       #  All orfs will apear and won't be checked if option is checked
    $CHECKORFS         = 0 if ($allorfs == 1);   #  A little calculation 
    $CHECKORFS         = 1 if ($allorfs == 0);   #  to find the opposite
    $WITHMAP           = $option->withmap;       #  The extension map

    #--Specific for the annotation (parameters for flip, blastall and organization)
    $BLASTEVALUECUTOFF       = $option->blast2;            #  Cutoff value for the blast
    $MINLENGTHORF            = $option->flip2;             #  This is the minimum length for creating an ORF with flip
    $MAXLENGTHFORGROUPINGORF = $option->maxintronsize;     #  Minimum size of a gap between 2 ORf. If 2 same ORF
    $MINLENEMPTYORF          = $option->minlenemptyorf;    #  Minimum length for ORF empty orfs (non corresponding orfs)
    $OVERLAPPINGCUTOFF       = $option->overlappingcutoff; #  Overlapping cutoff for ORFs 
    $TRNACUTOFF              = $option->trnacutoff;        #  tRNAs cutoff 
    $MININTRONSIZE           = $option->minintronsize;     #  opposite of $MAXLENGTHFORGROUPINGORF. Minimum size for intron
    $MINEXONSIZE             = $option->minexonsize;       #  Minimum exon size for intron. In genewise.
    $MATRIX                  = $option->matrix;            #  The matrix used in genewise alignement

}

sub CreatePepfileWithLibrary 
{
    my $library = shift;         # the name of the library
    my $pepfile = shift;         # the name of the file wanted.
                                 # This one contains after the all peptides from the library

    opendir (DIR, $library) or die 'can not open directory\n';        # Open the directory
    my @files = grep {/\.pep$/ and -f "$library/$_"} readdir (DIR);   # Keep the existing *.pep files
    close (DIR);                                                      # Close the directory

    # delete an hyp. previous same. file
    if (-f $pepfile) 
    {
        unlink($pepfile);
    }

    #concatenate all the file from the library
    foreach my $file (@files) 
    {
	my $loc_file = "$library/$file";
	open(PEPFILE,$loc_file) || die ("Can not open the pepfile");
	while (<PEPFILE>) {
	    if ($_ =~ /^>/){
                if (!($_ =~ /\s*([\S]*)\s*;/)) {
		die "The file $library"."$file haven't the good syntax\nThe line who haven't the good syntax is $_";
		}
	    }
	}
        system ("cat $library/$file >> $pepfile"); # Use the cat command to concatenate file in one
	close(PEPFILE);
    }
    return $pepfile;
    exit 0;
}

sub CreateCodonTableWithGeneticId 
{  # this function create a file
   # Having a codon table.
   # ATT F....
   # ATG M...
   # Comment will begin with "!"

    # declaration 
    ###############
    my $geneid         = shift;   # the genetic id for codon usage
    my $codontablefile = shift;   # the name of the file where the codon table will be put
    my $comment        = shift;   # Comment in the header of file
    my $codontable     = Bio::Tools::CodonTable->new( -id => $geneid );
    ###############


    # Process declaration
    #####################
    my @letter = qw (A T C G);
    my $i      = 0;
    my $j      = 0;
    my $z      = 0;
    ######################

    while ($i < scalar(@letter)) 
    {
        $j = 0;
        while ($j < scalar(@letter)) 
	{
            $z = 0;
            while ($z < scalar(@letter)) 
	    {
                my $codon = $letter[$i].$letter[$j].$letter[$z];
                my $aa    = $codontable->translate($codon);
	         	$CODE_GEN{$codon} = $aa;
                $z++;
            }
            $j++;
        }
        $i++;
    }
	
	if ($DEBUG) {
        # open the future file containing the codon table
        open (CODONTABLE, ">$codontablefile") or die "Impossible to open Codon Table file : $codontablefile\n"; 
        print CODONTABLE "! Codon table for genetic code $geneid\n";     # print a short header for description 
    	foreach my $codon ( sort keys %CODE_GEN) {
	    	my $aa = $CODE_GEN{$codon};
	        print CODONTABLE "$codon $aa\n";
        }
        close (CODONTABLE) or die "Impossible to close Codon Table file : $codontablefile\n";
	}
	
}  

sub FindExonsInHypProtArray 
{  # the main is to find exons
   # by making a local alignement

    ########################
    my $pirmaster = shift;        # the masterfile object
    my $flag      = shift || "";  # a flag, assigned to each pepfile
    my $count     = 1;              
    ########################

    for (my $i=0; $i < @PROT_FOR_EXONERATE ; $i++) 
    {
        # HYPOTHETICAL PROTEIN FEATURE
        my $name    = $PROT_FOR_EXONERATE[$i]->[0];
	$name = $1 if ($name =~ /^\/(\w+)/);
	my $contigname = $PROT_FOR_EXONERATE[$i]->[1];
	####################In order to have the contig sequence#################
        my $contig  = $pirmaster->GetContigByName ($PROT_FOR_EXONERATE[$i]->[1]);
	my $seq	    = ">sequence\n";
        $seq        .= $contig->sequence;
        $seq        =~ s/\!//g;
	####################In order to have the contig sequence#################
	my $protein = $PROT_FOR_EXONERATE[$i]->[2];
	my $strand  = $PROT_FOR_EXONERATE[$i]->[3];
	
	my $length = 0;
	my @tab_prot = split(/\n/, $protein);
	for (my $i = 0 ; $i <= $#tab_prot ; $i++)
	{
		if (!($tab_prot[$i] =~ /^>/)){
		$length += length($tab_prot[$i]);
		}
	}
	$length = $length - 1;
	my $overlappe_authorized = ((5*$length)/100);

        # WRITE PROTEIN AND GENE IN FASTA FILES
        my $fileprot = "$TMPDIR/prot_for_exonerate$count"."_"."$flag";
        my $filegene = "$TMPDIR/gene_for_exonerate"."_"."$flag";
        my $exonerate_out = "$TMPDIR/exonerate_$count"."_"."$flag"."_"."$name";


        # check if it exists
        if (-f $fileprot) 
	{ # this file already exists
            unlink($fileprot) or die "Impossible to delete $fileprot\n";
        }

        if (-f $filegene) 
	{ # this file already exists
            unlink($filegene) or die "Impossible to delete $filegene\n";
        }

        if (-f $exonerate_out) 
	{ # this file already exists
            unlink($exonerate_out) or die "Impossible to delete $exonerate_out\n";
        }

        #  open all the prot files and so on
        open (FILEPROT, ">$fileprot") or die "Impossible to open $fileprot\n";
        open (FILEGENE, ">$filegene") or die "Impossible to open $filegene\n";

         # write into the files
        print FILEPROT $protein, "\n" or die "Impossible to paste protein into $fileprot\n";
        print FILEGENE $seq,  "\n" or die "Impossible to paste gene sequence into $filegene\n";

        # close the files
        close (FILEPROT) or die "Impossible to close $fileprot\n";
        close (FILEGENE) or die "Impossible to close $filegene\n";

	my $cmd = "$EXONERATEPATH $Exonerate_parameter  --geneticcode $GENCODE $fileprot $filegene > $exonerate_out"; #$Exonerate_parameter $fileprot $filegene
	print "\n$cmd\n" if $DEBUG;

	my $resultat = system ("$cmd");

	my @tab = `cat "$TMPDIR/exonerate_$count"_"$flag"_"$name"`;			#@tab = the file result of exonerate
	my $flobj = new PirObject::ExonerateOutput();
	$flobj->FillFeaturesFromTextOutput(\@tab);
	#$flobj->ObjectToFile("-");

	my $ExoReports 		= $flobj->report;				#One report contain information about one C4 section present in exonerate Output

	my @sorted_report  = sort { $a->get_query_start() <=> $b->get_query_start()
			       ||   $a->get_query_stop()   <=> $b->get_query_stop()   } @$ExoReports;

	
        my $FirstC4Report = shift(@sorted_report);
        my @report_tab = ( [ $FirstC4Report ] );

        while (@sorted_report) {
            my $NextC4Report     = shift(@sorted_report);
            my $PreviousGroup    = $report_tab[-1];
            my $PreviousC4Report = $PreviousGroup->[-1];

            my $NextStart    = $NextC4Report->get_query_start();
            my $PreviousStop = $PreviousC4Report->get_query_stop();

            if ($NextStart > $PreviousStop || $PreviousStop-$NextStart < $overlappe_authorized) {
                push(@$PreviousGroup,$NextC4Report);
            } else {
                push(@report_tab, [ $NextC4Report ]); # A brand new group is created
            }
        }

	foreach  my $reports (@report_tab) {
	my @exon_start_end	= ();						#tab with information about start and end of all exons present in Exonerte Output
	my %strand;
	foreach my $report (@$reports){
	my $features = $report->dnafeatures;					#$features contains all information present in the part GFF DNA per lines
	my $query_range			= $report->query_range;
	my ($start_query,$end_query)	= ($query_range =~ m#(\d+)\s*->\s*(\d+)#);
	foreach my $lineobj (@$features) {
            my $feat 	= $lineobj->feature;
	    if ($feat eq "exon"){
	    my $strand_exon = $lineobj->strand;
	    $strand{1}++ if  $strand_exon eq "+";				#Just in order to know if we have a transpliced gene
	    $strand{-1}++ if $strand_exon eq "-";
	    }
	}

	my $isMinus = (($strand{1} && !$strand{-1}) ? 0 : 1);
	$strand = 1 if  !$isMinus;
	$strand = -1 if $isMinus;
	foreach my $lineobj (@$features) {
            my $start 	= $lineobj->start;
	    $start 		= $lineobj->end   if $isMinus;
	    my $end		= $lineobj->end;
	    $end 		= $lineobj->start if $isMinus;
	    my $strand_exon = $lineobj->strand;
	    my $feat 	= $lineobj->feature;
	    if ($feat eq "exon"){
	        my $pair_start_end 	= [ $start, $end, $strand_exon, $start_query ];
		push(@exon_start_end, $pair_start_end);				#@exon_start_end contain information about exon with start end and strand of each exons
		}
	}
	}
	

	if ($strand{1} && $strand{-1}){						#If we have a transpliced gene 
	    my $path 		= $OUTPUTFILE;
	    my $dirname  	= dirname($path);					#We must add condition in order to know if it isn't 2 genes
	    my $new_file 	= "$path".".Exonerate_"."$name";
	    my $number = 1;
	    foreach my $exon (@exon_start_end){
	    my $start_exon 	= $exon->[0];
	    my $end_exon 	= $exon->[1];
	    my $strand_exon     = $exon->[2];
	    my $arrow = "==>" if $strand_exon eq "+";
	       $arrow = "<==" if $strand_exon eq "-";
	    my $start_line      = ";; $name-E$number $arrow start";
 	    my $end_line        = ";; $name-E$number $arrow end";
            my $hyp_prot = new PirObject::AnnotPair(
                                               type      => "C",  
                                               genename  => $name,
                                               startpos  => $start_exon,
                                               endpos    => $end_exon,
                                               direction => $arrow,
                                               startline => $start_line,
                                               endline   => $end_line,
                                             );
            &AddAnnotToPirMaster($pirmaster,$contigname,$hyp_prot);
	    $number++;
	    }
	    $add_text_in_header .= ";; The gene coding for $name is probably transpliced (see annotation in comments)\n";
	    next;
	   }

	@exon_start_end = sort {    ($a->[3] <=> $b->[3])
				||  ($a->[0] <=> $b->[0])} @exon_start_end if $strand != -1;	#sort exons_start_end by start brin-

	@exon_start_end = sort {    ($a->[3] <=> $b->[3]) 
				||  ($b->[0] <=> $a->[0])} @exon_start_end if $strand == -1;	#sort exons_start_end by start brin+

	($exon_start_end[0]->[0] = $exon_start_end[0]->[0] - ($exon_start_end[0]->[3]*3)) if ($strand != -1 && $exon_start_end[0]->[3] != 0  && ($exon_start_end[0]->[0] - ($exon_start_end[0]->[3]*3) > 0)); 		   #correction about start of protein
	($exon_start_end[0]->[0] = $exon_start_end[0]->[0] + ($exon_start_end[0]->[3]*3)) if ($strand  == -1 && $exon_start_end[0]->[3] != 0 && ($exon_start_end[0]->[0] + ($exon_start_end[0]->[3]*3) < length($seq)) );  #correction about start of protein

##########################################correction about start and end of exon if two exons is overlapping####################################

	my @exon_start_end_cor	=();						#correction about start and end of exon if two exons is overlapping 
	for (my $i = 0; $i < (@exon_start_end-1); $i++){			#for exemple
		if ($strand != -1) {
		if (!( ($exon_start_end[$i]->[1] < $exon_start_end[$i+1]->[0]) || ($exon_start_end[$i+1]->[1] < $exon_start_end[$i]->[0]) )){	#take the minus start and the bigger stop if exons is on strand +
			my $boolean = (($exon_start_end[$i]->[1] > $exon_start_end[$i+1]->[0]) == 1 ? 0 : 1);
			my $start 		= $exon_start_end[$i]->[0]   if !$boolean;	#if E1_end > E2_start
			my $end  		= $exon_start_end[$i+1]->[1] if !$boolean;	#if E1_end > E2_start
			$start			= $exon_start_end[$i+1]->[0] if $boolean;	#if E2_end > E1_start
			$end  			= $exon_start_end[$i]->[1]   if $boolean;	#if E2_end > E1_start
			my $strand_exon		= $exon_start_end[$i]->[2];
			my $quad_start_end 	= [ $start, $end, $strand_exon, $i , $exon_start_end[$i]->[3]];		#start, end strand and index 
			push(@exon_start_end_cor, $quad_start_end);
		}
		}

		elsif ($strand == -1)  {
		if (!( ($exon_start_end[$i+1]->[0] < $exon_start_end[$i]->[1]) || ($exon_start_end[$i]->[0] < $exon_start_end[$i+1]->[1]) )){	#take the minus start and the bigger stop if exons is on strand +
			my $boolean = (($exon_start_end[$i+1]->[0] > $exon_start_end[$i]->[1]) == 1 ? 0 : 1);
			my $start 		= $exon_start_end[$i]->[0]   if !$boolean;	#if E2_start > E1_end
			my $end  		= $exon_start_end[$i+1]->[1] if !$boolean;	#if E2_start > E1_end
			$start 			= $exon_start_end[$i+1]->[0] if $boolean;	#if E1_start > E2_end
			$end  			= $exon_start_end[$i]->[1]   if $boolean;	#if E1_start > E2_end
			my $strand_exon		= $exon_start_end[$i]->[2];
			my $quad_start_end 	= [ $start, $end, $strand_exon, $i, $exon_start_end[$i]->[3]];		#start, end strand and index 
			push(@exon_start_end_cor, $quad_start_end);
		}
		}
	}

	@exon_start_end_cor = sort { $b->[3] <=> $a->[3] } @exon_start_end_cor; #sort by index

	 for (my $i=0; $i < @exon_start_end_cor; $i++){
		 splice(@exon_start_end,$exon_start_end_cor[$i]->[3],2);	#splice information about overlapping exons
	 }

	 for (my $i=0; $i < @exon_start_end_cor; $i++){				#push information about the new exon 
		 my $start 	 = $exon_start_end_cor[$i]->[0];
		 my $end 	 = $exon_start_end_cor[$i]->[1];
		 my $strand_exon = $exon_start_end_cor[$i]->[2];
		 my $start_query = $exon_start_end_cor[$i]->[4];
		 my $tri = [ $start, $end, $strand_exon, $start_query];			#start and end and strand
		 push(@exon_start_end, $tri );					#push information about the exon corrected into @exons_start_end
	 }
	 
	 @exon_start_end = sort { $a->[3] <=> $b->[3] || $a->[0] <=> $b->[0] || $a->[1] <=> $b->[1] } @exon_start_end if $strand != -1;
	 @exon_start_end = sort { $a->[3] <=> $b->[3] || $b->[0] <=> $a->[0] || $b->[1] <=> $a->[1] } @exon_start_end if $strand == -1;
##########################################correction about start and end of exon if two exons is overlapping####################################
	
	my @intron_start_end;							#Define the tab of intron with the information about exons localisation
 	for (my $i = 0; $i < (@exon_start_end-1); $i++){
         	 my $start 	   = $exon_start_end[$i]->[1] + 1;
		 $start   	   = $exon_start_end[$i]->[1] - 1 if $strand == -1;
	         my $end   	   = $exon_start_end[$i+1]->[0] - 1;
		 $end		   = $exon_start_end[$i+1]->[0] + 1 if $strand == -1;
		 my $strand_intron = $exon_start_end[$i]->[2];
		 my $tri = [$start,$end,$strand_intron];
	         push(@intron_start_end, $tri);	 
	 }

	my $newhypprot = undef;
	my $start = $exon_start_end[0]->[0]   if $strand == 1;
	my $end	  =  $exon_start_end[-1]->[1] if $strand == 1; #acces to the last element of $exon_start_end
	$start 	  =  $exon_start_end[0]->[0]  if $strand != 1;
	$end      =  $exon_start_end[-1]->[1] if $strand != 1; #acces to the last element of $exon_start_end

	$newhypprot = new PirObject::HypProt (
        	                                      name       => $name,
						      contigname => $contigname,
                                                      start      => $start,
                                                      end        => $end,
                                                      strand     => $strand,
                                                      numorfs    => 1,
                                                      remark     => "",
                                                      protein    => $protein,
                                                      score      => "", 
                                                      exons      => [],
                                                      introns    => [],
                                             );
        push (@$HYPPROTS,  $newhypprot);


	my $newhypprotexonarray = $newhypprot->exons;
	for (my $i = 0; $i < @exon_start_end; $i++){
		#fill information about exon
            my $hypprotexon = new PirObject::Exon (
                                                     start  => $exon_start_end[$i]->[0],
                                                     end    => $exon_start_end[$i]->[1],
                                                     strand => $exon_start_end[$i]->[2],
                                                  );
						   push (@$newhypprotexonarray, $hypprotexon); 
        }

	my $newhypprotintronarray = $newhypprot->introns;
	for (my $i = 0; $i < @intron_start_end; $i++){
		#fill information about intron
	my $hypprotintron = new PirObject::Intron (
		 start  => $intron_start_end[$i]->[0],
                 end    => $intron_start_end[$i]->[1],
                 strand => $intron_start_end[$i]->[2],
	 );
	  push (@$newhypprotintronarray, $hypprotintron);
	}
	}
	$count ++;
    }  #  End of each prot        
}

sub AnnotateEmptyOrfs {    # This function takes the empty array of ORF and annotate it as ORFs
                           # It means ORF having non corresponding gene in a pepfile
  
    my $pirmaster = shift; # get the masterfile object
    my $orf_a_annoter = scalar(@$EMPTYORFS);

@$EMPTYORFS = sort {
	$a->get_contigname()                 cmp $b->get_contigname()                 ||
	abs($b->get_start() - $b->get_end()) <=> abs($a->get_start() - $a->get_end()) ||
	$b->get_strand()                     <=> $a->get_strand()                     ||
        $a->get_start()                      <=> $b->get_start()
     } @$EMPTYORFS;     
     
    EMPTYORF : foreach my $emptyorf (@$EMPTYORFS) {             # process each non corresponding orf
     
        ####  Get informations  about empty ORF
        my $contigname            = $emptyorf->contigname;          # Get the contigname corresponding to the empty ORFs
        my $strand_orf            = $emptyorf->strand;

        my $arrow = '==>' if $strand_orf == 1;
        $arrow    = '<==' if $strand_orf != 1;
   
        my $start_orf = $emptyorf->start;
        my $end_orf   = $emptyorf->end;
	my $min_orf   = ($strand_orf == 1 ? $start_orf : $end_orf);
	my $max_orf   = ($strand_orf == 1 ? $end_orf : $start_orf);

	
	my $overlappingcutoff = $OVERLAPPINGCUTOFF;                 # authorized overlapping. It's a percent so it has to be between 0 and 1
        my $minimumlengthorf  = $MINLENEMPTYORF;                    # minimum Orf size, below this size, the ORF is no more kept
        my $contig            = $pirmaster->GetContigByName($contigname) or die "Can't get contig by name in AnnotateEmptyOrfs\n";
 
        my $annotations       = $contig->get_annotations;       # Get the annotations, for the same contig belonging to empty ORF
 
        # Get the new start codon
        my $seq               = $contig->sequence;              # Get the sequence
        $seq                  =~ s/!//g;                        # Remove ! from the sequence
	my $prefix = "";					# Is use for orf intronic

        # SIZE CHECKING
        next EMPTYORF if  (($end_orf - $start_orf + 1 ) < $minimumlengthorf) && $strand_orf == 1;  #  Size Verification 
        next EMPTYORF if  (($start_orf - $end_orf + 1 ) < $minimumlengthorf) && $strand_orf != 1;  #  Size Verification 

        # OTHER CHECKING, SUCH AS OVERLAPPING..........
#	my $annot_who_overlap = &WhatOverlapsThis($start_orf,$end_orf,$contig);
	
	my $isMinus = ($strand_orf == 1 ? 0 : 1);
	my $posOffset = ($isMinus ? -3 : 3);	
	
	my $annotIsOK_gene_without_intron = 0;
	
	  for (;;$start_orf += $posOffset) {
            last if $start_orf >= $end_orf && !$isMinus;
	    last if $end_orf >= $start_orf && $isMinus;
	    last if  (($end_orf - $start_orf + 1 ) < $minimumlengthorf) && !$isMinus;
	    last if  (($start_orf - $end_orf + 1 ) < $minimumlengthorf) &&  $isMinus;  #  Size Verification 
	    my $codon = uc (substr($seq, $start_orf - 1, 3)) if !$isMinus;
	    $codon = uc (substr($seq, $start_orf - 3, 3)) if $isMinus;
	    $codon =~ tr/ACGT/TGCA/ if $isMinus;
	    $codon = reverse $codon if $isMinus;
	    next unless defined($CODE_GEN{$codon}) && $CODE_GEN{$codon} eq "M";
	    $annotIsOK_gene_without_intron = 1;
	    last;
	  }

        next EMPTYORF if $annotIsOK_gene_without_intron == 0;
	
	my $annot_who_overlap = &WhatOverlapsThis($start_orf,$end_orf,$contig);
	
	my $annotIsOk = 0;
	my $number_of_annot = 0;
	my $overlap_an_intron = 0;
	ANNOT : foreach my $info_who_overlap (@$annot_who_overlap) {
		    foreach my $features_who_overlap (@$info_who_overlap ){
			    my $features_min 		= $features_who_overlap->[0];
			    my $features_max 		= $features_who_overlap->[1];
			    my $feature_annot_type 	= $features_who_overlap->[2]->type;
			    my $feature_annot_direction	= $features_who_overlap->[2]->direction;
			    my $feature_startpos 	= $features_who_overlap->[2]->startpos;
			    my $feature_endpos		= $features_who_overlap->[2]->endpos;
			    my $feature_endline		= $features_who_overlap->[2]->endline;
			    $number_of_annot++;
		        for (;;$start_orf += $posOffset) {
			    last if $start_orf >= $end_orf && !$isMinus;
			    last if $end_orf >= $start_orf && $isMinus;
			    
			    last if  (($end_orf - $start_orf + 1 ) < $minimumlengthorf) && !$isMinus;
			    last if  (($start_orf - $end_orf + 1 ) < $minimumlengthorf) &&  $isMinus;  #  Size Verification 
			    			    
			    last if (  (
			                ($features_min <= $start_orf		#
			    	      && $features_max >= $end_orf		#ORF in stand 1 
				      && !$isMinus)				#
							||
				        ($features_min <= $end_orf		#
				      && $features_max >= $start_orf		#ORF in strand -1
				      && $isMinus)				#
				      )
				      && (
					$feature_annot_type eq "E"		#An exon
				      	 		|| 
					($feature_annot_type eq "G"		#Gene without intron
					&& $features_who_overlap->[3] eq "YES")));
			    #Case 1              ------------>		ORF strand 1
			    #               * ------------------- **	Exon or gene without intron strand 1 or -1 we take the smallest value for start and we take the biggest values for end
			    #Case2	         <------------  	ORF strand -1
			
			    my $codon = uc (substr($seq, $start_orf - 1, 3)) if !$isMinus;
			    $codon = uc (substr($seq, $start_orf - 3, 3)) if $isMinus;
			    $codon =~ tr/ACGT/TGCA/ if $isMinus;
			    $codon = reverse $codon if $isMinus;
			    
			    if (!($features_max < $min_orf || $max_orf < $features_min)){
			        $overlap_an_intron = 1;
				last;
			    }
			  
			    next unless defined($CODE_GEN{$codon})  && $CODE_GEN{$codon} eq "M";
			    
			    
			    if ($features_who_overlap->[2]->genename =~ /^trn/){			#Overlap whith ARNt 
			        if (!$isMinus){
				    my $max_start = ( ( $features_min > $start_orf ) ? $features_min : $start_orf);
		                    my $min_end   = ( ( $features_max < $end_orf )   ? $features_max : $end_orf );
				    next if ( 0 < ( $min_end - $max_start + 1));
				    }
				if ($isMinus) {
				    my $min_start = ( ( $features_max < $start_orf ) ? $features_max : $start_orf );
				    my $max_end   = ( ( $features_min > $end_orf )   ? $features_min : $end_orf);
				    next if ( 0 < ( $min_start - $max_end + 1));
				    }
			    }
			    
			    if ( ($feature_annot_type eq "G" && $features_who_overlap->[3] eq "YES")	#Gene without intron
			      || ($feature_annot_type eq "E" && $features_who_overlap->[3] eq "YES")){	#First or last exon
			        if (!$isMinus){
				    if (
				    ($feature_annot_type eq "G")					#Gene whithout intron
				      			   ||   
				    ( $features_who_overlap->[4] eq "FIRST" 				#Case
				             && ( ($start_orf <= $features_min				# ---------->		ORF
					        && $end_orf   >= $features_min				#      --------->	E1
					        && $feature_annot_direction eq "==>"
						   )
					 			||
					           ($start_orf   <= $features_max			#Case
					        && $end_orf      >= $features_max			#     --------->	ORF
					        && $feature_annot_direction eq "<=="			# <--------		E1
						   )
					        )
				     )
					 	    	   ||   
				     ( $features_who_overlap->[4] eq "LAST"
				             && ( ($start_orf <= $features_max				#Case
					        && $end_orf   >= $features_max				#      --------> 	ORF 
					        && $feature_annot_direction eq "==>"			#  -------->		Ef
						   )
					 			||
					          ($start_orf   <= $features_min			#Case
					        && $end_orf     >= $features_min			# ------->		ORF
					        && $feature_annot_direction eq "<=="			#      <---------	Ef
						   )
					        )
					     )
				){
				    my $max_start = ( ( $features_min > $start_orf ) ? $features_min : $start_orf);
		                    my $min_end   = ( ( $features_max < $end_orf )   ? $features_max : $end_orf );
				    next if (  $overlappingcutoff < ( $min_end - $max_start + 1));
				}    
				}
				if ($isMinus) {
				    if (
				    ($feature_annot_type eq "G")					#Gene whithout intron
				      			   ||   
				    ( $features_who_overlap->[4] eq "FIRST" 				#Case
				             && ( ($start_orf >= $features_min				# <--------		ORF
					        && $end_orf   <= $features_min				#      --------->	E1
					        && $feature_annot_direction eq "==>"
						   )
					 			||
					           ($start_orf   >= $features_max			#Case
					        && $end_orf      <= $features_max			#     <---------	ORF
					        && $feature_annot_direction eq "<=="			# <--------		E1
						   )
					        )
				     )
					 	    	   ||   
				     ( $features_who_overlap->[4] eq "LAST"
				             && ( ($start_orf >= $features_max				#Case
					        && $end_orf   <= $features_max				#      <-------- 	ORF 
					        && $feature_annot_direction eq "==>"			#  -------->		Ef
						   )
					 			||
					          ($start_orf   >= $features_min			#Case
					        && $end_orf     <= $features_min			# <-------		ORF
					        && $feature_annot_direction eq "<=="			#      <---------	Ef
						   )
					        )
					     )
				){
				    my $min_start = ( ( $features_max < $start_orf ) ? $features_max : $start_orf );
				    my $max_end   = ( ( $features_min > $end_orf )   ? $features_min : $end_orf);
				    next if (   $overlappingcutoff < ( $min_start - $max_end + 1));
				    }
				}
			    }
			    	
			    if ($feature_annot_type eq "E"){
			       
			       if (!$isMinus){
			          if ( ($features_who_overlap->[3] ne "YES")	    		#Intern exon
			                           ||						#No overlap is accepted
				       ($features_who_overlap->[4] eq "FIRST"			#First internal exon overlap
				     && $start_orf <= $feature_endpos
				     && $end_orf   >= $feature_endpos
				     )
				       		   ||
				       ($features_who_overlap->[4] eq "LAST"			#Last internal exon overlap
				     && $start_orf <= $feature_startpos
				     && $end_orf   >= $feature_startpos 
				   )
				   ){
				    my $max_start = ( ( $features_min > $start_orf ) ? $features_min : $start_orf);
		                    my $min_end   = ( ( $features_max < $end_orf )   ? $features_max : $end_orf );
				    next if ( 0 < ( $min_end - $max_start + 1));
				   }
			       }
			       
			       if ($isMinus){
			          if ( ($features_who_overlap->[3] ne "YES")			#Intern exon
			       	                 ||						#No overlap is accepted
				       ($features_who_overlap->[4] eq "FIRST"			#First internal exon overlap
				     && $start_orf >= $feature_endpos
				     && $end_orf   <= $feature_endpos
				     )
				                ||
				       ($features_who_overlap->[4] eq "LAST"			#Last internale exon overlap
				     && $start_orf >= $feature_startpos
				     && $end_orf   <= $feature_startpos
				     )
				     ){
				        my $min_start = ( ( $features_max < $start_orf ) ? $features_max : $start_orf );
				        my $max_end   = ( ( $features_min > $end_orf )   ? $features_min : $end_orf);
				        next if ( 0 < ( $min_start - $max_end + 1));
				     }
			       }
			    }
			    $annotIsOk++;
			    last;
			}

		    }
	}

      if ( (@$annot_who_overlap && $annotIsOk == $number_of_annot) || (!@$annot_who_overlap && $annotIsOK_gene_without_intron == 1) 
         && $overlap_an_intron == 0){
      ### Creating an annotation object for storing in the masterfile
      my $orfsize = ($end_orf - $start_orf + 1)/3  if  !$isMinus;
      	 $orfsize = ($start_orf - $end_orf + 1)/3  if   $isMinus;
         $orfsize--; # minus 1 for the stop codon
      my $GenenameORF = "orf". $orfsize;

      #-------------------------------------------------------------------------------------
      #  Treatment to add a number after the genename ______________________________________
      #-------------------------------------------------------------------------------------
      my $startline = "";
      my $endline = "";
      $startline  = ";     G-$GenenameORF $arrow start";
      $startline  = ";     G-$prefix-"."$GenenameORF $arrow start" if $prefix ne "";
      $startline .= " ;; MFFEAT=$TAGNAME empty ORF" if $ADDCOMMENTS;     # add comments if option is activated
      $endline    = ";     G-$GenenameORF $arrow end";
      $endline  = ";     G-$prefix-"."$GenenameORF $arrow end" if $prefix ne "";
      $endline   .= " ;; MFFEAT=$TAGNAME empty ORF" if $ADDCOMMENTS;
      #________________________________________________________________________________
   
      my $orfannot = new PirObject::AnnotPair(
                                               type      => "G",  
                                               genename  => $GenenameORF,
                                               startpos  => $start_orf,
                                               endpos    => $end_orf,
                                               direction => $arrow,
                                               startline => $startline,
                                               endline   => $endline,
                                             );
    
      # Put into the table containing all of the masterfile annotations
      # So before, being put in the masterfile (means in a first time in the annotation table), there are some verification
      &AddAnnotToPirMaster($pirmaster,$contigname,$orfannot);
      } # END OF IF
  } # END OF FOR EACH EMPTY ORFS
} # End function AnnotateEmptyOrfs

sub AnnotateIntronicOrfs {
    my $pirmaster	 	= shift; # get the masterfile object
    my $contigs  		= $pirmaster->get_contigs();
    my $minimumlengthorf_nt  	= $MINLENEMPTYORF;
    my $minimumlengthorf_aa	= $minimumlengthorf_nt / 3;
    my $intronic_orfs;
    my $potential_intronic_orfs;
    my %Code;
    my %DefStarts;
    
    &GC::GetGC(\%Code, \%DefStarts, $GENCODE);
    &clean_die( qq/The genetic code $GENCODE is invalid/ ) unless 
    keys %Code;
    my $code_ref = &adjust_code( \%Code );
    
    foreach my $contig (@$contigs) {
	 my $name    	= $contig->get_name();       	# get the name for the contig
	 my $annotation = $contig->get_annotations();
	 my $seq     	= $contig->get_sequence();   	# get the sequence for each contig
	 $seq        	=~ s/[^atcgATCGnN]//g;
	 my $test_prot  = "";
	 foreach my $annot (@$annotation){
	     my $type 		= $annot->get_type();
	     my $direction	= $annot->get_direction();
	     my $start		= $annot->get_startpos();
	     my $end 		= $annot->get_endpos();
	     my $startline 	= $annot->get_startline();
	     my $endline 	= $annot->get_endline();
	     my $prefix 	= "";
	     my $prot 		= "";
	     my @orf; 
	     if ($type eq "I"){
		 $prot		= "";
		 ($prefix) 	= $endline =~ /;\s+G-(\S+)/;
		 $startline	=~ m#G-(\S+)-I(\d+)#;
		 my $num_intron = $2;
		 for (my $j = 0; $j < 3; $j++){
		 $start 		= $annot->get_startpos() + $j if $direction eq "==>";
		 $start 		= $annot->get_startpos() - $j if $direction eq "<==";
		 my $min_pos		= ($direction eq "==>" ? $start : $end );
		 my $max_pos		= ($direction eq "==>" ? $end : $start );
		 my $diff		= $max_pos - $min_pos + 1;
		 my $intronic_sequence  = substr($seq, $min_pos -1, $diff);
		 my $modulo	  	= length($intronic_sequence) % 3;
		 $intronic_sequence     =~ tr/acgt/ACGT/;
		 $intronic_sequence 	=~ tr/ACGT/TGCA/ if $direction eq "<==";
		 $intronic_sequence 	= reverse $intronic_sequence if $direction eq "<==";
		 $intronic_sequence 	= substr($intronic_sequence,0, length($intronic_sequence)-$modulo);
		 $intronic_sequence 	=~ tr/a-z/A-Z/;
		 my @pos_of_stop	= ();
		 ($prot = $intronic_sequence ) =~ s/(...)/$code_ref->{$1}/ge;
		 for (my $i = 0; $i <= length($intronic_sequence) - 3 ; $i += 3){
		     my $orf;
		     my $strand_current_orf 	 = $direction; 
		     my $nt = substr($intronic_sequence,$i,3);
		     my $aa = $code_ref->{$nt};
		     if ($aa eq "*"){
			 my $relative_pos_of_stop = $i+3;		#In order to include stop codon
			 push(@pos_of_stop, $relative_pos_of_stop);
		     }	#if
		 } #for
		 unshift(@pos_of_stop, 0);
		 for (my $i = 0; $i < @pos_of_stop - 1; $i++){
		     if ( abs($pos_of_stop[$i+1] - $pos_of_stop[$i]) >= $minimumlengthorf_nt ){
		        my $start_orf	= $start + $pos_of_stop[$i] 	  if $direction eq "==>";
			   $start_orf   = $start - $pos_of_stop[$i]       if $direction eq "<==";
			my $end_orf	= $start + $pos_of_stop[$i+1] - 1 if $direction eq "==>";
			   $end_orf	= $start - $pos_of_stop[$i+1] + 1 if $direction eq "<==";
			   
			my $intronic_orf = new PirObject::EmptyOrf (
                                                    start  	=> $start_orf,
                                                    end    	=> $end_orf,
                                                    strand 	=> $direction,
                                                    contigname 	=> $name,
						    intron 	=> $num_intron,
						    phase 	=> $j,
						    prefix	=> $prefix
                                                  );
			push (@$intronic_orfs, $intronic_orf);
		       } #if
		 } #for $i
	     } #for $j
	   } #if Intron
	 } #foreach annot
    } #foreach #contig
    
    
    
    foreach my $intronic_orf (@$intronic_orfs) {
	my $annotIsOk		= 0;
	my $start_orf		= $intronic_orf->get_start();
	my $end_orf		= $intronic_orf->get_end();
	my $direction 		= $intronic_orf->get_strand();
	my $contigname		= $intronic_orf->get_contigname();
	my $prefix		= $intronic_orf->get_prefix(); 
	my $contig            	= $pirmaster->GetContigByName($contigname) or die "Can't get contig by name in AnnotateEmptyOrfs\n";
	my $seq                 = $contig->sequence;              # Get the sequence
        $seq                    =~ s/!//g;                        # Remove ! from the sequence
	my $annot_who_overlap 	= &WhatOverlapsThis($start_orf,$end_orf,$contig);
	my $isInPhase 		= &IsInPhase($intronic_orf,@$annot_who_overlap);
	my $isMinus 		= ($direction eq "==>" ? 0 : 1);
	my $posOffset		= ($isMinus ? -3 : 3);			

	for (;;$start_orf += $posOffset) {
	    last if $start_orf >= $end_orf   && !$isMinus;
	    last if $end_orf   >= $start_orf && $isMinus;

	    last if  (($end_orf - $start_orf + 1 ) < $minimumlengthorf_nt) && !$isMinus;
	    last if  (($start_orf - $end_orf + 1 ) < $minimumlengthorf_nt) &&  $isMinus;  #  Size Verification 
		 
	     my $codon = uc (substr($seq, $start_orf - 1, 3)) if !$isMinus;
	     $codon    = uc (substr($seq, $start_orf - 3, 3)) if $isMinus;
	     $codon    =~ tr/ACGT/TGCA/ if $isMinus;
	     $codon    = reverse $codon if $isMinus;
	     $codon    = "ATG" if $isInPhase;
	     
	     next unless defined($CODE_GEN{$codon})  && $CODE_GEN{$codon} eq "M";
	     $annotIsOk = 1;
	     last;
	}
	
	if ( $annotIsOk == 1){
	    ### Creating an annotation object for storing in the masterfile
	    my $orfsize = ($end_orf - $start_orf + 1)/3  if  !$isMinus;
	    $orfsize = ($start_orf - $end_orf + 1)/3  if   $isMinus;
	    $orfsize--; # minus 1 for the stop codon
	    my $GenenameORF = "orf". $orfsize;
	    
	    my $diff_nt = $end_orf - $start_orf + 1 if $direction eq "==>";
	    $diff_nt = $start_orf - $end_orf + 1 if $direction eq "<==";
	    
	    my $seq_orf_nt = substr($seq, $start_orf - 1, $diff_nt) if $direction eq "==>";
	    
	    $seq_orf_nt = substr($seq, $end_orf - 1 , $diff_nt) if $direction eq "<==";
	    $seq_orf_nt =~ tr/ACGT/TGCA/ if $direction eq "<==";
	    $seq_orf_nt = reverse $seq_orf_nt if $direction eq "<==";
	    
	    $seq_orf_nt =~ tr/a-z/A-Z/;
	    
	    my $seq_orf_aa = "";
	    ($seq_orf_aa = $seq_orf_nt ) =~ s/(...)/$code_ref->{$1}/ge;

	    my $potential_intronic_orf = new PirObject::EmptyOrf (
                                                    start  	=> $start_orf,
                                                    end    	=> $end_orf,
                                                    strand 	=> $direction,
                                                    contigname 	=> $contigname,
						    intron 	=> $intronic_orf->get_intron(),
						    phase 	=> $intronic_orf->get_phase(),
						    prefix	=> $prefix,
						    size	=> $orfsize,
						    seq 	=> $seq_orf_aa
                                                  );
	    push (@$potential_intronic_orfs, $potential_intronic_orf);
      }
    }
    
    
    my %no_annotation;
    if ($potential_intronic_orfs){
    for (my $i = 0; $i < @$potential_intronic_orfs; $i++){
	my $start_orf_1		= @$potential_intronic_orfs[$i]->get_start();
	my $end_orf_1 		= @$potential_intronic_orfs[$i]->get_end();
	my $direction_orf_1	= @$potential_intronic_orfs[$i]->get_strand();
	my $min_pos_orf_1	= ($direction_orf_1 eq "==>" ? $start_orf_1 : $end_orf_1);
	my $max_pos_orf_1	= ($direction_orf_1 eq "==>" ? $end_orf_1   : $start_orf_1);
	my @tab_for_choose_intron;
	my $selected_orf	= "";
	push(@tab_for_choose_intron, [$i, @$potential_intronic_orfs[$i]]); 
	for (my $j = 0; $j < @$potential_intronic_orfs; $j++){
	    if ($j != $i){
		my $start_orf_2 	= @$potential_intronic_orfs[$j]->get_start();
		my $end_orf_2 		= @$potential_intronic_orfs[$j]->get_end();
		my $direction_orf_2	= @$potential_intronic_orfs[$j]->get_strand();
		my $min_pos_orf_2	= ($direction_orf_2 eq "==>" ? $start_orf_2 : $end_orf_2 );
		my $max_pos_orf_2	= ($direction_orf_2 eq "==>" ? $end_orf_2   : $start_orf_2);
	    
	   	if (!($max_pos_orf_1 < $min_pos_orf_2 || $max_pos_orf_2 < $min_pos_orf_1)){
		    push(@tab_for_choose_intron, [$j, @$potential_intronic_orfs[$j]]); 
		}
	    }
	}
	
	if (@tab_for_choose_intron > 1){
	    my $num_selected_orf = &choice_orf(\@tab_for_choose_intron);
	    $selected_orf = @$potential_intronic_orfs[$i] if $num_selected_orf == $i;
	}
	else {
	    $selected_orf = @$potential_intronic_orfs[$i];
	}
	
	if ($selected_orf ne ""){
	#-------------------------------------------------------------------------------------
	#  Treatment to add a number after the genename ______________________________________
	#-------------------------------------------------------------------------------------
	my $GenenameORF		= "orf".$selected_orf->get_size();
	my $direction 		= $selected_orf->get_strand();
	my $prefix 		= $selected_orf->get_prefix(); 
	my $contigname		= $selected_orf->get_contigname();
	my $startline  		= ";     G-$GenenameORF $direction start";
	   $startline  		= ";     G-$prefix-"."$GenenameORF $direction start" if $prefix ne "";
	   $startline 	       .= " ;; MFFEAT=$TAGNAME empty ORF" if $ADDCOMMENTS;     # add comments if option is activated
	my $endline    		= ";     G-$GenenameORF $direction end";
	   $endline    		= ";     G-$prefix-"."$GenenameORF $direction end" if $prefix ne "";
	   $endline            .= " ;; MFFEAT=$TAGNAME empty ORF" if $ADDCOMMENTS;
	#________________________________________________________________________________
	
	my $orfannot = new PirObject::AnnotPair(
       	                                       type      => "G",  
                                               genename  => $GenenameORF,
                                               startpos  => $selected_orf->get_start(),
                                               endpos    => $selected_orf->get_end(),
                                               direction => $direction,
                                               startline => $startline,
                                               endline   => $endline,
                                             );
    
      	# Put into the table containing all of the masterfile annotations
	# So before, being put in the masterfile (means in a first time in the annotation table), there are some verification
	&AddAnnotToPirMaster($pirmaster,$contigname,$orfannot);
	}
    }
    }
}

sub choice_orf{
    my $orfs	= shift;  # ref to array of pairs [ idx, Orf_object ]
    my $lib     = "/share/supported/apps/ogmp/lib/mfannot/intronic_orfs.pep";

    if (!(-e "$TMPDIR/fdb_intronic_orf.log")){
	
	open(LIB,$lib) || die ("Can not open the library for intronic orfs");
	while (<LIB>) {
	    if ($_ =~ /^>/){
                if (!($_ =~ /\s*([\S]*)\s*;/)) {
		die "The file $lib haven't the good syntax\nThe line who haven't the good syntax is $_";
		}
	    }
	}
	close(LIB);
    
        my $command      = "$FORMATDBPATH -p 'T' -t banque -i $lib -n $TMPDIR/mf_intronic_orf -l $TMPDIR/fdb_intronic_orf.log >/dev/null 2>/dev/null";
	print "$command\n" if $DEBUG;
	my $resformatdb  = system($command);
    }
    
    foreach my $orf ( @$orfs ) {
	my $name_of_file = "$TMPDIR/orf_".$orf->[0];
	my $orf_seq	 = $orf->[1]->get_seq();
	my $orf_num 	 = $orf->[0];
	my $output       = "$TMPDIR/blastoutput_orf_".$orf->[0];
	my $type         = 'PROT';
	if (!(-e "$name_of_file")){
	    open(ORFFILE,">$name_of_file") || die ("Can not open the orffile");
	    print ORFFILE ">ORF_$orf_num\n";
	    print ORFFILE $orf_seq;
	    close(ORFFILE);
	    
	    #RUN FOR BLAST : run blast with the db created and the flip results        
	    my $cmdblast     = "$BLASTPATH -p blastp -d $TMPDIR/mf_intronic_orf -i $name_of_file -D $GENCODE -o $output 2> $TMPDIR/blasterr_1.txt";
	    print "$cmdblast\n" if $DEBUG;
	    my $resblast = system ($cmdblast);
	}
	    
	if (! -r $output) { # it's supposed to be here at this point.
		die "Error: can't find $type report from blastall ?!?\n";
	}
	my $searchio = new Bio::SearchIO (
                                       -format => 'blast',
                                       -file   => $output,
                                     );

	my $result           = $searchio->next_result();
	my $num 	     = $searchio->result_count;
	die "We have most of 1 blast result for 1 orf " if $num > 1;
	my @hits 	     = $result->hits();               # Bio::Search::Hit::HitI
	$orf->[1]->set_score (9999); # really bad evalue by default
	next if !@hits;
	my $best_evalue      = $hits[0]->significance;
	$orf->[1]->set_score ($best_evalue);
    }
    
    my @orfs_sorted = sort
    { $a->[1]->get_score() <=> $b->[1]->get_score()
	   		||
      $b->[1]->get_size() <=>  $a->[1]->get_size()
    }
    @$orfs;
    
    return $orfs_sorted[0]->[0];
}

sub adjust_code {
  my( $code_ref ) = @_;

  my $value;         # Will hold the aa assigned to a codon containing an N
  my $good;          # 0 if a codon containing an N is associated to aa "X"
                     # (undefined), 1 otherwise.
  my $reg_exp;       # Temp var
  my( $x, $y, $z );  # Counters            

  for $x ( qw/A C G T N/ ){
    for $y ( qw/A C G T N/ ){
      for $z ( qw/A C G T N/ ){
	next unless $x eq 'N' or $y eq 'N' or $z eq 'N';
	($reg_exp = "$x$y$z") =~ tr/N/./;

        # Look if all codons matching $regexp have the same aa
        $value = "";
	$good = 1;
        foreach( keys %$code_ref ){
	  next unless /$reg_exp/;
	  $value = $code_ref->{$_}, next unless $value;
	  $good = 0, last if $value ne $code_ref->{$_};
	}

        $code_ref->{"$x$y$z"}  = $good ? $value : "X";
      }
    }
  }
return $code_ref;
}

sub AnnotateMfFromHYPPROTSArray { # This function annotates the masterfile from the blast results

    my $pirmaster = shift;

    foreach my $hyprot (@$HYPPROTS) {
        my $name = $hyprot->name;
        # go the next protein if name is not defined
        next if (not (defined ($name)) or ($name eq ""));
        my $contigname        = $hyprot->contigname;
        my $start             = $hyprot->start;
        my $end               = $hyprot->end;
  	my $prot	      = $hyprot->protein;
	my $length	      = 0;				#length of the library protein
  	my $length_protein    = 0; 				#length of the annotated protein

	my @tab_prot = split(/\n/, $prot);
	for (my $i = 0 ; $i <= $#tab_prot ; $i++)
	{
		if (!($tab_prot[$i] =~ /^>/)){
		$length += length($tab_prot[$i]);
		}
	}

	$length = $length - 1;

        my $arrow;
	my $exons = $hyprot->exons;
	my $isMinus = ($hyprot->strand == 1 ? 0 : 1);

	#Define arrows
	$arrow = '==>'; 
        $arrow = '<==' if $isMinus;

	#Define the length of the protein in order to compare them at the length of homolog protein
	if (@$exons){											#For protein with exon/intron
		foreach my $exon (@$exons)
		{
		    my $length_exon = $exon->end - $exon->start + 1;
		    $length_exon = $exon->start - $exon->end + 1 if $isMinus;
		    $length_protein += $length_exon /3 ; 
		}
	    $length_protein = $length_protein - 1;
	    }
	else												#For protein without intron
	{
	    $length_protein = (( $end - $start + 1 )/3) -1;
	    $length_protein = (( $start - $end + 1 )/3) -1 if $isMinus;
	}

	#Define the interval of length
	my $size_pourcent = (($SIZE * $length) / 100);
	my $length_min    = $length - $size_pourcent;
	my $length_max    = $length + $size_pourcent;

	#Put a warning if the length of protein is too small or too large
        my $tag               = $hyprot->remark;
	my $warning	      = $hyprot->warning || "";
	if ($warning eq "" && $length_protein < $length_min)
	{
		$warning = "Sequence is too small";
	}
	elsif ($warning ne "" && $length_protein < $length_min)
	{
		$warning .= " and sequence is too small"; 
	}
	elsif ($warning eq "" && $length_protein > $length_max)
	{
		$warning = "Sequence is too large";
	}
	elsif ($warning ne "" && $length_protein > $length_max)
	{
		$warning .= " and Sequence is too large";
	}
	else
	{
		$warning = $warning;
	}


	#annot the gene
        my $linename          = $name;                     # the name gene in start and endline
	my $startline 	      = "";

        $startline           .= ";     G-$linename $arrow start ;; Warning : $warning" if $warning ne "";
	$startline           .= ";     G-$linename $arrow start" if $warning eq "";
        $startline           .= " ;; MFFEAT=$TAGNAME ;; $tag" if $ADDCOMMENTS; # add comments if option is checked
        my $endline           = ";     G-$linename $arrow end";
        $endline             .= " ;; MFFEAT=$TAGNAME ;; $tag" if $ADDCOMMENTS;  # add comments if option is checked

        my $protannot = new PirObject::AnnotPair (
                                                   type      => "G", 
                                                   genename  => "$name",
                                                   startpos  => $start,
                                                   endpos    => $end,
                                                   direction => $arrow,
                                                   startline => $startline,
                                                   endline   => $endline,
                                                 );
        my $res               = &AddAnnotToPirMaster($pirmaster,$contigname,$protannot);

        # go out of the function if the protein has not been added
        if (!defined ($res) or $res == 0) {
            $ANNOT_STATS->{'Rediscovered'}->{$protannot->genename}->{'E'} += scalar (@$exons) if (scalar (@$exons) > 0);
            next;
        } 

        if ($name =~ /^orf/) {   # if it's an ORF, then it goes to through, because an ORF must not have  
            next;
        }
        if (scalar (@$exons) <= 1) {  # if there is only one exon, and if option is not checked, go to the next prot
            next;
        }     

        # Annotating exons

	my $strand = $hyprot->strand;
	my $number = ($isMinus ? 1 : 1);
	my $compt = ($isMinus ? 1 : 1);
        foreach my $exon (@$exons) {
            my $exon_start  = $exon->start;
            my $exon_end    = $exon->end;
            my $exon_strand = $exon->strand;

            my $start_line  = ";     G-$linename-E$number $arrow start";
            $start_line    .= " ;; MFFEAT=$TAGNAME" if $ADDCOMMENTS;       # option checked, add comments
            my $end_line    = ";     G-$linename-E$number $arrow end";
            $end_line      .= " ;; MFFEAT=$TAGNAME" if $ADDCOMMENTS;       # option checked, add comments

            my $exon_annot = new PirObject::AnnotPair (
                                                       type      => "E",
                                                       genename  => "$name",
                                                       startpos  => $exon_start,
                                                       endpos    => $exon_end,
                                                       direction => $arrow,
                                                       startline => $start_line,
                                                       endline   => $end_line,
                                                     );

            $number += $compt;
            my $res       = &AddAnnotToPirMaster($pirmaster,$contigname,$exon_annot);
        }

        # Annotating introns

	my $introns = $hyprot->introns;
        $number = ($isMinus ? 1 : 1);
	foreach my $intron (@$introns) {
            my $intron_start  = $intron->start;
            my $intron_end    = $intron->end;
            my $intron_strand = $intron->strand;

            my $start_line  = ";     G-$linename-I$number $arrow start";
            $start_line    .= " ;; MFFEAT=$TAGNAME" if $ADDCOMMENTS;       # option checked, add comments
            my $end_line    = ";     G-$linename-I$number $arrow end";
            $end_line      .= " ;; MFFEAT=$TAGNAME" if $ADDCOMMENTS;       # option checked, add comments

            my $intron_annot = new PirObject::AnnotPair (
                                                       type      => "I",
                                                       genename  => "$name",
                                                       startpos  => $intron_start,
                                                       endpos    => $intron_end,
                                                       direction => $arrow,
                                                       startline => $start_line,
                                                       endline   => $end_line,
                                                     );

            $number += $compt;
            my $res       = &AddAnnotToPirMaster($pirmaster,$contigname,$intron_annot);
        }
    }
}

sub OrganiseHYPPROTSArray { # This function is supposing to find the real start and recreating exon if necessary

    my $condontablle = $TMPDIR . "/codons". $GENCODE .".table";
    &CreateCodonTableWithGeneticId ($GENCODE, $condontablle);

    my $pirmaster      = shift;
    my $possiblestarts = ['ATG', 'AUG'];

    #################   The first thing is to look for the new start #########################
    foreach my $hypprot (@$HYPPROTS) {
        my $oldstartpos = $hypprot->start; 					# Get the old start position
        my $newstartpos = $hypprot->start;
	my $warning 	= $hypprot->warning;					#Get Warning
	my $new_warning	= $hypprot->warning;
	my $strand      = $hypprot->strand;
        my $found       = 0;
        my $contig      = $pirmaster->GetContigByName ($hypprot->contigname); 	# Get the contig
        my $seq         = $contig->sequence; 				      	# Get sequence
        $seq            =~ s/!//g;
        my $end         = $hypprot->end;					#Get end


	##########initialization############
      	my %hash;
	my @tab;
	my @tab_ATG_pos;
	my @tab_ATG_neg;
	my @tab_ATG_neutre;
	my @tab_GTG_pos;
	my @tab_GTG_neg;
	my @tab_GTG_neutre;

	my $currentpos  = $hypprot->start;					
	my $isMinus = ($hypprot->strand == 1 ? 0 : 1);
	my $posOffset = ($isMinus ? -3 : 3);
	my @i_start;


	for (my $i = -$STARTBEFORE; $i <= $STARTAFTER; $i++, $currentpos += $posOffset)
		{
		next if ((!$isMinus && ($currentpos-1-($STARTBEFORE*3) < 0)) || ($isMinus && ($currentpos+($STARTBEFORE*3)-3 > length($seq)-3 )))  ;
		next if ((!$isMinus && ($currentpos-1-($STARTBEFORE*3) > length($seq)-3)) || ($isMinus && (($currentpos+($STARTBEFORE*3)-3) < 0 ) ) ) ;
		$hash{$i}= uc (substr($seq, $currentpos-1-($STARTBEFORE*3), 3));
		my $pos = $currentpos-1-($STARTBEFORE*3);
		#print "i = $i pos = $pos start = $oldstartpos\n";
		if ($isMinus) {							#Reverse complement case
	            my $codon = uc (substr($seq, $currentpos+($STARTBEFORE*3)-3, 3));
		    #print "codon = $codon\n";
		    $pos = $currentpos+($STARTBEFORE*3)-3;
		    $codon =~ tr/ACGT/TGCA/;
		    $codon = reverse $codon;
		    $hash{$i} = $codon;
	        }
		#print "hash = $hash{$i}\n";
		if (defined($CODE_GEN{$hash{$i}})  && $CODE_GEN{$hash{$i}} eq "*"){ push(@tab, $i);} 
		push(@i_start, $i);
		}

        my $compt_i = $i_start[0];
	my $compt_f = $i_start[-1];
	$compt_i = $tab[-1]+1 if @tab;

	for (my $i = $compt_i ; $i <= $compt_f; $i++)
	{
		#print "i = $i hash = $hash{$i}\n";
		if ($hash{$i} eq "ATG")
		{
			if ($i > 0)
			{
				push(@tab_ATG_pos, $i);
			}
			elsif ($i < 0) 
			{
				push(@tab_ATG_neg, $i);
			}
			elsif ($i ==0)
			{
				push(@tab_ATG_neutre, $i);
			}
		}

		elsif ($hash{$i} eq "GTG")
		{
			if ($i > 0)
			{
				push(@tab_GTG_pos, $i);
			}
			elsif ($i < 0) 
			{
				push(@tab_GTG_neg, $i);
			}
			elsif ($i ==0)
			{
				push(@tab_GTG_neutre, $i);
			}
		}		
	}


if ( ! (@tab_ATG_pos || @tab_ATG_neutre || @tab_ATG_neg)) {			#If not ATG look for GTG
	@tab_ATG_pos = @tab_GTG_pos;
	@tab_ATG_neg = @tab_GTG_neg;
	@tab_ATG_neutre = @tab_GTG_neutre;
}

if (@tab_ATG_pos || @tab_ATG_neutre || @tab_ATG_neg)
{ 	
	if (@tab_ATG_neutre)
	{
		$newstartpos = $oldstartpos;
	}
	elsif ( @tab_ATG_pos  && ! @tab_ATG_neg )  #start en aval si brin +
	{
		$newstartpos = $oldstartpos + (3*$tab_ATG_pos[0]);
		$newstartpos = $oldstartpos - (3*$tab_ATG_pos[0])  if $isMinus;
	}
	elsif ( ! @tab_ATG_pos && @tab_ATG_neg )  #start en amont si brin -
	{
		$newstartpos = $oldstartpos + (3*$tab_ATG_neg[-1]);
		$newstartpos = $oldstartpos - (3*$tab_ATG_neg[-1]) if $isMinus;
	}
	elsif ( @tab_ATG_pos  && @tab_ATG_neg ){
		if (abs($tab_ATG_neg[-1]/3) > $tab_ATG_pos[0])
		{
			$newstartpos = $oldstartpos + (3*$tab_ATG_pos[0]);
			$newstartpos = $oldstartpos - (3*$tab_ATG_pos[0]) if $isMinus;
		} 
		else
		{
		$newstartpos = $oldstartpos + (3*$tab_ATG_neg[-1]);
		$newstartpos = $oldstartpos - (3*$tab_ATG_neg[-1]) if $isMinus;
		}
	}
}

else { $newstartpos = $oldstartpos; $new_warning .= "See for start codon"}

        $hypprot->set_start ($newstartpos);  # set the new start to the protein
	$hypprot->set_warning ($new_warning);
	my $name = $hypprot->name; 
	my $exons = $hypprot->exons;


	if (@$exons){
        my $first_exon = $exons->[0];
	my $end_exon   = $exons->[-1];
	my $end = $end_exon->end;

	if ($strand == 1){
		for (my $i = -3;; $i += 3)
		{
			my $length = length($seq);
			#print length($seq)."\n";
			last if $end+$i > length($seq)-3;
			my $tri_nt      = uc (substr($seq, $end + $i, 3));
			my $codon	= $CODE_GEN{$tri_nt};
			next if $codon ne "*";
			my $new_end	= $end + $i + 3;
			$end_exon->end($new_end);
			$hypprot->end($new_end);  # set the new end to the protein
			last;	
		}
	}

	elsif ($strand != 1){
		for (my $i = 0;; $i -= 3)
		{
			#print "name=$name i=$i end=$end\n";
			last if $end+$i-1 < 0;
			my $tri_nt      = uc (substr($seq, $end + $i - 1 , 3));
			#print "tri_nt_before=$tri_nt";
			$tri_nt    =~ tr/ATUGCatugc/TAACGTAACG/;
			$tri_nt    = reverse ($tri_nt);#Reverse and complementary
			#print "tri_nt_after=$tri_nt\n";
			my $codon	= $CODE_GEN{$tri_nt};
			#print "codon=$codon";
			next if $codon ne "*";
			my $new_end	= $end + $i;
			#print "new_end=$new_end\n";
			$end_exon->end($new_end);
			$hypprot->end($new_end);  # set the new end to the protein
			last;	
		}	
	}
	$first_exon->start($newstartpos);
	}
}
} # End function

sub ValueIsIn {  # check if a value is in an array

    my $array = shift;
    my $value = shift;

    foreach my $result (@$array) {
        if ($value eq $result) {
            return 1;
        }
    }

    return -1;
}

sub RunFlip { # This function run flip with the masterfile
              # Flip is a program generating ORF

    my $flag = shift || "";    # something to recognize, what is the pepfile treated
    my $cwd  = cwd();          # Let's get the current working directory name

    # We need to change to the temporary directory to run flip - just so the flip files are written here.
    chdir ("$TMPDIR");

    # Just check if Flip outfiles exist here already, if so get rid of them

    if (-e "prot.lst") {
      unlink("prot.lst");
    }
    if (-e "prot.src") {
      unlink("prot.src");
    }
    if (-e "compl") {
      unlink("compl");
    }
    if (-e "uncompl") {
      unlink("uncompl");
    }

    # Checking the see if the masterfile path is aboslute or relative
    my $tmpMasterfile;
    if ($MASTERFILE =~ m!^/!) {
        # absolute
        $tmpMasterfile = $MASTERFILE;
    }
    else {
        # relative
        $tmpMasterfile = "$cwd/$MASTERFILE";
    }
# Need to remove CR from masterfile, so let's make a local copy
    print "Making local copy of masterfile with no CRs.\n" if $DEBUG;
    my $ifh = new IO::File "<$tmpMasterfile"
        or die "Cannot read from masterfile '$tmpMasterfile': $!\n";
    my $ofh = new IO::File ">mf_noCr.all"
        or die "Cannot write to temp file 'mf_noCr.all': $!\n";  # in TMPDIR
    while (my $line = <$ifh>) {
        $line =~ s/\s+$/\n/;
        print $ofh $line;
    }
    $ofh->close();
    $ifh->close();

    #my $cmdflip = "$FLIPPATH -s ATG -m -l $MINLENGTHORF -g $GENCODE $tmpMasterfile > $TMPDIR/flip_$flag.output";
    my $cmdflip = "$FLIPPATH -m -l $MINLENGTHORF -g $GENCODE mf_noCr.all > $TMPDIR/flip_$flag.output";

    # -s start codon
    # -m With this switch, flip will translate the first codon of a protein by 'M' if the codon is a start codon
    # -l minimum length ORF
    # -g genetic codes

    my $resultat = system ("$cmdflip >/dev/null 2>/dev/null");

    print "$cmdflip\n" if $DEBUG;

    # Changing back to the original directory
    chdir($cwd);
} 


sub BlastFlipVSGene {    # it runs blast with the flip results against file containing genes 

    my $flag         = shift || "";    # something to recognize, what is the pepfile treated
    $BLASTOUTPUT     = $TMPDIR . "/blastoutput_$flag";
    my $file         = $PEPFILE;                                # undef should never happen in fact.
    my $escaped_file = $file;
    $escaped_file    =~ s#'#'\\'#g;         
    my $command      = "$FORMATDBPATH -p 'T' -t banque -i $escaped_file -n $TMPDIR/mf_$flag -l $TMPDIR/fdb_1.log >/dev/null 2>/dev/null";
    print "$command\n" if $DEBUG;
    my $resformatdb  = system($command);

    #RUN FOR BLAST : run blast with the db created and the flip results        
    my $cmdblast     = "$BLASTPATH -p blastp -d $TMPDIR/mf_$flag -i $TMPDIR/prot.lst -D $GENCODE -o $BLASTOUTPUT 2> $TMPDIR/blasterr_1.txt";
    print "$cmdblast\n" if $DEBUG;
    my $resblast = system ($cmdblast);
}

sub ParseInformationFromBlastResult {

    my $pirmaster   = shift;
    my $tag         = shift || "aVwXyZ";

    # This loop goes through the different fasta input files that
    # are currently defined in MfAnnotConfig.pir

    my $type        = 'PROT';
    my $file        = $PEPFILE;
    my $blastoutput = $BLASTOUTPUT;

    if (! -r $blastoutput) { # it's supposed to be here at this point.
        die "Error: can't find $type report from blastall ?!?\n";
    }
    my $searchio = new Bio::SearchIO (
                                       -format => 'blast',
                                       -file   => $blastoutput,
                                     );
    while (my $result = $searchio->next_result() ) {
    	my $num = $searchio->result_count;
        &FillFLIPBLASTPROTArrayFromBlastResult($pirmaster,$type,$result,$tag);
    }
}

sub FillFLIPBLASTPROTArrayFromBlastResult {
    my $pirmaster = shift; #    Pirmaster Object
    my $type      = shift; #    'DNA' or 'PROT'
    my $result    = shift; #    an object implementing Bio::SearchIO::Result::ResultI
    my $tag       = shift || "bVwXyZ";

    if (!$result) {return;}

    my $contigname = $result->query_name()        || "Unknown ID";
    $contigname =~ s/\;//g;                         # Delete false caracter            
    my $rdesc      = $result->query_description() || "Unknown Query Description";
    my $dbname     = $result->database_name()     || "Unknown DB name";
    my @hits       = $result->hits();               # Bio::Search::Hit::HitI        
    my $numhits    = scalar(@hits);                 # normally, only one! 
    return if $numhits < 1;

    # We have an hypothetical protein and we want to know if it'real
    my ($strand, $start, $end) = ($rdesc =~ /(orig|compl).\s+(\d+)\s+to\s+(\d+)\s+;\s+[\w\.\!]+/);
    my $arrow;

    if ($strand eq 'orig') {
        $arrow =  '==>';
    }
    else {
        $arrow =  '<==';
    }

    $strand                    = ($strand eq 'orig' ? 1 : -1);

    my $hit                    = $hits[0];    

    ###--------------------QUIT THE FUNCTION IF EVALUE IS TOO  WEAK-----------------------------#
    if ($hit->significance > $BLASTEVALUECUTOFF) { # If the e-value is not enough for these ORF you can
                                                   # It creates an Empty ORF 
        my $newemptyorf = new PirObject::EmptyOrf (
                                                    start  => $start,
                                                    end    => $end,
                                                    strand => $strand,
                                                    score  => $hit->significance,
                                                    contigname => $contigname,
                                                  );
        push (@$EMPTYORFS, $newemptyorf);          #  Put into the array, to be processed after   
        return;                                    #  Exit the function, because there is no significant ORF 
    }
    ###-----------------------------------------------------------------------------------------#

    ####  Now we have the start, we have the end, the strand
    ####  And we would like to know if more than one hit is allowed

    my @overlapping;

    HIT : foreach my $hit (@hits) {
              my $desc         = $hit->description();  # Get the description of the query sequence    
              my ($hypprotein) = ($desc =~ /\s*([\S]*)\s*;/); 
              next HIT if (not (defined ($hypprotein)) or $hypprotein eq "");
              my $score        = $hit->score();        # Get the blast score
              my $evalue       = $hit->significance(); # Get the e-value
              my @hsps         = $hit->hsps;           # High Scoring pairs : Bio::Search::HSP::BlastHSP

              return if ($evalue > $BLASTEVALUECUTOFF);

              my $prot = &TakeProteinFromPepfile ($desc, $PEPFILE);   # Take the protein corresponding to the hit

              if (scalar(@hsps) == 0) {
                  return; # An ORF that has a good evalue but no HSP => impossible but ...
              }

              #------- Calculate a sort of frame to see what's the region covered by this ORF
              #  Story : You can have, for some case, more than one protein per gen.
              #  It's a sort of fusion protein.
              #  Each of both have a functional part

              #-----------------------------------------------------------------------------#
              # To make distinction between a protein fusion and a protein annotated as twice
              # We have to check the High Scoring Pair frame. If there is no overllapping between 
              # HSP frames, it means you have many proteins on the same frame
              # If there is, it's probably because many similar proteins corresponds to the same gene

              my $frame           = {};
              my $framestart      = $hsps[0]->start;
              my $frameend        = $hsps[0]->end;

              #  We don't need to check for strand because HSP are sorted as if there were on the right strand
              foreach my $hsp (@hsps) {    
                  $framestart     = $hsp->start if ($hsp->start < $framestart);
                  $frameend       = $hsp->end   if ($hsp->end   > $frameend);
              }

              $frame -> {"start"} = $framestart;
              $frame -> {"end"}   = $frameend;

              my $isoverlapping = 0; #       Indiquate if wheter or not, accept the hit as annotation of the ORF 

              CURRENTFRAME : foreach my $currentframe (@overlapping) {
              ##################   FOR EACH STRAND THERE IS 4 CASES WHEN FRAME are OVerlapping

              # 1)     |----------------|             first frame
              #               |-----------------|     second frame

              # 2)            |----------------|      first frame
              #        |-----------------|            second frame

              # 2)          |---------|               first frame
              #        |-----------------|            second frame

              # 4)    |-----------------|             first frame
              #         |---------|                   second frame

              #       Case were we are on the right strand
        $isoverlapping = 1 if (($currentframe->{"start"} <=  $frame -> {"start"}) and ($currentframe->{"end"} >=  $frame -> {"start"}));
        $isoverlapping = 1 if (($frame -> {"start"} <=  $currentframe->{"start"}) and ($frame -> {"end"} >=  $currentframe->{"start"}));
        $isoverlapping = 1 if (($frame -> {"start"} <=  $currentframe->{"start"}) and ($currentframe -> {"end"} <=  $frame->{"end"})); 
        $isoverlapping = 1 if (($currentframe -> {"start"} <=  $frame->{"start"}) and ($frame -> {"end"} <=  $currentframe->{"end"}));  

                                 last CURRENTFRAME if $isoverlapping == 1; # Go out of the loop if there is a overlapping frame  
                             }

              next HIT if ($isoverlapping == 1); #  If there is an overlapping, the HIT isn't good for annotation
              push (@overlapping, $frame) if ($isoverlapping == 0);

              #----    Creating a new ORF object    ---
              my $neworf = new PirObject::Orf (
                                                start      => $start,
						startBlast => [],
                                                end        => $end,
                                                strand     => $strand,
                                                score      => $evalue,
                                                protein    => $prot, # assign the protein to the ORF 
                                                hsps       => []
                                              );

	      my @start_b;
	      my $refhsparray = $neworf->hsps;           #    An array reference,                          
              foreach my $hsp (@hsps) {
                  my $newhsp = new PirObject::Hsp_query_sbjct (
                                                    start_q  => $hsp->start('query'),
                                                    end_q    => $hsp->end('query'),
						    start_s => $hsp->start('sbjct'),
 						    end_s   => $hsp->end('sbjct'),
                                                    strand => $hsp->strand);
		push (@$refhsparray, $newhsp);

		if ($hsp->start('query') > $hsp->start('sbjct')) {
			my $start_cor = $start + ( ($hsp->start('query') *3) - ($hsp->start('sbjct') *3) ) if $strand == 1;
			   $start_cor = $start - ( ($hsp->start('query') *3) - ($hsp->start('sbjct') *3) ) if $strand != 1;
			push (@start_b, $start_cor);
			}		
              }

	      my $newstartblast = $neworf->startBlast;
	      my $start_bl = min(@start_b) if $strand == 1;
	         $start_bl = max(@start_b) if $strand == -1; 
	      push (@$newstartblast, $start_bl);

              my $newflipblastprot = GetFlipBlastProtByNAmeAndContigName ($hypprotein, $contigname);
              # Two case
              if (defined ($newflipblastprot)) {    #    Wether the prot is already defined
                  my $reforfarray = $newflipblastprot->orfs;
                  push (@$reforfarray, $neworf);    #    Annd we just add a new orf
              }
              else {
                  my $newflipblastprot = new PirObject::FlipBlastProt (
                                                                        name       => $hypprotein, # First we create the flipblast prot
                                                                        contigname => $contigname,
                                                                        orfs       => []
                                                                      );
                  my $reforfarray = $newflipblastprot->orfs;
                  push (@$reforfarray, $neworf);    #    Annd we just add a new orf
                  push (@$FLIPBLASTPROTS, $newflipblastprot);
              }    
              return if (! $MULTIORFS);                 #       Exit the function after the first hit if multi ORFS not allowed
          }
}

sub TakeProteinFromPepfile {  # this function takes a protein from the blast result with a descritpion line
                              # A kind of pareser of fasta file

    my $description = shift;
    my $pepfile     = shift;
    my $protein     = "";
    
    #print "search $pepfile $description\n";

    die "Impossible to read $pepfile" if (not (-f $PEPFILE));

    open (PEPFILE, "$PEPFILE") or die "Could not open $PEPFILE";

    # Parse the file, containing pep sequences
    my $parsebegin = 0;  

    $description =~ s/([^\w\s])/\\$1/g;
    $description =~ s/\s+/\\s+/g;

    while (my $line = <PEPFILE>) { #Treat each line
        chomp $line;
        next if ($line =~ /^\s*[;]/);  # don't parse line if it beginns with ; 
        if ($line =~ /$description/ and $line =~ /^\s*\>/ and $parsebegin == 0) {
            $protein .=  $line;
            $protein .= "\n";
            $parsebegin =1;  
            next;
        }

        if ($parsebegin ==1  and $line =~ /^\s*\>/) { # finish if meet an other protein
            last;
        }
        if ($parsebegin ==1) {    # Get the line.
            $protein .=  $line;
            $protein .= "\n";
        }    
    }
    
    die "Cannot find protein for $description in $PEPFILE\n" if $protein eq "";
    return $protein;
}

sub Select_protein								#This function is create in order to selection the protein for run Exonerate or not
{
         my $compt = 0;
	 my @index; 
	 foreach my $flipblastprot (@$FLIPBLASTPROTS) 
	 {
		 my $name       = $flipblastprot->name;
		 my $contigname = $flipblastprot->contigname;
		 my $orfs       = $flipblastprot->orfs;
		 my $number_orfs = scalar (@$orfs);
		 my %strand;									#hashtable with the number of each strand for one flipblastprot

		  if ($number_orfs < 1)
		  { 
			  next; # impossible but ..........
		  }
		  
		  if ($number_orfs > 1)
		  {
			  my @prot_score;							#tab for score of blast and protein
			  foreach my $orf(@$orfs) 
			  {
				$strand{1}++ if $orf->strand == 1;
				$strand{-1}++ if $orf->strand == -1;							
				my $info_prot_score = [$orf->score, $orf->protein];
				push (@prot_score, $info_prot_score);	   
			   }

			   @prot_score = sort { $a->[0] <=> $b->[0] } @prot_score;				#sort @protein_score by score
			   my $prot = $prot_score[0]->[1];							#protein who have bigger score

			   if ($strand{1} && $strand{-1}){
				#print "The gene coding for $name is probably transpliced\n";
		                my $info = [$name, $contigname, $prot, 2];
			        push(@PROT_FOR_EXONERATE, $info);
			        push(@index, $compt);
			   }

			   elsif ($strand{1} || $strand{-1}){
				my @start_end_orf;
				my $strand = 1 if $strand{1};
				$strand = -1 if $strand{-1};
				foreach my $orf(@$orfs){
				  my @start_hsp 	=();
				  my @end_hsp 		=();
				  my $hsps		= $orf->hsps;
				  foreach my $hsp(@$hsps){
				     push (@start_hsp, $hsp->start_q);
				     push (@end_hsp, $hsp->end_q);
				   }
				 my $min_start_hsp 	= min(@start_hsp);					#give the lower start of hsp
				 my $max_end_hsp	= max(@end_hsp);					#give the bigger end of hsp
				 my $cor_start 	= $orf->start + (3 * $min_start_hsp) if $strand == 1;		#the really start of orf if strand +
				 $cor_start	= $orf->start - (3 * $min_start_hsp) if $strand == -1;		#the really startof orf if strand -
				 my $cor_end   	= $orf->start + (3 * $max_end_hsp)   if $strand == 1;		#the really end of orf if strand +
				 $cor_end   	= $orf->start - (3 * $max_end_hsp)   if $strand == -1;		#the really endof orf if strand -
				 my $pair_start_end   = [ $cor_start, $cor_end ];
				 push (@start_end_orf, $pair_start_end);
				}

				@start_end_orf  = sort { $a->[0] <=> $b->[0] } @start_end_orf if $strand == 1;			#sort @start_end_orf by start for strand+
				@start_end_orf  = sort { $b->[0] <=> $a->[0] } @start_end_orf if $strand == -1;			#sort @start_end_orf by start for strand-

				for (my $i=0; $i < @start_end_orf - 1; $i++)
				{

				   my $diff = abs($start_end_orf[$i]->[1]-$start_end_orf[$i+1]->[0]);
				   #print "difference = $diff name = $name\n";
				   if ( 142 <= $diff )								#if distance between 2 orf who have match with one protein is higher than 142 nt => Run exonerate
				   {
				     my $info = [$name, $contigname, $prot, $strand];
				     push(@PROT_FOR_EXONERATE, $info);
				     push(@index, $compt);
				   }
				   else
				   	{
				     print "   The gene coding for $name present probably a frameshift\n"; 
					}
				}
			}
		  }
		  $compt++;
	 }

	 #In order to run exonerate only one time foreach protein
	 my %index_deja_vu = ();
	 my @index_uni; 
	 foreach my $index (@index) { 
	 push(@index_uni,$index) unless $index_deja_vu{$index}++; 
	 }

	 my %prot_deja_vu = (); 
	 my @prot_uni; 
	 foreach my $prot (@PROT_FOR_EXONERATE) {
             my $ident = $prot->[1] . "-" . $prot->[2];
	     push(@prot_uni,$prot) unless ($prot_deja_vu{$ident}++); 
	 }

	 @PROT_FOR_EXONERATE = @prot_uni; 

	 @index_uni = sort {$b <=> $a} @index_uni;

	 #In order to remove the protein of flipblastprot when we run Exonerate
	 for (my $i=0; $i < @index_uni; $i++){
		 splice(@$FLIPBLASTPROTS,$index_uni[$i],1);
	 }
}

sub FillHYPPROTSArrayWithFLIPBLASTPROTSArray {    #    This function fill the HYPPROTS array (array of hypothetical proteins with
                       				  #    FLIPBLASTPROTS array (array of ORF and hsp)

    #    This is mainly the algorithm given by Franz
    foreach my $flipblastprot (@$FLIPBLASTPROTS) {        #    For each fliup blast protein
        my $name       = $flipblastprot->name;
        my $contigname = $flipblastprot->contigname;

        my $orfs       = $flipblastprot->orfs;
        my $numberorfs = scalar (@$orfs);


        if ($numberorfs < 1) { 
            next; # impossible but ..........
        }

        else {  # if there is more than one orf
            my $neworfs = [];

            #---------------SORT THE ORF-------------------------#
            @$orfs = sort {        #    The ORFs are classified and sorted by starnd and start, stop positions
                         my $stranda = $a->strand;
                         my $strandb = $b->strand;
                         if ($stranda != $strandb) {
                             $a->strand <=> $b->strand;
                         }
                         elsif ($stranda == 1) {
                             $a->start  <=> $b->start;
                         }
                         else {
                             $a->end    <=> $b->end;
                         }    
            } @$orfs;    

            my $newhypprot = undef;

             foreach my $orf(@$orfs) {
                #    Now the thing is to create a new hyp prot if the conditions are not required
                #    First : if the $currentprot is not defined	

		my $start_cor;
		my $start_bl = $orf->startBlast;
		if (!(@$start_bl[0])){
		$start_cor = $orf->start;
		}
		else {
	     	$start_cor = @$start_bl[0];
		}

                #------------    case     1 : first ORF
                if (not defined($newhypprot)) {
                #    Here we create a new protein
                $newhypprot = new PirObject::HypProt (
                                                       name       => $name,
                                                       contigname => $contigname,
                                                       start      => $start_cor,
                                                       end        => $orf->end,
                                                       strand     => $orf->strand,
                                                       numorfs    => 1,
                                                       remark     => "",
                                                       protein    => $orf->protein,
                                                       score      => $orf->score, 
                                                       exons      => [],
                                                       introns    => [],
                                                     );

                    next; 
                }

                #------------    case     2 : not the same strand
                if ($newhypprot->strand !=  $orf->strand) {
                    push (@$HYPPROTS,  $newhypprot);
                    #+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                    $newhypprot = new PirObject::HypProt (
                                                           name       => $name,
                                                           contigname => $contigname,
                                                           start      => $start_cor,
                                                           end        => $orf->end,
                                                           strand     => $orf->strand,
                                                           numorfs    => 1,
                                                           remark     => "",
                                                           protein    => $orf->protein,
                                                           score      => $orf->score,  
                                                           exons      => [],
                                                           introns    => [],
                                                         );                 

                    next;
                }

                #------------    case     3-4 : Check space between 2 ORFs, including overlapping
                if ($orf->strand == 1) { # Two case : right strand or opposite strand
                    if (($newhypprot->end > $orf->start) or (abs ($orf->start - $newhypprot->end) < $MAXLENGTHFORGROUPINGORF)) {

                        my $newstart;
                        my $newend; 

                        if ($orf->start < $newhypprot->start) {
                            $newstart = $orf->start;
                        }
                        else {
                            $newstart = $newhypprot->start;
                        }

                        if ($orf->end   > $newhypprot->end) {
                            $newend   = $orf->end;
                        }
                        else {
                            $newend   = $newhypprot->end;
                        }

                        $newhypprot->set_start ($newstart);
                        $newhypprot->set_end ($newend);

                        # Check which protein is the best
                        if ($orf->score < $newhypprot->score) {
                            $newhypprot->set_protein ($orf->protein);
                            $newhypprot->set_score ($orf->score);
                        }

                        # increase from 1, the number of orf, if we concatenate
                        my $numorfs = $newhypprot->numorfs;
                        $numorfs++;
                        $newhypprot->set_numorfs($numorfs);
                        next;
                    }
                    else {
                                            #    ++    
                        push (@$HYPPROTS,  $newhypprot);            #    ++
                        #+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                        $newhypprot = new PirObject::HypProt (
                                                               name       => $name,
                                                               contigname => $contigname,
                                                               start      => $start_cor,
                                                               end        => $orf->end,
                                                               strand     => $orf->strand,
                                                               numorfs    => 1,
                                                               remark     => "",
                                                               protein    => $orf->protein,
                                                               score      => $orf->score, 
                                                               exons      => [],
                                                               introns    => [],
                                                             );         

                        next;    
                    }
                }    
                else {            #    Opposite strand
                    if (($newhypprot->start > $orf->end) or (abs ($orf->end - $newhypprot->start) < $MAXLENGTHFORGROUPINGORF)) {

                        my $newstart;
                        my $newend;

                        if ($orf->start > $newhypprot->start) {
                            $newstart = $orf->start;
                        }
                        else {
                            $newstart = $newhypprot->start;
                        }

                        if ($orf->end   < $newhypprot->end) {
                            $newend   = $orf->end;
                        }
                        else {
                            $newend   = $newhypprot->end;
                        }

                        $newhypprot->set_start ($newstart);
                        $newhypprot->set_end ($newend);

                        # Check which protein is the best
                        if ($orf->score < $newhypprot->score) {
                            $newhypprot->set_protein ($orf->protein);
                            $newhypprot->set_score ($orf->score);
                        }

                        # Add 1 to the number of orf if there is concatenation
                        my $numorfs = $newhypprot->numorfs;
                        $numorfs++;
                        $newhypprot->set_numorfs($numorfs);
                        next;
                    }
                    else {
                                                #    ++    
                        push (@$HYPPROTS,  $newhypprot);            #    ++
                        #+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                        $newhypprot = new PirObject::HypProt (
                                                               name       => $name,
                                                               contigname => $contigname,
                                                               start      => $start_cor,
                                                               end        => $orf->end,
                                                               strand     => $orf->strand,
                                                               numorfs    => 1,
                                                               remark     => "", 
                                                               protein    => $orf->protein,
                                                               score      => $orf->score, 
                                                               exons      => [],
                                                               introns    => [],
                                                             );
                        next;    
                    }
                }
            }  # end for each ORF
            push (@$HYPPROTS,  $newhypprot);
        } # end if there is more than one ORF
    } # End for each Flip Blast Prot
}    


sub GetFlipBlastProtByNAmeAndContigName {    
    #     this function gives a FlipBlastProt with his name and contig name
    my $name = shift;    #    This the name of the GetFlipBlastProt
    my $contigname = shift;    #    This is the contigname of the FlipBlastProt

    foreach my $result (@$FLIPBLASTPROTS) {
        if ($result->name eq $name and $result->contigname eq $contigname) {
            return $result;
        }
    }
    return undef; # in the case where any object has been found

}

sub Old_UseRNAweasel{
	#Description of the sub
	#1st : put the dna sequence into a temporary fastafile
	#2nd : run RNAweasel with the temporary fasta file  
	#3th : annotate with the output

   	 #1st : put the dna sequence into a temporary fastafile

  	  my $pirmaster   = shift;                    	 	# get the masterfile object
	  my $tag         = shift;        
	  my $contigs     = $pirmaster->get_contigs(); 		# get the masterfiles contigs
	  my $countcontig = 1;

      system("/bin/cp","$RNAweasel_training","$TMPDIR/tRNA.epn");

  	  foreach my $contig (@$contigs) {             	# parse all the contig
		  my $name    = $contig->get_name();       	# get the name for the contig
		  my $seq     = $contig->get_sequence();   	# get the sequence for each contig
		  $seq        =~ s/[^atcgATCGnN]//g;

	#2nd : run RNAweasel with the temporary fasta file

        my $fastatmp = "$TMPDIR/fasta.tmp";      			# temporary fasta file
        my $outputrnaweaseltmp = "$TMPDIR/RNAweasel.tmp";  		# RNAweasel output temporary file

        open (FASTATMP, ">$fastatmp") or die "can't open fasta tmp file\n"; 		# put into a temporary fasta file    
        print FASTATMP ">contig$countcontig\n$seq";   					#put the sequence into the temporary file with fasta format
        close FASTATMP; 								#close the temporary file    

        if (! -r "$fastatmp") {
            die "can't open fasta tmp file\n";
        }

	my $RNAweaselcmd = "$RNAWEASELPATH \"$TMPDIR/tRNA.epn\" $fastatmp $RNAweasel_parameter >/dev/null 2>/dev/null";
	print "$RNAweaselcmd\n" if $DEBUG;
	my $resRNAweasel = system ($RNAweaselcmd);

	print "   Processing contig '$name' ($countcontig/$numbercontigs) \n";

	my $dh = new IO::Dir "$TMPDIR" or die "Cannot opendir \"$TMPDIR\": !$\n";		#
	my @files = $dh->read();														#	Take the file
	$dh->close();																	#	which is use by
	@files = grep( m/\.fullalignment$/, @files);									#	RNAweaelparser
	die "Cannot find .fullalignment file from RNAweasel?!?\n" unless @files == 1;	#
	my $fullalign = $files[0];														#

	#3rd Parsing RNAweasel output
        my $parser  = new PirObject::RNAweaselparser();       					# Open the parser for RNAweasel
        $parser->loadObjectfromFile("$TMPDIR/$fullalign"); 					# Parse the file with the file and fill the object
        unlink("$TMPDIR/$fullalign");
        unlink("$TMPDIR/$fullalign.log");

	my @annotat = $parser->get_annotations;
    my $table   = $parser->get_annotations;              					#this is a reference to an array
        #my $cmp = 0;

	foreach my $result (@$table) { 								#Correspond to the tRNAweasel annotation 
        my $start;
        my $end;
	    my $strand;
	    my $ac_begin = $result->get_begin_ac;
	    $strand = $result->get_strand;
	    my $arrow;
	    my $fullseq = $contig->get_sequence();
	    #########################################
	    #	Allows the define the symbol of     #
	    #		the Amino acid		            #
	    #########################################
	    my $acodon	 = $result->get_anti_codon;
           $acodon   =~ tr/UTCGAutcga/AAGCTAAGCT/;
	       $acodon	 =~ s/(\w+)/reverse $1/ge;   
	    my $aaSymbol =  $CODE_GEN{$acodon};

	    #########################################
	    #	    Use to define the strand        #
	    #########################################
	   if ($strand eq "RC") {		
            $arrow = "<==";
			$start = $result->get_end;
			$end   = $result->get_begin - 1;
            }
       else {
            $arrow = "==>";
			$start = $result->get_begin;
			$end   = $result->get_end + 1;
            } 

	    if($aaSymbol eq "H")
	    {
		    $start =  &Histidine_Case($arrow, $seq, $result->get_begin, $result->end, $start)
	    }

	    # 4th ----- Create annotation -----#
            my $genename = "trn$aaSymbol"; # ."_"."$cmp";
            my $annot    = new PirObject::AnnotPair (
                                                  type      => "G", 
                                                  genename  => "$genename", # Before : genename  => "tRNA-$type($acodon)",
                                                  startpos  => $start,
                                                  endpos    => $end,
                                                  direction => $arrow,
                                                  );

	    #					$cmp++;
	    my $annot_ac    = new PirObject::AnnotPair (
                                                   type      => "AC", 
		                        	   genename  => "!anticodon!",
                                                   startpos  => $ac_begin, 
                                                   );

            my $arnname   = $genename;

	    $acodon = $result->get_anti_codon;
	    $acodon       =~ tr/UTCGAutcga/uucgauucga/;
            $arnname     .= "($acodon)";
            my $startline = ";     G-$arnname $arrow start";
            my $endline   = ";     G-$arnname $arrow end";
            $annot->set_startline ($startline);
            $annot->set_endline ($endline);
            &AddAnnotToPirMaster($pirmaster,$name,$annot);
	    &AddAnnotToPirMaster($pirmaster,$name,$annot_ac);
	}
        $countcontig ++;    
    } # each contig    
}

sub Annotate_Using_external_programs {
    my $pirmaster   = shift;
    my $conf_file   = PirObject::MfAnnotExternalProgs->ImportFromTextFile($EXTCONFIGFILE);
    my $genecomsets = $conf_file->get_geneprogs(); # this is a HASH genename => <MfAnnotGeneCommandSet>
   
    # Here we build a list of external programs to run; by default all
    # of them are executed, but this can be modified by the option --ext_select, which
    # we parse here.

    # Default: all of them
    my @allprogs      = map { split(/\s*,\s*/,$_) } keys %$genecomsets;
    my %allprogs      = map { lc($_) => 1  }        @allprogs;
    my %progs_to_run  = %allprogs; # copy, which will be adjusted
   
    # What do we have in --ext_select? Parse it
    my @ext_selected  = split(/\s*,\s*/, $EXTSELECTPROG);

    my @no_ext = grep(/^no/,@ext_selected);
    if (@no_ext) { # there are some 'no', which means ( ALL minus the 'no's )
        foreach my $noext (@no_ext) {
            $noext =~ s/^no//;
            delete $progs_to_run{lc $noext};
        }
    } elsif (@ext_selected) { # there are no 'nos', which means --ext_select is the full list
        %progs_to_run = map { lc($_) => 1 } @ext_selected;
    } # no else needed
   
    # Print warnings about unknown names in --ext_select
    foreach my $prog (sort keys %progs_to_run) {
        print "   Warning: no external programs specified for '$prog' in '$EXTCONFIGFILE'\n"
            unless $allprogs{lc $prog};
    }
   
    # Run each external program command set.
    my @extcomsets = sort {
        $genecomsets->{$a}->get_filerank() <=> $genecomsets->{$b}->get_filerank()
    } keys %$genecomsets; # now sorted; these are keys with possible MULTIPLE names, e.g. "rns,rnl"

    foreach my $comsetnames (@extcomsets) {
    foreach my $genename (split(/\s*,\s*/,$comsetnames)) {
        next if ! $progs_to_run{lc $genename};
        print "   Using external programs for '$genename'...\n";
        my $commandobject = $genecomsets->{$comsetnames};
        my $outfile_gene = "$TMPDIR/result_for_$genename.xml";
        my $substitutions = {
            "OUTFILE"        => "$outfile_gene",       # what will be created, a series of AnnotPairCollections
            "PLAINFASTAFILE" => "$TMPDIR/mf_noCr.all",
            "MASTERFILE"     => "$MASTERFILE",
            "DEBUG"          => $DEBUG ? "#" : "",     # see the config file text
            "GENENAME"       => $genename,             # optional; the Execute command use this but you can override it yourself)
            "TMPDIR"         => "$TMPDIR",             # mfannot's tmp dir
            "GENCODE"        => "$GENCODE",
            };

        $commandobject->set_debug($DEBUG);
        my ($outfile,$errfile) = $commandobject->Execute(
            "$TMPDIR",
            "$TMPDIR",
            $substitutions,
        );

        # Read back AnnotPairCollections;
        my $infh = new IO::File "<$outfile_gene"; # which should be your %OUTFILE%
        if (! $infh){ 
            print "Cannot read result for '$genename'; maybe there were problems with the commands?\n";
            print "See outfile '$outfile' and errfile '$errfile' for more info.\n" if $DEBUG;
            next;
        }

        # Process each AnnotPairCollection
        for (;;) {
            my $annotcollection = PirObject->FileHandleToObject($infh);
            last if ! $annotcollection;
            my $header           = $annotcollection->get_contigname();
            my ($contigname)   = ($header =~ m#^>?\s*(\S+)#)
                or die "Can't parse header line '$header'\n";
            # ANNOTATE THE RESULTS, using the annotpairlist field of
            # your annotcollection (an AnnotPairCollection object).
            my $annotpairs = $annotcollection->get_annotpairlist();
            foreach my $annot (@$annotpairs){
                my $type       = $annot->get_type()       || "G";
                my $a_genename = $annot->get_genename()   || $genename;
                my $startpos   = $annot->get_startpos()
                   || die "Can't find startpos() from annotpair obtained from external analysis?!? Object=\n" . $annot->ObjectToXML() . "\n";
                my $endpos     = $annot->get_endpos();
                   #|| die "Can't find endpos() from annotpair obtained from external analysis?!? Object=\n" . $annot->ObjectToXML() . "\n";

                my $arrow = "==";  # Woh.. that's not a legal masterfile arrow
                   $arrow = "$arrow>" if $startpos < $endpos;
                   $arrow = "<$arrow" if $startpos > $endpos;
                my $direction  = $annot->get_direction()  || $arrow;
                my $start_line = $annot->get_startline();
                   $start_line = "; G-$genename $arrow start" if !defined($start_line);
                my $end_line   = $annot->get_endline(); 
                   $end_line   = "; G-$genename $arrow end"   if !defined($end_line);
                my $gene = new PirObject::AnnotPair(
                                  type      => $type,
                                  genename  => $a_genename,
                                  startpos  => $startpos,
                                  endpos    => $endpos,
                                  direction => $direction,
                                  startline => $start_line,
                                  endline   => $end_line,
                );
                &AddAnnotToPirMaster($pirmaster,$contigname,$gene);
            } # foreach annotpair
        } # foreach annotpaircollection (one per contig)
        $infh->close();
    } # foreach genename1, genename2, ...
    } # foreach "genename1,genename2"
}

sub old_AddGeneFeatureUsingtRNAscanSE {

    #Description of the sub
    #1st : put the dna sequence into a temporary fastafile
    #2nd : run tRNAscanSE with the temporary fasta file  
    #3rd : parse the tRNAscanSE output
    #4th : annotate with the output

    #1st : put the dna sequence into a temporary fastafile

    my $pirmaster   = shift;                     	# get the masterfile object
    #my $contigs     = [];                        	# create a reference to a config file
    my $tag         = shift;        

    my $contigs        = $pirmaster->get_contigs(); 	# get the masterfiles contigs

    #my $contig      = undef;                     	# An array containing all the contig name
    my $countcontig = 1;

    foreach my $contig (@$contigs) {                	# parse all the contig
        my $name    = $contig->get_name();       	# get the name for the contig
        my $seq     = $contig->get_sequence();   	# get the sequence for each contig
        $seq        =~ s/[^atcgATCGnN]//g;

        #2nd : run tRNAscanSE with the temporary fasta file

        my $fastatmp = "$TMPDIR/fasta.tmp";      					# temporary fasta file
        my $outputtrnascansetmp = "$TMPDIR/tRNAnouvscanSEoutputamacr.tmp";  		# tRNAscanSE output temporary file

        open (FASTATMP, ">$fastatmp") or die "can't open fasta tmp file\n"; 		# put into a temporary fasta file    
        print FASTATMP ">contig$countcontig\n$seq";   					#put the sequence into the temporary file with fasta format
        close FASTATMP; 								#close the temporary file    

        if (! -r "$fastatmp") {
            die "can't open fasta tmp file\n";
        }

        my $tRNAscanSEcmd = "$TRNASCANPATH -O -o $outputtrnascansetmp $fastatmp  > $TMPDIR/tRNAscanSE.output 2>&1";
        print "$tRNAscanSEcmd\n" if $DEBUG;
        my $restRNAscanSE = system ($tRNAscanSEcmd);         				# -O for searching tRNA in organellar
                                                             				# -C for unsing coves
											# -o to write the result in a output file    

        #3rd Parsing tRNAscan output
        my $parser  = new PirObject::tRNAscanSEparser;       				# Open the parser for tRNAscanSE
        $parser->loadObjectfromFile("$outputtrnascansetmp"); 				# Parse the file with the file and fill the object

        my @annotat = $parser->get_annotations;
        my $table   = $parser->get_annotations;     				         #this is a reference to an array

        foreach my $result (@$table) { 							# Correspond to the tRNAscanSE annotation 
            my $start;
            my $end;
	    my $type   = $result->get_type;
            my $acodon = $result->get_anti_codon;
            my $score  = $result->get_score;

            my $arrow;
            if ($result->get_begin > $result->get_end) {
                $arrow = "<==";   
		$start = $result->get_begin;
                $end   = $result->get_end;
            }
            else {
                $arrow = "==>";
		$start = $result->get_begin;
                $end   = $result->get_end;
            }     

           if ($score < $TRNACUTOFF) { # if the score value is under the tRNA cutoff
                # go to the next tRNA
                next;
            }

            my %CodonTable = Bio::SeqUtils->valid_aa(2); # get the amino acide code
            my $aaSymbol   = uc(substr($type, 0, 1)).lc(substr($type, 1, 2)); # case treatment
            $aaSymbol      = $CodonTable{$type};         # change the amino acid in one to 3 letter

            if (!defined($CodonTable{$type})) {
                $aaSymbol  = $type;
            }
            else {
                $aaSymbol  = $CodonTable{$type};         # change the amino acid in one to 3 letter
            }

            # 4th ----- Create annotation -----#
            chomp ($aaSymbol) if (defined ($aaSymbol));
            my $genename = "trn$aaSymbol";

	    if($aaSymbol eq "H")
	    {
		    $start =  &Histidine_Case($arrow, $seq, $result->get_begin, $result->end, $start)
	    }

            my $annot    = new PirObject::AnnotPair (
                                                      type      => "G", 
                                                      genename  => "$genename", # Before : genename  => "tRNA-$type($acodon)",
                                                      startpos  => $start,
                                                      endpos    => $end,
                                                      direction => $arrow,
                                                    );

            my $arnname   = $genename;

            $acodon       =~ tr/UTCGAutcga/uucgauucga/;
            $arnname     .= "($acodon)";
            my $startline = ";     G-$arnname $arrow start";
            $startline   .= " ;; MFFEAT=$tag score=$score" if $ADDCOMMENTS;
            my $endline   = ";     G-$arnname $arrow end";
            $endline     .= " ;;MFFEAT=$tag" if $ADDCOMMENTS;
            $annot->set_startline ($startline);
            $annot->set_endline ($endline);
            &AddAnnotToPirMaster($pirmaster,$name,$annot);
        } # end of each trna

        $countcontig ++;    
    } # each contig    
}


##############################################################################
#        #	Allows the define of the beginning  #			     #	
#	 #	       and the end of the tRNA      #                        #
#adjust_histidine_trna                          	                     #
#                                                                            #
#adjusts the start of trnas with AC Histidine (H) 			     #	
#It searches for those trnas and gets the nuc upstream of the  		     #
#first nuc of the trna:                                                      #
#                                                                            #
#                - If the trna is on the forward strand and the nuc forms a  #
#                  base pair (A-T, T-A, G-C, C-G, G-T, T-G) with the last    #
#                  nuc of the trna, then the trna's start is decremented by  #
#                  1                                                         #
#                                                                            #
#                - If the trna is on the reverse strand and the complemented #
#                  nuc forms a base pair (A-T, T-A, G-C, C-G, G-T, T-G) with #
#                  the last nuc of the trna (complemented also), then the    #
#                  trna's start is incremented by 1 (which in fact enlarges  #
#                  the trna since it lies on the reverse strand)             #
##############################################################################

sub Histidine_Case {
    my $arrow = shift; 
    my $seq   = shift;
    my $begin = shift;
    my $end   = shift;
    my $start = shift;  
    my %compl = ( 'A' => ['T'], 'T' => ['A', 'G'], 'C' => ['G'], 'G' => ['C', 'T'] );
    my( $nuc1, $nuc2 );

    if ($arrow eq "==>")
    {            
    	if ($start == 1 )
	{
	    print "Cannot test histidine case, trna starts at 1";
	} # if ($aaSymbol eq "H" && $result->get_begin == 1)
	elsif ( $start != 1 )
	{
	    $nuc1 = uc substr( $seq, $begin - 2, 1 );
	    $nuc2 = uc substr( $seq, $end   - 1, 1 );
	    if( grep($nuc2, @{ $compl{$nuc1} } ) )
	    {
	       $start--;
	    } # if ( grep($nuc2, @{ $compl{$nuc1} } ) )
	} # elsif ($aaSymbol eq "H" && $result->get_begin != 1 )
    } # if ($arrow eq "==>")
    else {
	if ( $start == length($seq))
	{
	    print "Cannot test histidine case, trna ends at the last nucleotide of the contig";
	} # if ($aaSymbol eq "H" && $result->get_end == length($seq))
	elsif ( $start != length($seq))
	{
	    $nuc1 = uc substr( $seq, $begin , 1 );
	    $nuc2 = uc substr( $seq, $end   - 1, 1 );
	    $nuc1 =~ tr/ACGT/TGCA/;
	    $nuc2 =~ tr/ACGT/TGCA/;
	    if( grep($nuc2, @{ $compl{$nuc1} } ) )
	    {
		    $start++;
	    } # if( grep($nuc2, @{ $compl{$nuc1} } ) )
         } # elsif ($aaSymbol eq "H" && $result->get_end != length($seq))
     } # else 
    return $start;
}


sub AddAnnotToPirMaster {

    #### MEANING CODE FOR THIS FUNCTION
    #### return 1 means ok, it has been added
    #### return 0 means function quit before the end, => rediscovered 

    my $pirmaster   = shift;
    my $contigname  = shift;
    my $annot       = shift;
    my $contig      = $pirmaster->GetContigByName($contigname) or die "Can't get contig by name\n";
    my $annotations = $contig->get_annotations;


    # Here we compare all the annotations, with the one we try to add 
    foreach my $annotation (@$annotations) {
	my $annotname = $annotation->genename; 
        my $annottype = $annotation->type || "C";
        my $annotstart = $annotation->startpos;
        my $annotend = $annotation->endpos;
        $annotname = "comment" if (!defined  ($annotname));
        $annotstart = -1 if (!defined  ($annotstart));
        $annotend = -1 if (!defined  ($annotend));


        ##--First case : if both are same comment on the same line 
        if (($annottype eq "C") and ($annot->type eq "C") and
            ($annot->startpos == $annotstart) and
            ($annot->startline eq $annotation->startline)) {

            #Nothing is done in this case,
            return 0;
        }

        ##--Second case : No comment, both have same start end, and genename;
        if (($annottype ne "C") and ($annotname eq $annot->genename) and
            ($annotstart == $annot->startpos) and
            ($annotend == $annot->endpos)) {
            $ANNOT_STATS->{'Rediscovered'}->{$annot->genename} ||= {   'I' => 0, 'E' => 0, };
            return 0;
        }

        ##--Third case : Exons
        if ($annot->type eq "E") { # it's an exon. The protein has normally already been added
            if (defined ($annot->genename)) {
                $ANNOT_STATS->{'Added'}->{$annot->genename}->{'E'} ++;
            }
            push (@$annotations, $annot);
            return 1;
        }

        ##--4th case : Introns
        if ($annot->type eq "I") { # it's an intron. The protein has normally already been added
            if (defined ($annot->genename)) {
                $ANNOT_STATS->{'Added'}->{$annot->genename}->{'I'} ++;
            }
            push (@$annotations, $annot);
            return 1;
        } 
    }

    if ($FORCEANNOT) { # If Force annot, you can add a new one
        $ANNOT_STATS->{'Added'}->{$annot->genename} ||= {  'I' => 0, 'E' => 0, } if ($annot->genename ne "comment");
        push (@$annotations, $annot);
        return 1;
    }

    if ($annot->type eq "C") {
        push (@$annotations, $annot);
        return 1;
     }

         if (&AnnotAlreadyAtSamePlace($annotations, $annot->startpos, $annot->endpos, $annot->genename)) { 	 	#  It mean,, this annotation has already been seen
             $ANNOT_STATS->{'Rediscovered'}->{$annot->genename} ||= {  'I' => 0, 'E' => 0, } if ($annot->genename ne "comment");
             return 0;
	  }

      #  It means, force annot but this annotations doesn't seems to have an other copy

     $ANNOT_STATS->{'Added'}->{$annot->genename} ||= {  'I' => 0, 'E' => 0, } if ($annot->genename ne "comment");
     push (@$annotations, $annot);
     return 1;
}

sub AnnotAlreadyAtSamePlace {
	my $annotations = shift;
	my $start	= shift;
	my $end 	= shift;
	my $name	= shift;

	return if $name =~ /^!/;
	($start,$end) = ($end,$start) if $start > $end; 
	$name =~ s/_\d+$//;

	#A refaire ici 
	foreach my $annotation (@$annotations) {
		next if $annotation->type eq "C";
		next if $annotation->genename =~ /^!/;
		my $annot_name  = $annotation->genename;
		my $annot_start = $annotation->startpos;
		my $annot_end   = $annotation->endpos;
		$annot_name =~ s/_\d+$//;		
		($annot_start,$annot_end) = ($annot_end,$annot_start) if $annot_start > $annot_end; 


		if ( (!($end < $annot_start || $annot_end < $start)) && $name eq $annot_name){
		        return 1;
	        } 
        }
	return 0;
}

sub LogInfo 
{ 	      # this function is supposed to add information
              # in the head of the masterfile
              # such as
              #  - the genes added (with exons)
              #  - the rediscovered genes    

    my $pirmaster = shift;
    my $header    = $pirmaster->header() || [];

    my @report    = ();
    my $added     = $ANNOT_STATS->{'Added'};
    my $redisc    = $ANNOT_STATS->{'Rediscovered'};

    my @added     = sort keys %$added;
    my $comp_add  = 0;
    foreach my $genename (@added){ 
    $comp_add++ if ( $genename =~ /^!/);  
    }
    my @redisc    = sort keys %$redisc;
    my $comp_red  = 0;
    foreach my $genename (@redisc)
    { 
    $comp_red++ if ( $genename =~ /^!/);  
    }

    my $gene_add = scalar(@added) - $comp_add;
    my $red_add = scalar(@redisc) - $comp_red;

    push(@report, ";;    - Gene Totals: " . $gene_add  . " added; " . $red_add . " rediscovered.",);

    # ---------------- genes added -------------------------

    push(@report, ";;    - List of genes added:",) if @added;

    my $COLS      = 3;
    my $cnt       = 0;
    my $rep       = "";

    print "Added : ", $gene_add, "\n" if $DEBUG;
    print LOGFILE "Added : ", $gene_add, "\n" if $ISLOGFILE;

    foreach my $genename (@added) 
    {
	    if ($genename =~ /^[^!]/)
	    {
		    my($e,$i) = (($added->{$genename}->{'E'} || 0),($added->{$genename}->{'I'} || 0)); 
		    $rep      = ";;     " if !$cnt;
		    $rep     .= sprintf(" %-20s", ("$genename" . ($e > 1 ? " ($e exons)" : "")));
		    $cnt++;
		    if ($cnt >= $COLS) 
		    {
			    push(@report, $rep);
			    $cnt  = 0;
		    }
	    }
    }
    push(@report, $rep) if $cnt;

    # ---------------- genes rediscovered -------------------------

    push(@report, ";;    - List of genes rediscovered:",) if @redisc;

    $cnt = 0;
    $rep = "";
    print "Rediscovered : ", $red_add, "\n" if $DEBUG;
    print LOGFILE "Rediscovered : ", $red_add, "\n" if $ISLOGFILE;
    foreach my $genename (@redisc) 
    {
	if ($genename =~ /^[^!]/)
	{
        my ($e,$i) = ($redisc->{$genename}->{'E'},$redisc->{$genename}->{'I'});
        $rep       = ";;     " if !$cnt;
        $rep      .= sprintf(" %-20s", ("$genename" . ($e > 1 ? " ($e exons)" : "")));
        $cnt++;
        	if ($cnt >= $COLS) 
		{
			push(@report, $rep);
			$cnt = 0;
		}
	}
    }
    push(@report, $rep) if $cnt;

    push(@$header, ";; Masterfile modified automatically by $BASENAME version $VERSION");
    push (@$header, ";;    - New annotations labeled with: MFFEAT=$TAGNAME") 
        if $ADDCOMMENTS;  # we only put this sentence if option addcomments is activated
    push (@$header, @report, ";;",);
    push(@$header, $add_text_in_header) if $add_text_in_header ne "";
    $pirmaster->set_header($header);
}

sub CreateMap {   # A sub for creating map


    my $nameofmap = $OUTPUTFILE.".".$WITHMAP;

    # generate the xml file 
    my $xmlcmd         = "$MF2XMLPATH $OUTPUTFILE $TMPDIR/map.xml > $TMPDIR/mf2xmloutput 2> $TMPDIR/mf2xmlwarnings";
    print "$xmlcmd\n" if $DEBUG;
    print LOGFILE "$xmlcmd\n" if $ISLOGFILE;
    system $xmlcmd;

    # generate the map
    my $putinoptions;
    $putinoptions = " -f $WITHMAP ";
    $putinoptions .= " -E F " if ($WITHMAP eq "svg");
    my $mapcmd         = "$CGVIEWPATH -i $TMPDIR/map.xml $putinoptions -o $nameofmap  > $TMPDIR/cgviewoutput 2> $TMPDIR/cgviewwarnings";
    print "$mapcmd\n" if $DEBUG;
    print LOGFILE "$mapcmd\n" if $ISLOGFILE;
    system $mapcmd;    

    unlink ("$TMPDIR/map.xml");
    unlink ("$TMPDIR/mf2xmloutput");
    unlink ("$TMPDIR/mf2xmlwarnings");
    unlink ("$TMPDIR/cgviewoutput");
    unlink ("$TMPDIR/cgviewwarnings");

}

sub TestFile
{
  my $file = shift;
  if (!(-x $file)) {
      die "The file $file could not be found or was not executable. Please notify your administrator\n";
  }
}

sub WhatOverlapsThis {
    my $wstart     = shift;
    my $wend       = shift;
    my $contig     = shift;

    my $contiglen  = $contig->get_sequencelength();

    my $annotlist  = $contig->get_annotations() || [];
    
    ($wstart, $wend) = ($wend, $wstart) if $wend < $wstart;

    my @GEI_annots = grep( $_->get_type() =~ m#^[GEI]$# , @$annotlist);
    my %RanksGEI = ( G => 0, E => 1, I => 2 );
    @GEI_annots = sort
        { $a->get_genename() cmp $b->get_genename()
          or
          $RanksGEI{$a->get_type()} <=> $RanksGEI{$b->get_type()}
          or
          $a->get_startpos() <=> $b->get_startpos();
        }
        @GEI_annots;

    my $groups = [];
    foreach my $annotation (@GEI_annots) {
        my $genename  = $annotation->get_genename(); # does NOT contain the _1
        my $type      = $annotation->get_type();
        my $startline = $annotation->get_startline();
        my $start     = $annotation->get_startpos();
        my $end       = $annotation->get_endpos();
        my $dir       = $annotation->get_direction() || "==>";

        my ($ostart,$oend) = ($start,$end); # strandless interval
           ($ostart,$oend) = ($end,$start) if $end < $start;

        if ($type eq "G") {
            next unless # No overlap? next
                &OverlappingRegions($contiglen,$start,$end,$dir,$wstart,$wend,">"); # real dir of orf not important
            push(@$groups, [ [ $ostart, $oend, $annotation ] ] );
            next;
        }

        # For introns and exons
        foreach my $group (@$groups) {
            my $geneinfo = $group->[0]; # first entry of group is always a gene object
            my $gi_name  = $geneinfo->[2]->get_genename();
            next unless $gi_name eq $genename;
            my $gstart = $geneinfo->[2]->get_startpos();
            my $gend   = $geneinfo->[2]->get_endpos();
            my $gdir   = $geneinfo->[2]->get_direction();
            next unless # if E or I is outside of gene
                &OverlappingRegions($contiglen,$start,$end,$dir,$gstart,$gend,$gdir);
            push(@$group, [ $ostart, $oend, $annotation ] );
            #  last; # commented out in case for some reason an exon overlap multiple genes with the same names!
        }
    }

    # Now, flag the first and last exon of each group in field ->[3] of each group
    foreach my $group (@$groups) {
        $group->[0]->[3] = "";  # flag set to false for first entry
        if (@$group == 1) { # gene with no introns
            $group->[0]->[3] = "YES";
            next;
        }
        my $maxexnum=0;
        my $maxexinfo="";
        for (my $i=1;$i<@$group;$i++) {
            my $info = $group->[$i];
            $info->[3] = "";  # flag set to false
            next unless $info->[2]->get_type() eq "E";
            my $startline = $info->[2]->get_startline() || "";
            next unless $startline =~ m#G-(\S+)-E(\d+)#;
            my $exnum = $2;
            $info->[3] = "YES" if $exnum == 1; # first exon flaged
	    $info->[4] = "FIRST" if $exnum == 1; # first exon flaged
	    $info->[4] = "" if $exnum != 1; # first exon flaged
            if ($exnum > $maxexnum) {
                $maxexnum = $exnum;
                $maxexinfo = $info;
            }
        }
        if ($maxexinfo) { # should always be true here
            $maxexinfo->[3] = "YES"; # this is the last exon of the group
	    $maxexinfo->[4] = "LAST"; # this is the last exon of the group
        }
    }

    $groups;
}

sub IsInPhase {
    my $intronic_orf 	  = shift;
    my $annot_who_overlap = shift;
    
    my $strand_orf 	      = $intronic_orf->get_strand();
    my $start_orf 	      = $intronic_orf->get_start();
    my $phase_orf  	      = $intronic_orf->get_phase();
    my $num_intron	      = $intronic_orf->get_intron();
    my $length_add	      = 0;
    my $distance_inf_3	      = 0;
    
    foreach my $features_who_overlap (@$annot_who_overlap ){
	my $feature_type      	= $features_who_overlap->[2]->get_type();    
	my $feature_start     	= $features_who_overlap->[2]->get_startpos();
	my $feature_end       	= $features_who_overlap->[2]->get_endpos();
	my $feature_direction	= $features_who_overlap->[2]->get_direction();
	my $feature_startline 	= $features_who_overlap->[2]->get_startline();
	if ($feature_type eq "E"){
	    $feature_startline 	=~ m#G-(\S+)-E(\d+)#;
	    my $num_exon	= $2;
	    my $min_pos		= ($feature_direction eq "==>" ? $feature_start : $feature_end );
	    my $max_pos		= ($feature_direction eq "==>" ? $feature_end : $feature_start );
	    if ($num_exon == $num_intron){
		$distance_inf_3 = 1 if $feature_direction eq "==>" && $start_orf - $feature_end <= 3; 
		$distance_inf_3 = 1 if $feature_direction eq "<==" && $feature_end - $start_orf <= 3;
	    }
	    if ($num_exon <= $num_intron){
		my $length 		= $max_pos - $min_pos + 1;
		$length_add	+= $length;
	    } 
	}
    }
    	$length_add += $phase_orf;
	if ($length_add % 3 == 0 && $distance_inf_3 == 1){
	    return 1;
	}
}



# Post-processing: renumber gene names with unique
# extensions such as _1, _2 etc. The original mechanism
# that was trying to do this using %ANNOTSEEN is
# broken, this routine does a better job.
sub RenumberFeatures {
    my $pirmaster = shift;

    my %genename2suffix = (); # cox3 => { _1 => [ [ obj obj ] [ obj ] ], "" => [ [ obj obj ] [ obj ] ] }

    my $contigs = $pirmaster->get_contigs(); 	# get the masterfiles contigs
    foreach my $contig (@$contigs) {                	# parse all the contig
        my $contiglen = $contig->get_sequencelength();

        my $annotations = $contig->get_annotations();
        my @GEI_annots = grep( $_->get_type() =~ m#^[GEI]$# , @$annotations);
        my %RanksGEI = ( G => 0, E => 1, I => 2 );
        @GEI_annots = sort
            { $RanksGEI{$a->get_type()} <=> $RanksGEI{$b->get_type()}
                  or
              &IsIntronicOrf($a) <=> &IsIntronicOrf($b)
                  or
              $a->get_startpos() <=> $b->get_startpos();
            }
            @GEI_annots;

        foreach my $annotation (@GEI_annots) {

            my $genename  = $annotation->get_genename(); # does NOT contain the _1
            my $type      = $annotation->get_type();
            my $startline = $annotation->get_startline();
            my $start     = $annotation->get_startpos();
            my $end       = $annotation->get_endpos();
            my $dir       = $annotation->get_direction() || "==>";

            if ($startline =~ m#G-([^\-\s]+)#) { # we need to override for G-cox1_3-I4-orf34 for instance
                $genename  = $1; # we want cox1 not orf34
            }
            $genename =~ s/_\d+$//; # make sure

            my $suffix    = "";
            $suffix = $1 if $startline =~ m#(_\d+)#;

            my $suffix2groups = $genename2suffix{$genename} ||= {};
            my $groups        = $suffix2groups->{$suffix}   ||= [];
            my $addedToExistingGroup = 0;
            foreach my $group (@$groups) {
                my $firstfeat = $group->[0];
                my $ffstart = $firstfeat->get_startpos();
                my $ffend   = $firstfeat->get_endpos();
                my $ffdir   = $firstfeat->get_direction() || "==>";

                if (&OverlappingRegions($contiglen,$start,$end,$dir,$ffstart,$ffend,$ffdir)) {
                    push(@$group,$annotation);
                    $addedToExistingGroup=1;
                    last;
                }
            }
            if (!$addedToExistingGroup) {
                push(@$groups, [ $annotation ]);
            }

        } # foreach annotation

    } # foreach contig

    # At this point, we've regrouped all G, E and I features in
    # overlapping groups based on their EXISTING suffixes. Now
    # let's fix these suffixes.

    foreach my $genename (keys %genename2suffix) {
        my $suffix2groups = $genename2suffix{$genename};
        my @suffixes = sort keys %$suffix2groups; # "" , _1, _2 etc etc

        if (
            @suffixes == 1 &&            # only one type of suffix found
            $suffixes[0] eq "" &&        # case where only "genename" exists with no suffix
            @{$suffix2groups->{""}} == 1 # a single instance? All ok.
        ) {
#print "RENUMBER: $genename is unique with no suffix.\n";
            next;
        }

#print "RENUMBER: $genename has duplicates: [",join("][",@suffixes),"]\n";
        # ok, so we have a "" or _1 or _2 or _nn and/or a mix, we need to renumber
        my @keepnumbering=(); # we set aside those that need no renumbering; not used actually
        my @dorenumber=(); # these groups will be renumbered
        foreach my $suffix (@suffixes) {
            my $groups = $suffix2groups->{$suffix};
            if ($suffix eq "") {
                push(@dorenumber,@$groups); # all of them are renumbered
                next;
            }
            my $unchangedgroup = shift(@$groups); # only first group KEEPS its number
            push(@keepnumbering,$unchangedgroup);
            push(@dorenumber,@$groups); # these get new numbers
        }

        # Renumber all annots of each group (each group gets a single new number)
        for (my $i = 1; @dorenumber > 0 ; $i++) {
            my $newsuf = "_$i";
            next if $suffix2groups->{$newsuf}; # already used? try next suffix
            my $group = shift(@dorenumber);
            foreach my $annot (@$group) {
                my $origname  = $annot->get_genename();
                my $startline = $annot->get_startline();
                my $endline   = $annot->get_endline();
                my $type      = $annot->get_type();
                my $start     = $annot->get_startpos();
                my $end       = $annot->get_endpos();
                print "Warning: gene '$genename' ($start..$end) was renamed with suffix $newsuf to make it distinct.\n"
                    if $type eq "G" && $origname eq $genename; # no warn if "cox1_1-I1-orf344"
#print " -> To $newsuf : $startline ";
                $startline = &ReplaceNumber($startline,$newsuf);
#print " -> $startline\n";
                $endline   = &ReplaceNumber($endline,$newsuf);
                $annot->set_startline($startline);
                $annot->set_endline($endline);
            }
        }
    }
}

# Returns 1 if annotation line is like G-gene-Inn-orfblahblah
sub IsIntronicOrf {
    my $annot = shift;
    return 0 unless $annot->get_type() eq "G";
    my $startline = $annot->get_startline();
    return 1 if $startline =~ m#G-\S+-I\d+-\S+#;
    0;
}

sub OverlappingRegions { # Works even for circular genomes and regions that span the gap
    my ($seqlen,$start1,$end1,$dir1,$start2,$end2,$dir2) = @_;

    my $spansgap1 = (($dir1 =~ m#>#) xor ($start1 <= $end1)); # true means spans the gap
    my $spansgap2 = (($dir2 =~ m#>#) xor ($start2 <= $end2)); # true means spans the gap

    if ($spansgap1) {
        if ($dir1 =~ m#>#) {
            $end1 += $seqlen;
        } else {
            $start1 += $seqlen;
        }
    }

    if ($spansgap2) {
        if ($dir2 =~ m#>#) {
            $end2 += $seqlen;
        } else {
            $start2 += $seqlen;
        }
    }

    ($start1,$end1) = ($end1,$start1) if $start1 > $end1;
    ($start2,$end2) = ($end2,$start2) if $start2 > $end2;

    # Test for overlap
    return 1 if ! ($end1 < $start2 || $start1 > $end2);

    return 0 if $spansgap1 == $spansgap2; # same spanning sit -> we're done

    if (! $spansgap1) {
        $start1 += $seqlen;
        $end1   += $seqlen;
    }

    if (! $spansgap2) {
        $start2 += $seqlen;
        $end2   += $seqlen;
    }

    # Test for overlap again, new situation
    return 1 if ! ($end1 < $start2 || $start1 > $end2);

    return 0; # really, no overlap
}

# Substitutes, in a G- annotation line, the numbered suffix _1 _2 etc (which
# might not even be there) bu a new suffix ($newsuf).
sub ReplaceNumber {
    my $line   = shift;
    my $newsuf = shift;
    $line =~ s/(G-[^_\s]+)_\d+/$1/; # remove existing _1
    if ($line =~ m#G-\S+-[EI]\d+#) { # exon or intron ?
        $line =~ s/(-[EI]\d+)/$newsuf$1/;
    } else {
        $line =~ s/(G-\S+)/$1$newsuf/;
    }
    $line;
}

END { # With exit, programme will go here
      # Cleanup temp directory when program exits.

    return unless defined($TMPDIR) and $TMPDIR =~ m#^/tmp/#;

    print "Temporary work directory $TMPDIR NOT cleaned up ...\n" if $DEBUG; 
    #system("/bin/rm","-rf",$TMPDIR) if -d $TMPDIR && !$DEBUG;
    rmtree($TMPDIR) unless $DEBUG;
}

# End Of File. Or is it? What's beyond? Maybe the lost characters of all the sentences that were trunca
