#!/usr/bin/perl -w -- -*-Perl-*-

##############################################################################
#
#                                 mfannot.pl
#
# DESCRIPTION:
# Attempts to do a quick first pass at annotating a masterfile
# with meaningfull start/stop lines by calling blast on collections
# of known genes. Manual intervention is still required to check/adjust
# the new annotations.
#
# Known issues: - Annotations for START/STOP introns are interleaved (they
#                 are at the correct position, though).
#
##############################################################################

##############################################################################
#                                                                            #
#                       CONFIDENTIAL & PROPRIETARY                           #
#       Nothing herein is to be disclosed in any way without the prior       #
#           express written permission of Pierre Rioux                       #
#                                                                            #
#          Copyright 2004 Pierre Rioux, All rights reserved.                 #
#                                                                            #
##############################################################################
#
#    $Id: mfannot,v 1.24 2005/06/29 18:55:39 thomash Exp $
#
#    $Log: mfannot,v $
#    Revision 1.24  2005/06/29 18:55:39  thomash
#    bugs with trna scan solved
#    (Contig name)
#
#    Revision 1.21  2005/06/15 15:59:54  thomash
#    ORF size corrected
#
#    Revision 1.20  2005/06/13 21:04:54  thomash
#    - orf size changed : nucleotides => amino acids
#    - grouping of exons
#    - add a number for each gene (if the number of copies is more than
#    - 1)),
#      to the normal genes and trna genes
#    - change exons : comments => real annotations
#    - Exon problems corrected
#
#    Revision 1.19  2005/05/20 21:56:28  thomash
#    Contains, orf modifications.
#    Now, overlapping is calculated on the both strands
#
#    Revision 1.17  2005/05/11 21:22:43  thomash
#    The multiples annotations for a same frame function has been improved
#    Before, all the significant annotation were taken for the same ORF.
#    It could have a sense if a protein contains two functionnal domains
#    derived from 2 different protein.
#    The most of the time, an ORF having more than one annotation,
#    comes when two similar proteins correspond to the annotation
#    In this case we just want one annotation.
#    This has been done (but not tested one real fusion protein)
#    And work on proteins present in masterfiles used
#
#    Revision 1.14  2005/05/09 15:00:30  thomash
#    Problems fixed (Exons problems)
#
#    Revision 1.13  2005/05/05 19:41:33  thomash
#    mfannot modified in order to have more than one annotation
#    per ORF;
#    if option -m is in line command it will active the multi
#    annotation per ORF option
#
#    Revision 1.12  2005/05/05 16:00:06  thomash
#    Disallow, 2 annotations for the same gene, by default
#    Allows 2 annotations if option -f.
#    Give, too non coresponding ORF (it means, with no
#    corresponding gene after running blast) with a
#    specific cutoff size
#
#    Revision 1.10  2005/04/28 19:10:55  thomash
#    Comment added,
#    Options problemes fixed by allowing
#    setting parameters
#    This mfannot version runs with the new
#    MAsterfile.pir object that allows the user
#    to load annotation from a Masterfile
#    having the same name
#
#    Revision 1.8  2005/04/13 20:06:07  thomash
#    New Version of Mfannot
#    Input : A masterfile (-m) and a peplibrary (-p)
#    First step : Give the pepfile from the peplibrary corresponding to
#    the closest Organism.
#    Second step : Doing annotation of the Masterfile with the pepfile
#    Annotation is made with translation (in the 6 frames) of the
#    Masterfile
#    and blasting the results with the pepfile.
#
#    Revision 1.6  2005/03/16 14:52:49  dto
#    Added correct location of perl
#
#    Revision 1.5  2005/03/15 20:36:22  thomash
#    Add tRNAscanSE for prediction
#
#    Revision 1.4  2005/03/04 20:47:29  dto
#    New version provided by Pierre
#    Modified by Hoellinger T. 2005/03/14
#
#

##########################
# Initialization section #
##########################

require 5.00;
use strict;
use vars qw( $VERSION $RCS_VERSION );
use IO::File;                             
use PirObject;                                        #  Pir module treatment 
use Bio::SearchIO;                                    #  Bioperl (used for parsing blast outout)
use Bio::SeqUtils;                          
   

#---General Objects
PirObject->LoadDataModel("Masterfile");               #  Masterfile object
PirObject->LoadDataModel("MfAnnotConfig");            #  Configuration object
PirObject->LoadDataModel("tRNAscanSEparser");         #  Parser for tRNAscanSE output

#---Objects for annotation 
PirObject->LoadDataModel("FlipBlastProt");            #  Objects for storing ORFs predicted by Flip and kept with blast
PirObject->LoadDataModel("Orf");                      #  ORF (belong to FlipBlastProt)
PirObject->LoadDataModel("Hsp");                      #  High Scoring Pair (belong to Orf)
PirObject->LoadDataModel("HypProt");                  #  Hypothetical protein : We believe its a protein after flip, blast an
                                                      #  Organization of the results     
PirObject->LoadDataModel("Exon");                     #  Exons : belongs to Hypothetical proteins
PirObject->LoadDataModel("Option");                   #  A module for options gestion

PirObject->LoadDataModel("EmptyOrf");                 #  Object containing Orfs having no corresponding genes




# Default umask
umask 027;

# Program's name and version number.
$RCS_VERSION='$Id: mfannot,v 1.24 2005/06/29 18:55:39 thomash Exp $';
($VERSION) = ($RCS_VERSION =~ m#,v ([\w\.]+)#);
my ($BASENAME) = ($0 =~ /([^\/]+)$/);

# Get login name.
my $USER=getpwuid($<) || getlogin || die "Can't find USER from environment!\n";

##################################
# Global variables and constants #
##################################

# Command-line args

#--No more used
my $AUTOMATIC=0;
my $TAGNAME=undef;                              #  Tag : is presnt in masterfile within the annotations made with Mfannot
my $FORCEANNOT=0;
my $HOMECONFIGFILE = ($ENV{"HOME"} || ".") . "/.mfannotconfig.xml";
my $BLASTALL_DNA_OPTIONS  = "-e 1.0e-15" .      #  e-value
                            "";
my $BLASTALL_PROT_OPTIONS = "-e 1.0e-15" .      #  e-value
                            "";
my $ANNOT_STATS = {
    'Added'        => {},                       #  It means, never see it before
    'Rediscovered' => {},                       #  Means exist at the same place (not added into the file)
};
my $EMPTYORFS = [];                             #  An array containing, EmptyOrf object. It means ORFs having
                                                #  no corresponding genes
my $ANNOTSEEN = {};                             #  An array storing annotations that have been seen before
my $FIRSTTIME = 1;                              #  A global variable for annotation process (used in AddAnnotFrompirmaster)	
my %GENENAMEOCCURENCE;                          #  An hash array, defined only if the gene has been discovered

	


#--General options
my $DEBUG;                                      #  Debug mode. If true, display message on the screen
my $GENCODE=undef;                              #  Genetique code
my $TMPDIR = "/tmp/mfannot.$$";                 #  Temporary directory
my $LOGFILE;                                    #  log file : store all the information about run
my $SIMILARITYSEARCH;                           #  Usefull for running similaritie gene process for annot.
my $ISLOGFILE=0;                                #  Just to know if the $LOGFILE is not empty (0 or 1)
my $PEPLIBRARY;                                 #  Path for peplibrary directory
my $MASTERFILE;                                 #  Path for Masterfile
my $PEPFILE;                                    #  Path for the peptide file used
my $TAKEINPUTFILE;
my $FLIPBLASTPROTS = [];                        #  Array containing the Proteins predicted by Blast and Flip
my $HYPPROTS = [];                              #  Array containing the Proteins predicted by Blast and Flip and reprocessed after
my $OUTPUTFILE;                                 #  Path for the new
my $USETRNASCANSE;                              #  T or F : use of tRNAscanSE in the annotation 
my $MULTIORFS;                                  #  0 or 1 allows many gene annotations for 1 ORF 
my $NEWRCFILE;                                  #  0 or 1 : print if a new rcfile is generated
my $NORCFILE;                                   #  0 or 1, if a rcfile has been used for loading data
my $RCFILE;                                     #  The rcfile used for loading options
my $ORFPROCESS;                                 #  Allows ORF appearing in the masterfile as annotations
my $LOADSTRICT;                                 #  Load strict Masterfile
my $ADDCOMMENTS;                                #  Add comments into masterfile (0 or 1) as mfeat=.....
my $ALLEXONS;                                   #  All exons are displayed in the masterfile
my $CHECKORFS;                                  #  Say if yes or not have to check for orf, if no all orfs appears in mf                                   

#--Specific for finding the closest organism
my $BLASTOUTFORFINDINGCLOSESTORGANISM;          #  The blast output used to find closest organism 
my $MINLENGTHORFFORFINDINGCLOSESTORGANISM;      #  Minimum ORF size generated with flip
my $BLASTEVALUECUTOFFFORFINDINGCLOSESTORGANISM; #  Minimum blast e-value thresold
$BLASTOUTFORFINDINGCLOSESTORGANISM =  $TMPDIR . "/blastout1";


#--Specific for the annotation (parameters for flip, blastall and organization)
my $BLASTOUTPUT                   ;             #  The path for blast file results	
my $BLASTEVALUECUTOFF;	          		#  Cutoff value for the blast
my $MINLENGTHORF;				#  This is the minimum length for creating an ORF with flip
my $MAXLENGTHFORGROUPINGORF;     		#  Minimum size of a gap between 2 ORf. If 2 same ORF
$BLASTOUTPUT = $TMPDIR . "/blastout2";          #  Blastreport 
my $MINLENEMPTYORF;                             #  Minimum length for ORF empty orfs (non corresponding orfs)
my $OVERLAPPINGCUTOFF;                          #  Overlapping cutoff for ORFs 
my $TRNACUTOFF;                                 #  The cutoff for the tRNAs annotation


#############################
# Environment Verifications #
#############################
# Added by David To 11th February 2005
$ENV{"BLASTMAT"} = "/share/supported/apps/ncbi/data";

die "Please make sure the BLASTMAT environment variable is set\n" .
    "to point to a directory where the blast matrices are stored.\n"
    unless defined($ENV{"BLASTMAT"}) && (-d $ENV{"BLASTMAT"}) &&
           (-f ($ENV{"BLASTMAT"} . "/PAM30"));

die "Please make sure that the 'blastall' executable is in your\n" .
    "current command search path.\n"
    unless grep(-x ($_ . "/blastall"),split(/:/,$ENV{"PATH"})) > 0;
    
    
    ############  THINGS TO PUT IN VERIFICATION ########
     #      - Check if tRNAscanSE is installed
     #      - Check if flip is installed
     #      - Check if formatdb is installed
     


##################
# HELP AND USAGE #
##################

sub GoOut {
	print "----------------\n";
	#&Usage;
	exit 0;

}

sub Help {

print "Help for mfannot.pl\n";
print "-------------------\n";
#&Usage;

}


################
# Trap Signals #
################

sub SigCleanup { # private
     die "\nExiting: received signal \"" . $_[0] . "\".\n";
     # Note that some cleanup will be performed in the END block at this point.
}
$SIG{'INT'}  = \&SigCleanup;
$SIG{'TERM'} = \&SigCleanup;
$SIG{'HUP'}  = \&SigCleanup;
$SIG{'QUIT'} = \&SigCleanup;
$SIG{'PIPE'} = \&SigCleanup;
$SIG{'ALRM'} = \&SigCleanup;

###############################
#   M A I N   P R O G R A M   #
###############################

#####################################################
# Command-Line Arguments Processing and verification#
#####################################################

##------------------------------------------------##
&GetOptions ;

open (LOGFILE, ">$LOGFILE") if $ISLOGFILE;


my $header = "\n".
             "######################################################################\n".
             "MFANNOT, ORGANELLAR GENOME ANNOTATION PROGRAMM                        \n".
             "VERSION $VERSION                                                      \n".
	     "Programmed by david To, Thomas Hoellinger, Pierre Rioux and Franz Lang\n".
	     "######################################################################\n\n";
	     
print $header if $DEBUG;
print LOGFILE $header if $ISLOGFILE;


##--OPTIONS OF THE PROGRAM
my $options ="----------------------------------\n".
             "        General Options	        \n".
             "----------------------------------\n";
	    
if ($NORCFILE) {
    $options .= "No rcfile used for options\n";
}
else {
    $options .= "$RCFILE used for loading options\n";
}
$options .= "Masterfile used : $MASTERFILE\n";
$options .= "new Masterfile created : $OUTPUTFILE\n";
$options .= "Genetic code : $GENCODE\n";
$options .= "Tag for annotation : $TAGNAME\n" if $ADDCOMMENTS;
$options .= "New rcfile generated in .mfannotrc\n" if $NEWRCFILE;
$options .= "Add comments in Masterfile\n" if $ADDCOMMENTS;

if ($SIMILARITYSEARCH) {
  if ($TAKEINPUTFILE == 0) {
    $options .= "Look in the peptide library $PEPLIBRARY\n";	     
  }
  else {
    $options .= "Peptide file : $PEPFILE\n";
  }
}
else {
   $options .=  "Any search in gene similarity for annotation\n";
}

if ($USETRNASCANSE == 0) {
  $options .= "No usage of tRNAscanSE\n";
}
else {
  $options .= "Usage of tRNAscanSE\n";
}

print LOGFILE $options if $ISLOGFILE;           #Print options in the logfile
print $options if $DEBUG;                       #Print the options on the screen 

  
mkdir($TMPDIR,0700) || die "Error: can't create work directory '$TMPDIR': $!\n";

if ($TAKEINPUTFILE == 0 && $SIMILARITYSEARCH) {  
  print "----------------------------------\n",  # First print : debug
        "  Look For The Closest Organism   \n",
        "----------------------------------\n" if $DEBUG;
  print LOGFILE "----------------------------------\n",  # First print : debug
                "  Look For The Closest Organism   \n",
                "----------------------------------\n" if $ISLOGFILE;
  my $optionsforlooking;                         # options, 
  $optionsforlooking = "Minimum size ORF, for flip running : $MINLENGTHORFFORFINDINGCLOSESTORGANISM\n";
  $optionsforlooking .= "Blast e-value cutoff : $BLASTEVALUECUTOFFFORFINDINGCLOSESTORGANISM\n";
  print "options :\n$optionsforlooking" if $DEBUG;
  print LOGFILE "options :\n$optionsforlooking" if $ISLOGFILE;
  $PEPFILE = &FindClosestOrganism;               # Look for the closest Organism
  if (not defined ($PEPFILE)) {
    die "Peptide file not found in pep directory\n";
  }
  $PEPFILE = $PEPLIBRARY. "/" . $PEPFILE;
  print "The closest Organism is : $PEPFILE\n" if $DEBUG;
  print LOGFILE "The closest Organism is : $PEPFILE\n" if $ISLOGFILE;
}

if ((not -r  $PEPFILE) && $SIMILARITYSEARCH) {
  die "Unable to read $PEPFILE\n";
}

print "----------------------------------\n",
      "           Annotation             \n",
      "----------------------------------\n" if $DEBUG;
print LOGFILE "----------------------------------\n",
              "           Annotation             \n",
              "----------------------------------\n" if $ISLOGFILE;

if ($SIMILARITYSEARCH) {
  $options = "Options : \n";                  # Options & parameters used for the blast
  $options .= "Minimum size ORF, for flip running $MINLENGTHORF\n";
  $options .= "Blast e-value cutoff : $BLASTEVALUECUTOFF\n";
  $options .= "Maximum intron size : $MAXLENGTHFORGROUPINGORF\n";
  $options .= "Minimum length for non corresponding ORFs : $MINLENEMPTYORF\n";
  $options .= "Overlapping cutoff for non corresponding ORFs: $OVERLAPPINGCUTOFF\n";
  $options .= "trna cutoff : $TRNACUTOFF\n" if ($USETRNASCANSE);
  
  print $options if $DEBUG;
  print LOGFILE $options if $ISLOGFILE;
}

my $step=1;
print "$step) Parsing masterfile...\n" if $DEBUG;
$step += 1; 
my $pirmaster = PirObject::Masterfile->ObjectFromMasterfile($MASTERFILE, $LOADSTRICT);
my $contigs = $pirmaster->get_contigs();
my $numbercontigs = 0;                              # Number of contigs in the masterfile
my $numberannot = 0;                                # Number of annotations detected in the program

$numbercontigs += scalar (@$contigs);
foreach my $contig ( @$contigs) {
    my $annotations = $contig-> get_annotations();
    $numberannot += scalar (@$annotations);
    #foreach my $annot ( @$annotations) {
    #    print "annot : ";
    #	print  "name ", $annot->get_genename, " ", if defined($annot->get_genename);
    #	print  "start ", $annot->get_startpos, " ", if defined($annot->get_startpos);
    #	print  "end ", $annot->get_endpos, if defined($annot->get_endpos);
    #    print "\n";
    #}
}

print "Number of contigs in Masterfile : $numbercontigs\n",
      "Number of annotations (or comments) detected : $numberannot\n" if $DEBUG;

print LOGFILE "Number of contigs in Masterfile : $numbercontigs\n",
              "Number of annotations (or comments) detected : $numberannot\n" if $ISLOGFILE;
      
&InitializeANNOTSEEN ($pirmaster);   # Initialise the work variables, to know how many copies per genes, there is
	            	      
if ($SIMILARITYSEARCH) {
                                 
  # Run the programm step by, to know the right step            
  print "$step) Run Flip...\n" if $DEBUG;
  $step += 1; 
  &RunFlip;

  print "$step) Run Blast...\n" if $DEBUG;
  $step += 1;  
  &BlastFlipVSGene;

  print "$step) Parse Information From Blast Results...\n" if $DEBUG;
  $step += 1;
  &ParseInformationFromBlastResult ($pirmaster, $TAGNAME);
  
  # Just print 
  #foreach (@$FLIPBLASTPROTS){
  #    print "Protein name : ", $_->name, "\n";
  #    my $orfs = $_->orfs;
  #    foreach my $orf (@$orfs) {
  #       print "orf start ", $orf->start, " end ", $orf->end, " strand ", $orf->strand, "\n";
  #    
  #    }
  #
  #}
  
  print "$step) Fill Hyp prot Array With FLIPBLASTPROTSArray...\n" if $DEBUG;
  $step += 1; 
  &FillHYPPROTSArrayWithFLIPBLASTPROTSArray;

  print "$step) Organise Prot Array...\n" if $DEBUG; 
  $step += 1; 
  &OrganiseHYPPROTSArray ($pirmaster);

  print "$step) Annotate from Hyp Prots Array...\n" if $DEBUG;
  $step += 1; 
  &AnnotateMfFromHYPPROTSArray ($pirmaster);
  
  if ($ORFPROCESS) {
      print "$step) Process Empty ORFs...\n" if $DEBUG; 
      $step += 1; 
      &AnnotateEmptyOrfs ($pirmaster);
  }
}
  
if ($USETRNASCANSE) {
    print "$step) Annotate with tRNAscanSE...\n" if $DEBUG;
    $step += 1; 
    &AddGeneFeatureUsingtRNAscanSE ($pirmaster, "trnascanSE");
}    
    
print "----------------------------------\n",
      "       End of the Programm        \n",
      "----------------------------------\n" if $DEBUG;  
  
      
my $cntigs = $pirmaster->contigs();
my $annotations = $cntigs->[0]->annotations();

     
      
#system ("rm $TMPDIR -f -r") || print "problem for cleaning; 


&LogInfo ($pirmaster);
print "Dumping new masterfile in $OUTPUTFILE...\n" if  $DEBUG;
$pirmaster->ObjectToMasterfile("$OUTPUTFILE");

 

if ($ISLOGFILE == 1) {
        print "close Logfile : $LOGFILE\n" if $DEBUG;
	close LOGFILE || print "Logfile not closed\n";
}
exit 0;

#############################
#   S U B R O U T I N E S   #
#############################

##############################
# Parse command-line options #
##############################

sub GetOptions {          # this function is here to manipulate options

    my $option = new PirObject::Option ();   #  buil a new option model
    $option->FillOption ();                  #  This one buil with the default option and look for a rc file
    
    ### Now The object contains all the options
    
    
    #--General options
    $DEBUG = $option->debug;                     #  Debug mode. If true, display message on the screen
    $GENCODE = $option->genetic;                 #  Genetique code
    $LOGFILE = $option->logfile;                 #  log file : store all the information about run
    $SIMILARITYSEARCH = $option->similarity;     #  Usefull for running similaritie gene process for annot.
    $ISLOGFILE= $option->islogfile;              #  Just to know if the $LOGFILE is not empty (0 or 1)
    $PEPLIBRARY = $option->pepdirectory;         #  Path for peplibrary directory
    $MASTERFILE = $option->masterfile;           #  Path for Masterfile
    $PEPFILE = $option->inputfile;               #  Path for the peptide file used
    $OUTPUTFILE = $option->outputfile;           #  Path for the new
    $USETRNASCANSE = $option->tRNAscanSE;        #  T or F : use of tRNAscanSE in the annotation 
    $TAKEINPUTFILE = $option->takeinputfile;     #  A boolean saying if programme is taking an input file
    $TAGNAME = $option->tagname;                 #  Adds a tag  
    $FORCEANNOT = $option->force;                #  Force the annotation when 2 annotations have the same name
    $MULTIORFS = $option->multiorfs;             #  Permit 2 annotations for an ORF
    $NEWRCFILE = $option->newrcfile;             #  Just used to be printed. Indiquates that a new rcfile will be created
    $NORCFILE = $option->norcfile;               #  0 or 1, if a rcfile has been used for loading data
    $RCFILE = $option->rcfile;                   #  The rcfile used for loading options
    $ORFPROCESS = $option->orf;                  #  For Orf process, allowing presence or not in the masterfile
    $LOADSTRICT = $option->loadstrict;           #  Load strict masterfile
    $ADDCOMMENTS = $option->addcomments;         #  Add comments in the masterfile
    $ALLEXONS = $option->allexons;               #  diplay all exons in the masterfile
    my $allorfs = $option->allorfs;              #  All orfs will apear and won't be checked if option is checked
    $CHECKORFS = 0 if ($allorfs == 1);           #  A little calculation 
    $CHECKORFS = 1 if ($allorfs == 0);           #  to find the opposite
    
    
    #--Specific for finding the closest organism
    $MINLENGTHORFFORFINDINGCLOSESTORGANISM = $option->flip1;       #  Minimum ORF size generated with flip
    $BLASTEVALUECUTOFFFORFINDINGCLOSESTORGANISM = $option->blast1; #  Minimum blast e-value thresold
   

    #--Specific for the annotation (parameters for flip, blastall and organization)	
    $BLASTEVALUECUTOFF = $option->blast2;                                  #  Cutoff value for the blast
    $MINLENGTHORF = $option->flip2;                                        #  This is the minimum length for creating an ORF with flip
    $MAXLENGTHFORGROUPINGORF = $option->intronsize;                        #  Minimum size of a gap between 2 ORf. If 2 same ORF
    $MINLENEMPTYORF = $option->minlenemptyorf;                             #  Minimum length for ORF empty orfs (non corresponding orfs)
    $OVERLAPPINGCUTOFF = $option->overlappingcutoff;                       #  Overlapping cutoff for ORFs 
    $TRNACUTOFF = $option->trnacutoff;                                     #  tRNAs cutoff 

    
}

sub FindClosestOrganism    # This function is regarding into the PEPLIBRARY if what is the file having
{                          # the
	
    my $directory = $PEPLIBRARY;                     # Data directory
    my $pepfile = "$TMPDIR/Pep.txt";
    my $peplib = "$TMPDIR/Peplib";
    my $flipcutoff = $MINLENGTHORFFORFINDINGCLOSESTORGANISM;
    my $blastoutput = $BLASTOUTFORFINDINGCLOSESTORGANISM;
    my $blastcutoff = $BLASTEVALUECUTOFFFORFINDINGCLOSESTORGANISM;
	
    opendir (DIR, $directory) or die 'can not open directory\n';        # Open the directory
    my @files = grep {/\.pep$/ && -f "$directory/$_"} readdir (DIR);    # Keep the existing *.pep files
    close (DIR);
	
	
    if (-f $pepfile) {
        system ("rm -f $pepfile");
    }
    foreach (@files) {
        system ("cat $directory/$_ | sed 's/^>.*/>$_/' >> $pepfile")	
    }	
	
	
    #########	FIRST RUN FORMATDB	###################
	
    my $cmdformatdb = "formatdb -p T -i $pepfile -n $peplib";
    print "$cmdformatdb\n" if $DEBUG;
    my $resformatdb = system("$cmdformatdb");
    #print $resformatdb if $DEBUG;
	
    #########	THEN RUN FLIP	###################	
    my $cmdflip = "flip -l $flipcutoff $MASTERFILE > $TMPDIR/flip1.output";
    my $resflip =  system $cmdflip;
    print "$cmdflip\n" if $DEBUG;
    #print "$resflip\n" if $DEBUG;		

    #########	THEN RUN BLAST	###################		

    my $cmdblast = "blastall -p blastp -d $peplib -i prot.lst -o $blastoutput 2> $TMPDIR/blasterr.txt";  #  -p programm
                                                                                                         #  -d database
                                                                                                         #  -i input
                                                                                                         #  -o output
    print "$cmdblast\n" if $DEBUG;                                                             
    my $resblast = system("$cmdblast");
    #print $resblast if $DEBUG;
	
    #########	THEN PARSE THE BLAST ###############	
	
    my %bestresults;
    if (! -r $blastoutput) { # it's supposed to be here at this point.
        die "Error: can't find report from blastall ?!?\n";
    }
    my $searchio = new Bio::SearchIO (
                                       -format => 'blast',
                                       -file   => $blastoutput,
                                      );
   RESULT : while (my $result = $searchio->next_result() ) {
                my $contigname = $result->query_name()        || "Unknown ID";
                my $rdesc      = $result->query_description() || "Unknown Query Description";
                my $dbname     = $result->database_name()     || "Unknown DB name";
                my @hits       = $result->hits();             # Bio::Search::Hit::HitI		
                my $numhits    = scalar(@hits);               # normally, only one! 
                next RESULT if $numhits < 1;
                my $hit=$hits[0];
                my $hypprotein   = $hit->name();              # returns the name of the Hit sequence
                my $desc         = $hit->description();       # Get the description of the query sequence
                my $score        = $hit->score();             # Get the blast score
                my $evalue	 = $hit->significance();      # Get the e-value

                if ($evalue < $blastcutoff) {                 # Keep only if evalue is good
                    $bestresults {$hypprotein} += 1; 
                }		 
	   }
	
    ##########   THEN LOOK FOR THE BEST : THE MAX OCCURENCES IN THE ARRAY  #######
	
    my @bestresultskeys = keys(%bestresults);
	
    if (scalar(@bestresultskeys) < 1) {                       # If there is no file
        return "";
    } 
	
    my $bestfile = $bestresultskeys[0];
    foreach (@bestresultskeys) {
        if ($bestresults {$_} > $bestresults {$bestfile}) {
            $bestfile = $_;
        }
        else {
            next;
        }
    }
	
    undef (%bestresults);
    return $bestfile || undef;
}

sub AnnotateEmptyOrfs {   #  This function takes the empty array of ORF and annotate it as ORFs
                          #  It means ORF having non corresponding gene in a pepfile
			  
     my $pirmaster = shift;    # get the masterfile object

     EMPTYORF : foreach my $emptyorf (@$EMPTYORFS) {   #  process each non corresponding orf
     
         ####  Get informations  about empty ORF
	 my $contigname = $emptyorf->contigname;       #  Get the contigname corresponding to the empty ORFs
	 my $strand = $emptyorf->strand;
	 my $arrow = ($strand == 1 ? '==>' : '<==');
	 my $start;
         my $end;
	 
	 my $overlappingcutoff = $OVERLAPPINGCUTOFF;                 #  authorized overlapping  
	 my $minimumlengthorf = $MINLENEMPTYORF;                     #  minimum Orf size, below this size, the ORF is no more kept
	 my $contig = $pirmaster->GetContigByName($contigname) || die "Can't get contig by name in AnnotateEmptyOrfs\n";
         
	 
	 my $annotations = $contig->get_annotations;                 #  Get the annotations, for the same contig belonging to empty ORF
	 
	 # Get the new start codon
	 my $seq = $contig->sequence;						#	Get the sequence
	 $seq =~ s/!//g;
	 
	 my $newstart = &FindNewStart ($seq, $emptyorf->start, $emptyorf->end, $strand);
         
	 
	 $emptyorf->set_start ($newstart);

	 if ($emptyorf->start < $emptyorf->end) {
	     $start = $emptyorf->start;
	     $end = $emptyorf->end;
	 }
	 else {
	     $start = $emptyorf->end;
	     $end = $emptyorf->start;
	 }

	 
	 #next EMPTYORF if (int(abs($end - $start)*3) < $minimumlengthorf);  #  Size Verification 
	 next EMPTYORF if (int(abs($end - $start)/3) < $minimumlengthorf);  #  Size Verification 
	 
	 if ( $CHECKORFS) { # if option CHECKORF is activate
             ANNOT : foreach my $annotation (@$annotations) {
	     
	         ## Verifiaction : 
	         ## -doesn't take the annotation if it's something else than a comment
	         next ANNOT if ((not defined($annotation->type)) or ($annotation->type ne 'G'));       
	     	     
	         ## Get information from current annotation
	         my $annotstart;
	         my $annotend; 
	         if ( $annotation->startpos <  $annotation->endpos) {
	             $annotstart = $annotation->startpos;
	             $annotend = $annotation->endpos;
                 }
	         else {
	             $annotstart = $annotation->endpos;
	             $annotend = $annotation->startpos;
	         }
		 
	
	     
	         # OVERLAPPING CHECK
	         # overlapping is allowed below a given cutoff 
	         # this cutoff is inside the variable $OVERLAPPINGCUTOFF
	     
	         #### Case were it seems to work
                 next ANNOT if ((($start >= $annotend) or ($end <= $annotstart)));
		
                 #### Case were it doesn't work
		
	         ######## FOUR CASES
						      
	         ####  1) ORF is inside the gene and longer than the gene
	         ####         |___________________|      ORF
	         ####            |______________|        GENE
	 	
	
	         if ($start <= $annotstart && $end >= $annotend) {
		    next EMPTYORF;    
	         }				       
		
		
	         ####  2) ORF is inside the gene and smaller than the gene => that is ok
	         ####            |_____________|        ORF
	         ####         |___________________|     GENE
		
	         #if ($start >= $annotstart && $end <= $annotend) {
	         #    next EMPTYORF;    
	         #}
		
	         ####  3) ORF is overlapping the gene
	         ####                        |___________|        ORF
	         ####         |____________________|              GENE
		
	         if ($start >= $annotstart && $end >= $annotend) {
		     my $overlapping=0;                           #  Overlapping calculation
		     $overlapping += abs($annotstart-$end);
		     $overlapping = $overlapping / abs ($end - $start);
		    
		     if ($overlapping > $overlappingcutoff) {
		         next EMPTYORF;
	             }   
	          }  
		
	          ####  4) ORF is overlapping the gene
	          ####        |__________|              ORF
	          ####              |________________|  GENE
		
	          if ($start <= $annotstart && $end <= $annotend) {
	       	      
		      my $overlapping=0;                        #  Overlapping calculation
		      $overlapping += abs($start-$annotend);
		    
		      $overlapping = $overlapping / abs ($end - $start);
		    
		      if ($overlapping > $overlappingcutoff) {
		         next EMPTYORF;
	              }
	          }
		
	    
	
        	}  # End of traversing each annotation
	} # end of if ORFCHECK
	
	
	 ### Creating an annotation object for storing in the masterfile
	 my $orfsize = abs($start-$end);
	 $orfsize = $orfsize / 3;
	 $orfsize = int ($orfsize);
	 my $GenenameORF = "orf". $orfsize;
		
	#-------------------------------------------------------------------------------------
	#  Treatment to add a number after the genename ______________________________________
	#-------------------------------------------------------------------------------------	
	 my $numberofannotforthisorf = $ANNOTSEEN->{$GenenameORF} || 0;
	 $numberofannotforthisorf ++;
	 my $startline = "";
	 my $endline = "";
	 if ($numberofannotforthisorf >= 2) {
	     	$startline = ";     G-$GenenameORF"."_$numberofannotforthisorf"." $arrow start";
	        $startline .= " ;; MFFEAT=$TAGNAME" if $ADDCOMMENTS;     # add comments if option is activated
	        $endline = ";     G-$GenenameORF"."_$numberofannotforthisorf"." $arrow end";
	        $endline .= " ;; MFFEAT=$TAGNAME" if $ADDCOMMENTS;       # add comments if option is activated
	 }
	 else {
	       $startline = ";     G-$GenenameORF $arrow start";
	       $startline .= " ;; MFFEAT=$TAGNAME" if $ADDCOMMENTS;     # add comments if option is activated
	       $endline = ";     G-$GenenameORF $arrow end";
	       $endline .= " ;; MFFEAT=$TAGNAME" if $ADDCOMMENTS;
	 }
	 # ________________________________________________________________________________
	   
	 my $orfannot = new PirObject::AnnotPair (
	                        type      => "G",  
              			genename  => $GenenameORF,
                        	startpos  => $emptyorf->start,
                        	endpos    => $emptyorf->end,
                        	direction => $arrow,
                        	startline => $startline,
                        	endline   => $endline,
                    	);
    
	# Put into the table containing all of the masterfile annotations
	# So before, being put in the masterfile (means in a first time in the annotation table), there are some verification
       # print "Il a ajoute cette orf vide : $GenenameORF\n";
	&AddAnnotToPirMaster($pirmaster,$contigname,$orfannot);
	
     
     }  #  END OF FOR EACH EMPTY ORFS


}  # End function AnnotateEmptyOrfs

sub NextLetter {                        #       A function that gives you the next letter

    my $letter = shift;
    my $newletter = ord ($letter);
    $newletter ++;
    $newletter = chr $newletter;
    return $newletter;
    
}

sub InitializeANNOTSEEN {   # this function initilaise the hash array
                            # After the masterfile has been opened
			    # This one contain how many annotation per genname
			    

my $pirmaster = shift;
my $contigs = $pirmaster->get_contigs;
foreach my $contig (@$contigs) {
    my $annotations = $contig->get_annotations;
    foreach my $annotation (@$annotations){
        if ($annotation->type eq "G") {
	    $ANNOTSEEN->{$annotation->genename} += 1; 
	} # end if
    } # next annotation	
	
 } # next contig 
	    

}

sub AnnotateMfFromHYPPROTSArray {	#	This function annotates the masterfile from the blast results


	my $pirmaster = shift;

	HYPPROT : foreach my $hyprot (@$HYPPROTS)
	{
		my $name = $hyprot->name;
		next HYPPROT if (not (defined $name) or ($name eq ""));    #  go the next protein if name is not defined, 
		my $contigname = $hyprot->contigname;
		my $start = $hyprot->start;
		my $end = $hyprot->end;
		my $arrow = ($hyprot->strand == -1 ? '<==' : '==>');
		my $tag = $hyprot->remark;
		
	
		#print "----------------------------------\n";
		#print "Annotation :, $name, $start, $end, $arrow\n";
		
		my $numberofthisannot = $ANNOTSEEN->{$name} || 0;               # get the number for each annot  
		$numberofthisannot += 1;                                        # increase by one, because it's current
		my $linename = $name;                                           # the name gene in start and endline
		$linename .= "_$numberofthisannot" if ($numberofthisannot >= 2); # If there is more than one, add this at the end
		
		my $startline = ";     G-$linename $arrow start"; 
		$startline .=  " ;; MFFEAT=$TAGNAME ;; $tag" if $ADDCOMMENTS;   # add comments if option is checked
		my $endline = ";     G-$linename $arrow end";
		$endline .= " ;; MFFEAT=$TAGNAME ;;$tag" if $ADDCOMMENTS;       # add comments if option is checked
		
		my $protannot = new PirObject::AnnotPair (
		                type      => "G", 
              			genename  => "$name",
                        	startpos  => $start,
                        	endpos    => $end,
                        	direction => $arrow,
                        	startline => $startline,
                        	endline   => $endline,
                    	);
        	my $res = &AddAnnotToPirMaster($pirmaster,$contigname,$protannot);
	        
	        my $exons =  $hyprot->exons;
		
		if (!defined ($res) or $res == 0)  # go out of the function if the protein has not been added
	        {
		    	$ANNOT_STATS->{'Rediscovered'}->{$protannot->genename}->{'E'} += scalar (@$exons) if (scalar (@$exons) > 0);
			next HYPPROT;
		} 
			
	       
		if ($name =~ /^orf/) {   # if it's an ORF, then it goes to through, because an ORF must not have  
		    next HYPPROT;
		}
		
		if (($ALLEXONS == 0) and (scalar (@$exons) <= 1)) {  # if there is only one exon, and if option is not checked, go to the next prot
		    next HYPPROT;
		}     
		
		# Annotating exons	
		my $number = 1;
		foreach my $exon (@$exons) {
			
			my $exonstart = $exon->start;
			my $exonend = $exon->end;
			my $exonstrand = $exon->strand;
		
			my $startline = ";     G-$linename-E$number $arrow start";
			$startline .= " ;; MFFEAT=$TAGNAME" if $ADDCOMMENTS;           # option checked, add comments
			my $endline = ";     G-$linename-E$number $arrow end";
			$endline .= " ;; MFFEAT=$TAGNAME" if $ADDCOMMENTS;             # option checked, add comments
			
			my $exonannot = new PirObject::AnnotPair (
			        type      => "E",
              			genename  => "$name",
                        	startpos  => $exonstart,
				endpos    => $exonend,
                        	direction => $arrow,
                        	startline => $startline,
				endline   => $endline,
			);
			
			$number++;	
			my $res = &AddAnnotToPirMaster($pirmaster,$contigname,$exonannot);	
		
		}
	
	
	}


}

sub FindNewStart {  # This function is assuming to return the new start codon,  

  # arg1, sequence
  # arg2, start,
  # arg3, end
  # arg4, strand

  my $possiblestarts = ['ATG', 'AUG'];
  my $seq = shift;                                # the sequence where to look
  my $oldstartpos = shift;                        # Get the old start position
  my $newstartpos = $oldstartpos;             
  my $currentpos  = $oldstartpos;
  my $end = shift;                                # the end of the gene
  my $strand = shift;                             # the strand of the gene
  		  
  my $found = 0;
  
  
  ####	Two cases
		if ($strand == 1)						#	Right strand
		{
			CODON : while (not ($found) and ($currentpos < $end))
			{
				my $codon = uc (substr($seq, $currentpos-1, 3));
				$codon =~ tr/ATUGCatugc/ATTGCATTGC/;
				#print $hypprot->name, " $codon $currentpos\n";
				#print "codon 
				
				if (ValueIsIn($possiblestarts, $codon) == 1)
				{
					$found = 1;
					$newstartpos = $currentpos;
					next CODON;
				}
				else {
					$currentpos += 1;
					next CODON;
				}
			}		
		}
		else 									#	Complementary strand
		{
			CODON : while (not ($found) and ($currentpos-3 > $end))
			{
				my $codon = uc (substr($seq, $currentpos-3-1, 3));
				$codon =~ tr/ATUGCatugc/TAACGTAACG/;
				$codon = reverse ($codon);				#	Reverse and complementary
				
				if (ValueIsIn($possiblestarts, $codon) == 1)
				{
					$found = 1;
					$newstartpos = $currentpos-1;
					next CODON;
				}
				else {
					$currentpos -= 1;
					next CODON;
				}
			}
		}
  
    return $newstartpos;
  
}

sub OrganiseHYPPROTSArray {	#	this function is supposing to find the real start and recreating exon if necessary

	my $pirmaster = shift;
	my $possiblestarts = ['ATG', 'AUG'];

	#################   The first thing is to look for the new start #########################
	foreach my $hypprot (@$HYPPROTS) {
	
		my $oldstartpos = $hypprot->start;					#	Get the old start position
		my $newstartpos = $hypprot->start;
		my $currentpos  = $hypprot->start; 
		my $found = 0;
		my $contig =  $pirmaster->GetContigByName ($hypprot->contigname);	#	Get the contig
		my $seq = $contig->sequence;						#	Get sequence
		$seq =~ s/!//g;
		my $end = $hypprot->end;
		
		####	Two cases
		if ($hypprot->strand == 1)						#	Right strand
		{
			CODON : while (not ($found) and ($currentpos < $hypprot->end))
			{
				my $codon = uc (substr($seq, $currentpos-1, 3));
				$codon =~ tr/ATUGCatugc/ATTGCATTGC/;
				#print $hypprot->name, " $codon $currentpos\n";
				
				if (ValueIsIn($possiblestarts, $codon) == 1)
				{
					$found = 1;
					$newstartpos = $currentpos;
					next CODON;
				}
				else {
					$currentpos += 1;
					next CODON;
				}
			}		
		}
		else 									#	Complementary strand
		{
			CODON : while (not ($found) and ($currentpos-3 > $hypprot->end))
			{
				my $codon = uc (substr($seq, $currentpos-3-1, 3));
				$codon =~ tr/ATUGCatugc/TAACGTAACG/;
				$codon = reverse ($codon);				#	Reverse and complementary
				
				if (ValueIsIn($possiblestarts, $codon) == 1)
				{
					$found = 1;
					$newstartpos = $currentpos-1;
					next CODON;
				}
				else {
					$currentpos -= 1;
					next CODON;
				}
			}
		}
		
		#print $hypprot->name, " ", $newstartpos, " ", $oldstartpos, "\n";
		
		#	Now we have found the new start codon
		#	Exons have to be reorganized
		my $exons =  $hypprot->exons;
		@$exons = sort {							
				if ($hypprot->strand == 1) {
				
					$a->start <=> $b->start;
				}
				elsif ($hypprot->strand == -1){
				 
					
					$b->start <=> $a->start;
				}
		} @$exons;	#	Exons are sorted
		
		my $newexons = [];
		EXON : foreach my $exon (@$exons) {
		
			if ($hypprot->strand == 1) {
				if ($exon->start < $newstartpos) { #	2 case Or the exon changes his first start or it doesnt belong anymore to the prot
					if ($exon->end <  $newstartpos)	{	#	it doesnt belong anymore to the prot
						next EXON;
					}
					else {					# 	it belongs but start has changed
						$exon->set_start ($newstartpos);
						push (@$newexons, $exon);
					}
				}
				else {
					push (@$newexons, $exon);
				}
			}	#	End strand == 1
			else {
				if ($exon->start > $newstartpos) { #	2 case Or the exon changes his first start or it doesnt belong anymore to the prot
					if ($exon->end >  $newstartpos)	{	#	it doesnt belong anymore to the prot
						next EXON;
					}
					else {					# 	it belongs but start has changed
						$exon->set_start ($newstartpos);
						push (@$newexons, $exon);
					}
				}
				else {
					push (@$newexons, $exon);
				}	 
			}
		
		}
		
		undef (@$exons);	# 	unreferencing the array
		$hypprot->set_start ($newstartpos);
		$hypprot->set_exons ($newexons);
		
		# After the real start has been done, delete exon
		# having an overlapping => take one exon : look if he is overlapping 
		# the others and group them.
		if (scalar (@$newexons) >1) {   # only if there are more than one exon
		    my $newexons2 = [];
		    foreach my $exon (@$newexons) {  # go through the exons
		        my $found = 0;
			foreach my $currentexon (@$newexons2) {  # go through the new exons
		            
			    if ($hypprot->strand == 1) {   #First case, if the two exons beginn with -1
			        # for each strand, 4 case
				if (($exon->start <= $currentexon->start) &&   ($exon->end >= $currentexon->end)) {
				    #   __________________  other
				    #       _________       current 
				    $currentexon->set_start ($exon->start);                                        
				    $currentexon->set_end ($exon->end);                                             
				    $found = 1;
				}
				elsif (($exon->start <= $currentexon->start) &&   ($exon->end <= $currentexon->end) && ($exon->end >= $currentexon->start)) {   
				    #   ____________       other
				    #       _____________  current    
			            $currentexon->set_start ($exon->start);                                                                                     
				    $found = 1;
				}
				elsif (($exon->start > $currentexon->start) &&   ($exon->end > $currentexon->end) && ($exon->start <= $currentexon->end)) {   
			            #         ____________ other
				    #   _____________      current    
				    $currentexon->set_end ($exon->end);                                                
				    $found = 1;
				}
				elsif (($exon->start > $currentexon->start) &&   ($exon->end < $currentexon->end)) {
				    #   __________________  current
				     #       _________       other      
				    $found = 1;                                                                    
				}
			    }  # end of case if strand == 1
			    
			    elsif ($hypprot->strand == -1) {   #First case, if the two exons beginn with -1
			        # for each strand, 4 case
				if (($exon->start >= $currentexon->start) &&   ($exon->end <= $currentexon->end)) {
				    #   __________________  other
				    #       _________       current 
				    $currentexon->set_start ($exon->start);                                        
				    $currentexon->set_end ($exon->end);                                             
				    $found = 1;
				}
				elsif (($exon->start >= $currentexon->start) && ($exon->end >= $currentexon->end) && ($exon->end <= $currentexon->start)) {
				    #   ____________       other
				    #       _____________  current     
			            $currentexon->set_start ($exon->start);                                           
				    $found = 1;
				}
				elsif (($exon->start <= $currentexon->start) &&  ($exon->end <= $currentexon->end) && ($exon->start >= $currentexon->end) ) {
				    #         ____________ other
				    #   _____________      current       
			            $currentexon->set_end ($exon->end);                                             
				    $found = 1;
				}
				elsif (($exon->start <= $currentexon->start) &&   ($exon->end >= $currentexon->end)) {
				    #   __________________  current   
				    #       _________       other   
				    $found = 1;                                                                     
				}
			    }  # End of case if strand == -1
			    
			}
			if ($found == 0) { # that means, this exons can not be grouped with no other
			
			    push (@$newexons2, $exon);
			
			}
		     }
		     
		     #print "Nom de la prot ou on a change les exons : ", $hypprot->name, "\n";
		     #print "Avant\n";
		     #foreach my $currentexon (@$newexons) {  # go through the new exons
		     #         print $currentexon->start, " ", $currentexon->end, " ", $currentexon->strand, "\n";
		     #	}
		     #print "Apres\n";
		     #foreach my $currentexon (@$newexons2) {  # go through the new exons
		     #         print $currentexon->start, " ", $currentexon->end, " ", $currentexon->strand, "\n";
		     #	}
		     	
		     # At the end, attribut the new exon table,
		     $hypprot->set_exons ($newexons2);	
		}
		
		
		
	}	#	End for each prot

}	#	End function

sub ValueIsIn {		# check if a value is in an array

	my $array = shift;
	my $value = shift;
	
	foreach (@$array)
	{
		if ($value eq $_)
		{
			return 1;
		}
	}
	
	return -1;

}

sub RunFlip { # This function run flip with the mf
	
    my $cmdflip = "flip -s ATG -m -l $MINLENGTHORF -g $GENCODE $MASTERFILE > $TMPDIR/flip2.output";
    my $resultat = system ($cmdflip);	
    print "$cmdflip\n" if $DEBUG;
    # print "$resultat\n" if $DEBUG || defined $resultat;
    # After that flip will create files in the local directory wich are called prot.lst, and prot.src

} 



sub BlastFlipVSGene {	# it runs blast with the flip results against file containing genes 


    my $file = $PEPFILE;                                # undef should never happen in fact.
    my $escaped_file = $file;
    $escaped_file =~ s#'#'\\'#g;         
    my $command = "formatdb -p 'T' -t banque -i $escaped_file -n $TMPDIR/mf -l fdb.log";
    print "$command\n" if $DEBUG;
    my $resformatdb = system($command);
    #print "$resformatdb\n" if $DEBUG;

    #RUN FOR BLAST : run blast with the db created and the flip results		
    my $cmdblast = "blastall -p blastp -d $TMPDIR/mf -i prot.lst -D $GENCODE -o $BLASTOUTPUT 2> $TMPDIR/blasterr.txt";
    print "$cmdblast\n" if $DEBUG;
    my $resblast = system ($cmdblast);
    #print "$resblast\n" if $DEBUG;
	
}

sub ParseInformationFromBlastResult {

    my $pirmaster   = shift;
    my $tag         = shift || "aVwXyZ";
    
    # This loop goes through the different fasta input files that
    # are currently defined in MfAnnotConfig.pir
   
        
    my $type = 'PROT';
    my $file = $PEPFILE;
    my $blastoutput = $BLASTOUTPUT;
    if (! -r $blastoutput) { # it's supposed to be here at this point.
        die "Error: can't find $type report from blastall ?!?\n";
    }
    my $searchio = new Bio::SearchIO (
                                       -format => 'blast',
                                       -file   => $blastoutput,
                                     );
    while (my $result = $searchio->next_result() ) {
        &FillFLIPBLASTPROTArrayFromBlastResult($pirmaster,$type,$result,$tag);
    }
}

sub FillFLIPBLASTPROTArrayFromBlastResult {
    my $pirmaster = shift;	#	Pirmaster Object
    my $type      = shift;  	# 	'DNA' or 'PROT'
    my $result    = shift; 	# 	an object implementing Bio::SearchIO::Result::ResultI
    my $tag       = shift || "bVwXyZ";
    
    if (!$result) {return;}

    my $contigname = $result->query_name()        || "Unknown ID";
    $contigname =~ s/\;//g;	#	Delete false caracter			
    my $rdesc      = $result->query_description() || "Unknown Query Description";
    my $dbname     = $result->database_name()     || "Unknown DB name";
    my @hits       = $result->hits();# Bio::Search::Hit::HitI		
    my $numhits    = scalar(@hits);  # normally, only one! 
    return if $numhits < 1;
    #print "description : $rdesc\n";
    #print "Found result: ID=$contigname DESC=$rdesc DBNAME=$dbname with $numhits hits\n" if $DEBUG;
    #print "Found result: ID=$contigname DESC=$rdesc DBNAME=$dbname with $numhits hits\n";
    #my $contigus = $pirmaster->get_contigs();

          
    # We have an hypothetical protein and we want to know if it'real
    my ($strand, $start, $end) = ($rdesc =~ /(orig|compl).\s+(\d+)\s+to\s+(\d+)\s+;\s+[\w\.\!]+$/);
    # if ((not (defined $strand)) or (not (defined  $start)) or (not (defined $end)) or (not (defined $rdesc))) {
    # print "starnd $strand\n, 
    #      start  $start\n
    #	  emd $end\n
    #	  rdesc $rdesc\n";}
    #print "ligne 376 $strand, $start, $end \n";
    my $debut = ($start < $end ? $start : $end);
    my $fin = ($start < $end ? $end : $start);
    
    #sort (@hits)
    my $arrow = ($strand eq 'orig' ? '==>' : '<==');
    $strand = ($strand eq 'orig' ? 1 : -1);
    
    my $hit=$hits[0];    
    ###--------------------QUIT THE FUNCTION IF EVALUE IS TOO  WEAK-----------------------------#
    if ($hit->significance > $BLASTEVALUECUTOFF) {	        # If the e-value is not enough for these ORF you can
                                                # It creates an Empty ORF 
    	my $newemptyorf = new PirObject::EmptyOrf (start   => $start,
                                                   end    => $end,
				                   strand => $strand,
				                   score  => $hit->significance,
						   contigname => $contigname,
				                   );
	push (@$EMPTYORFS, $newemptyorf);       #  Put into the array, to be processed after   
	return;                                 #  Exit the function, because there is no significant ORF 
    }
    ###-----------------------------------------------------------------------------------------#
    
    ####  Now we have the start, we have the end, the strand
    ####  And we would like to know if more than one hit is allowed
    
    my @overlapping;
    
    HIT : foreach my $hit (@hits) {
    # my $hit=$hits[0];
    #my $hypprotein   = $hit->name();		#	returns the name of the Hit sequence
        my $desc         = $hit->description();	#	Get the description of the query sequence
    #print "description $desc\n"; 
        my ($hypprotein) = ($desc =~ /\s*([\w]*)\s*;/); 
	next HIT if (not (defined $hypprotein) or $hypprotein eq "");
        my $score        = $hit->score();		#	Get the blast score
        my $evalue	 = $hit->significance();	#	Get the e-value
        my @hsps = $hit->hsps;			# 	High Scoring pairs : Bio::Search::HSP::BlastHSP
        
	print "$desc\n";
	print "------------------\n";
	return if ($evalue > $BLASTEVALUECUTOFF);
        foreach my $hsp (@hsps) {
	    my (@hih,@aha) = $hsp->matches('hits');
	    print "@aha\n";
	    
	}
    print "------------------\n";
        if (scalar(@hsps) == 0) {
            return;				#	An ORF that has a good evalue but no HSP => impossible but ...
        }
        elsif (scalar(@hsps) == 1) {
    		
        }
	
	#------- Calculate a sort of frame to see what's the region covered by this ORF
	#  Story : You can have, for some case, more than one protein per gen.
	#  It's a sort of fusion protein.
	#  Each of both have a functional part
	
	#-----------------------------------------------------------------------------#
	# To make distinction between a protein fusion and a protein annotated as twice
	# We have to check the High Scoring Pair frame. If there is no overllapping between 
	# HSP frames, it means you have many proteins on the same frame
	# If there is, it's probably because many similar proteins corresponds to the same gene
	
	
	my $frame = {};
	my $framestart = $hsps[0]->start;
	my $frameend = $hsps[0]->end;
	#my $framestrand = $strand;
	
	#  We don't need to check for strand because HSP are sorted as if there were on the right strand

	foreach (@hsps) {	
	    $framestart = $_->start if ($_->start < $framestart);
            $frameend = $_->end if ($_->end > $frameend);
	    
        }
	$frame -> {"start"} = $framestart;
	$frame -> {"end"} = $frameend;
	#push (@overlapping, 
	
	#print "________________________________________________\n";
	#print "HIT : $hypprotein, frame, $framestart, $frameend\n";        
	#print "les autres frames : \n";
	#----  Regarding for overlapping in hits : if it's rigth, only one hit is allowed
	
	my $isoverlapping = 0;                          #       Indiquate if wheter or not, accept the hit as annotation of the ORF 
	           
	CURRENTFRAME : foreach my $currentframe (@overlapping) {
	
	    #print $currentframe->{"start"}, " ", $currentframe->{"end"};
	    
	
	    ##################   FOR EACH STRAND THERE IS 4 CASES WHEN FRAME are OVerlapping
	    
	    # 1)     |----------------|             first frame
	    #               |-----------------|     second frame
	    
	    # 2)            |----------------|      first frame
	    #        |-----------------|            second frame
	    
	    # 2)          |---------|               first frame
	    #        |-----------------|            second frame
	    
	    # 4)    |-----------------|             first frame
	    #         |---------|                   second frame
	                            
				    #       Case were we are on the right strand
	    $isoverlapping = 1 if (($currentframe->{"start"} <=  $frame -> {"start"}) && ($currentframe->{"end"} >=  $frame -> {"start"}));
	    $isoverlapping = 1 if (($frame -> {"start"} <=  $currentframe->{"start"}) && ($frame -> {"end"} >=  $currentframe->{"start"}));
	    $isoverlapping = 1 if (($frame -> {"start"} <=  $currentframe->{"start"}) && ($currentframe -> {"end"} <=  $frame->{"end"})); 
	    $isoverlapping = 1 if (($currentframe -> {"start"} <=  $frame->{"start"}) && ($frame -> {"end"} <=  $currentframe->{"end"}));  
	    
	    last CURRENTFRAME if $isoverlapping == 1;   #       Go out of the loop if there is a overlapping frame  
	}
	
	next HIT if ($isoverlapping == 1);              #       If there is an overlapping, the HIT isn't good for annotation
	push (@overlapping, $frame) if 	($isoverlapping == 0);
    
	
        #----	Creating a new ORF object	---
        my $neworf = new PirObject::Orf (start   => $start,
                                      end    => $end,
				      strand => $strand,
				      score  => $evalue,
				      hsps   => []);
        my $refhsparray = $neworf->hsps;	       #	An array reference,					      
        foreach (@hsps) {
    	    my $newhsp = new PirObject::Hsp (start  => $_->start,
		                             end    => $_->end,
					     strand => $_->strand);
	    push (@$refhsparray, $newhsp);
	}
    
		      			      
        my $newflipblastprot = GetFlipBlastProtByNAmeAndContigName ($hypprotein, $contigname);
        #	Two case
        if (defined $newflipblastprot) {	#	Wether the prot is already defined
    	    my $reforfarray = $newflipblastprot->orfs;
	    push (@$reforfarray, $neworf);	#	Annd we just add a new orf
        }
        else {
    	    my $newflipblastprot = new PirObject::FlipBlastProt (name        => $hypprotein,	#	First we create the flipblast prot
							     contigname => $contigname,
							     orfs       => []);
	    my $reforfarray = $newflipblastprot->orfs;
	    push (@$reforfarray, $neworf);	#	Annd we just add a new orf
	    push (@$FLIPBLASTPROTS, $newflipblastprot);
        }	
    
	return if (! $MULTIORFS);                 #       Exit the function after the first hit if multi ORFS not allowed
    
    }

	
        
}

sub FillHYPPROTSArrayWithFLIPBLASTPROTSArray {	#	This function fill the HYPPROTS array (array of hypothetical proteins with
						#	FLIPBLASTPROTS array (array of ORF and hsp)

	#	This is mainly the algorithm given by Franz
	foreach my $flipblastprot (@$FLIPBLASTPROTS) {		#	For each fliup blast protein
		my $name = $flipblastprot->name;
		my $contigname = $flipblastprot->contigname;
		
		
		
		my $orfs = $flipblastprot->orfs;
		my $numberorfs = scalar (@$orfs);
		
		# print "$name,  $contigname $numberorfs\n";
		
		if ($numberorfs < 1) {
			return;			#	Impossible but ...
		}
		elsif ($numberorfs == 1) {	#	Most of the case where there is no introns
			my $hsps = @$orfs[0]->hsps;
			
			#Two case : Are the HSP in a same frame or not
			my $starthsps = [];	#	All of the start of the hsp
			my $strandhsps = [];	#	All of the strand in the HSP
			
			foreach my $hsp (@$hsps)
			{
				push (@$starthsps, $hsp->start);
				push (@$strandhsps, $hsp->strand);
			}
			
			
			if (IsSameFrame($starthsps) ==- 1) { # Create an hypoproteine containing only one orf
			        
				#-------------------------------------------#
				#THE PROTEIN HAS INTRON OR THERE IS A SEQUENCING PROBLEM
				
				# 1) creating the new hypothetical protein
				my $newhypprot = new PirObject::HypProt (name       => $name,
									 contigname => $contigname,
									 start      => @$orfs[0]->start,
									 end        => @$orfs[0]->end,
									 strand     => @$orfs[0]->strand,
									 exons      => [],
									 numorfs    => 1,
									 remark     => "One Reading Frame but HSP not in the same frame. protein seems to have introns, or sequencing problem"
									 );
				
				# 2) creating the potential exon
				my $exons = $newhypprot->exons;
				foreach my $hsp_exon (@$hsps)
				{
					my $exonstart = (@$orfs[0]->strand == 1 ? @$orfs[0]->start + $hsp_exon->start : @$orfs[0]->start - $hsp_exon->start);
					my $exonend = (@$orfs[0]->strand == 1 ? @$orfs[0]->start + $hsp_exon->end : @$orfs[0]->start - $hsp_exon->end);
					
					my $exon = new PirObject::Exon (start  => $exonstart, 
									end    => $exonend,
									strand => @$orfs[0]->strand
									);
					push (@$exons, $exon);
				}
				
				push (@$HYPPROTS, $newhypprot);		#	Don't forgett to put the hyp prot. in the array
			
			}
			else {              
				#-------------------------------------------#
				#THE PROTEIN HAS NO INTRON IN THE SEQUENCE BECAUSE ALL THE HSP ARE IN THE SAME FRAME
			        #print "On est ici ", $name,"\n";
				my $newhypprot = new PirObject::HypProt (name       => $name,
									 contigname => $contigname,
									 start      => @$orfs[0]->start,
									 end        => @$orfs[0]->end,
									 strand     => @$orfs[0]->strand,
									 numorfs    => 1,
									 remark     => "One Reading Frame. Protein seems to have no introns, all hsp are on the same frame"
									 );
			
				push (@$HYPPROTS, $newhypprot);		#	Don't forgett to put the hyp prot. in the array
			
			}
			
			
			
			
			
			
		}
		else{	# 	On the case you have many ORFs
			
			my $neworfs = [];
			
			@$orfs = sort {		#	The ORFs are classified and sorted by starnd and start, stop positions
				my $stranda = $a->strand;
				my $strandb = $b->strand;
				if ($stranda != $strandb) {
				
					$a->strand <=> $b->strand;
				}
				else {
				 
					if ($stranda == 1) {
						$a->start <=> $b->start;
					}
					else {
						$a->end <=> $b->end;
					}	
				}
				} @$orfs;
				
			
			my $newhypprot = undef;		#	This is the current hyp. prot
			
			ORF : foreach my $orf(@$orfs)
			{
				
			
				#	Now the thing is to create a new hyp prot if the conditions are not required
				#	First : if the $currentprot is not defined
				
				#------------	case	 1 : first ORF
				if (not defined($newhypprot)) {
				#	Here we create a new protein
				
					$newhypprot = new PirObject::HypProt (name       => $name,
									      contigname => $contigname,
									      start      => $orf->start,
									      end        => $orf->end,
								              strand     => $orf->strand,
									      exons      => [],
									      numorfs    => 1,
									      remark	 => "" 
									 );
					my $exons = $newhypprot->exons;
					my $hsps = $orf->hsps;
					foreach my $hsp_exon (@$hsps)
					{
						my $exonstart = ($orf->strand == 1 ? $orf->start + $hsp_exon->start : $orf->start - $hsp_exon->start);
						my $exonend = ($orf->strand == 1 ? $orf->start + $hsp_exon->end : $orf->start - $hsp_exon->end);
					
						my $exon = new PirObject::Exon (start  => $exonstart, 
										end    => $exonend,
										strand => $orf->strand
										);
						push (@$exons, $exon);
					}
									 
					next ORF; 
					
				}
				
				
				
				#------------	case	 2 : not the same strand
				if ($newhypprot->strand !=  $orf->strand)
				{
					#+++++++++++BEFORE PUSHING AN HYP PROT, CHECK+++++++++++++++++++++
					if ($newhypprot->remark eq "")				#	++
					{							#	++	
						my $exons = $newhypprot->exons;			#	++
						my $startexons = [];				#	++
						foreach my $exon (@$exons)			#	++
						{						#	++
							push (@$startexons, $exon->start);	#	++	
						}						#	++
						if (IsSameFrame($startexons) ==- 1)	#	++
						{						#	++
							$newhypprot->set_remark ("One Reading Frame but HSP not in the same frame. Protein may have introns, or sequencing errors");	#	++
						} else 						#	++
						{						#	++	
							$newhypprot->set_remark ("One Reading Frame and all HSP are in the same frame=>probably no introns");				#	++
						}						#	++
					}							#	++	
					push (@$HYPPROTS,  $newhypprot);			#	++
					#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
					
			
					$newhypprot = new PirObject::HypProt (name       => $name,
									      contigname => $contigname,
									      start      => $orf->start,
									      end        => $orf->end,
								              strand     => $orf->strand,
									      exons      => [],
									      numorfs    => 1,
									      remark     => ""	 
									 );
					my $exons = $newhypprot->exons;
					my $hsps = $orf->hsps;
					foreach my $hsp_exon (@$hsps)
					{
						my $exonstart = ($orf->strand == 1 ? $orf->start + $hsp_exon->start : $orf->start - $hsp_exon->start);
						my $exonend = ($orf->strand == 1 ? $orf->start + $hsp_exon->end : $orf->start - $hsp_exon->end);
					
						my $exon = new PirObject::Exon (start  => $exonstart, 
										end    => $exonend,
										strand => $orf->strand
										);
						push (@$exons, $exon);
					}				 
									 
					next ORF;
				}
				
				#print "On arrive desfois ici \n";
				
				#------------	case	 3-4 : Check space between 2 ORFs, including overlapping
				if ($orf->strand == 1)	#	Two case : right strand or opposite strand
				{
					#print "Mais on rentre la qd meme $name\n"; 
					if (($newhypprot->end > $orf->start) or (abs ($orf->start - $newhypprot->end) < $MAXLENGTHFORGROUPINGORF)) {
						#print "On rentre la dedans un jour $name\n"; 
						my $newstart = ($orf->start < $newhypprot->start ? $orf->start : $newhypprot->start);
						my $newend = ($orf->end > $newhypprot->end ? $orf->end : $newhypprot->end); 
					
						$newhypprot->set_start ($newstart);
						$newhypprot->set_end ($newend);
						$newhypprot->set_remark("Many ORFs. These proteins seems to have introns or sequencing problems");
						# increase from 1, the number of orf, if we concatenate
						my $numorfs = $newhypprot->numorfs;
						$numorfs ++;
						$newhypprot->set_numorfs($numorfs);
					
						my $exons = $newhypprot->exons;
						my $hsps = $orf->hsps;
						foreach my $hsp_exon (@$hsps)
						{
							my $exonstart = ($orf->strand == 1 ? $orf->start + $hsp_exon->start : $orf->start - $hsp_exon->start);
							my $exonend = ($orf->strand == 1 ? $orf->start + $hsp_exon->end : $orf->start - $hsp_exon->end);
						
							my $exon = new PirObject::Exon (start  => $exonstart, 
											end    => $exonend,
											strand => $orf->strand
											);
							push (@$exons, $exon);
						}				 
										
						next;
					}
					else {
						#+++++++++++++++++++CHECK AND PUSH++++++++++++++++++++++++++++++++
						if ($newhypprot->remark eq "")				#	++
						{							#	++	
							my $exons = $newhypprot->exons;			#	++
							my $startexons = [];				#	++
							foreach my $exon (@$exons)			#	++
							{						#	++
								push (@$startexons, $exon->start);	#	++	
							}						#	++
							if (IsSameFrame($startexons) ==- 1)	#	++
							{						#	++
								$newhypprot->set_remark ("One Reading Frame but HSP not in the same frame. Protein may have introns, or sequencing errors");	#	++
							} else 						#	++
							{						#	++	
								$newhypprot->set_remark ("One Reading Frame and all HSP are in the same frame=>probably no introns");				#	++
							}						#	++
						}							#	++	
						push (@$HYPPROTS,  $newhypprot);			#	++
						#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
						$newhypprot = new PirObject::HypProt (name       => $name,
									      contigname => $contigname,
									      start      => $orf->start,
									      end        => $orf->end,
								              strand     => $orf->strand,
									      exons      => [],
									      numorfs    => 1,
									      remark     => ""	 
									 );
						my $exons = $newhypprot->exons;
						my $hsps = $orf->hsps;
						foreach my $hsp_exon (@$hsps)
						{
							my $exonstart = ($orf->strand == 1 ? $orf->start + $hsp_exon->start : $orf->start - $hsp_exon->start);
							my $exonend = ($orf->strand == 1 ? $orf->start + $hsp_exon->end : $orf->start - $hsp_exon->end);
						
							my $exon = new PirObject::Exon (start  => $exonstart, 
											end    => $exonend,
											strand => $orf->strand
											);
							push (@$exons, $exon);
						}				 
										
						next;	
					}
				}	
				else {			#	Opposite strand
				
				       #print "test avec ", $newhypprot->name, "\n";
				
					if (($newhypprot->start > $orf->end) or (abs ($orf->end - $newhypprot->start) < $MAXLENGTHFORGROUPINGORF)) {
						my $newstart = ($orf->start > $newhypprot->start ? $orf->start : $newhypprot->start);
						my $newend = ($orf->end < $newhypprot->end ? $orf->end : $newhypprot->end); 
					
						$newhypprot->set_start ($newstart);
						$newhypprot->set_end ($newend);
						$newhypprot->set_remark("Many ORFs. These proteins seems to have introns or sequencing problems");
					        
						# Add 1 to the number of orf if there is concatenation
						my $numorfs = $newhypprot->numorfs;
						$numorfs ++;
						$newhypprot->set_numorfs($numorfs);
						
						my $exons = $newhypprot->exons;
						my $hsps = $orf->hsps;
						foreach my $hsp_exon (@$hsps)
						{
							my $exonstart = ($orf->strand == 1 ? $orf->start + $hsp_exon->start : $orf->start - $hsp_exon->start);
							my $exonend = ($orf->strand == 1 ? $orf->start + $hsp_exon->end : $orf->start - $hsp_exon->end);
						
							my $exon = new PirObject::Exon (start  => $exonstart, 
											end    => $exonend,
											strand => $orf->strand
											);
							push (@$exons, $exon);
						}				 
										
						next;
					}
					else {
						#+++++++++++++++++++CHECK AND PUSH++++++++++++++++++++++++++++++++
						if ($newhypprot->remark eq "")				#	++
						{							#	++	
							my $exons = $newhypprot->exons;			#	++
							my $startexons = [];				#	++
							foreach my $exon (@$exons)			#	++
							{						#	++
								push (@$startexons, $exon->start);	#	++	
							}						#	++
							if (IsSameFrame($startexons) ==- 1)	#	++
							{						#	++
								$newhypprot->set_remark ("One Reading Frame but HSP not in the same frame. Protein may have introns, or sequencing errors");	#	++
							} else 						#	++
							{						#	++	
								$newhypprot->set_remark ("One Reading Frame and all HSP are in the same frame=>probably no introns");				#	++
							}						#	++
						}							#	++	
						push (@$HYPPROTS,  $newhypprot);			#	++
						#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
						$newhypprot = new PirObject::HypProt (name       => $name,
									      contigname => $contigname,
									      start      => $orf->start,
									      end        => $orf->end,
								              strand     => $orf->strand,
									      exons      => [],
									      numorfs    => 1,
									      remark     => ""	 
									 );
						my $exons = $newhypprot->exons;
						my $hsps = $orf->hsps;
						foreach my $hsp_exon (@$hsps)
						{
							my $exonstart = ($orf->strand == 1 ? $orf->start + $hsp_exon->start : $orf->start - $hsp_exon->start);
							my $exonend = ($orf->strand == 1 ? $orf->start + $hsp_exon->end : $orf->start - $hsp_exon->end);
						
							my $exon = new PirObject::Exon (start  => $exonstart, 
											end    => $exonend,
											strand => $orf->strand
											);
							push (@$exons, $exon);
						}				 
										
						next;	
					}
				
				
				}	
			}	#	End of foreach ORFs
			
			#+++++++++++++++++++CHECK AND PUSH++++++++++++++++++++++++++++++++
			if ($newhypprot->remark eq "")				#	++
			{							#	++	
				my $exons = $newhypprot->exons;			#	++
				my $startexons = [];				#	++
				foreach my $exon (@$exons)			#	++
				{						#	++
					push (@$startexons, $exon->start);	#	++	
				}						#	++
				if (IsSameFrame($startexons) ==- 1)	#	++
				{						#	++
					$newhypprot->set_remark ("One Reading Frame but HSP not in the same frame. Protein may have introns, or sequencing errors");	#	++
				} else 						#	++
				{						#	++	
					$newhypprot->set_remark ("One Reading Frame and all HSP are in the same frame=>probably no introns");				#	++
				}						#	++
			}							#	++	
			push (@$HYPPROTS,  $newhypprot);			#	++
			#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
			
		}	#	End of case you have many ORFS	
	}	#	End for each flipblastprot									
}	#	End function

sub IsSameFrame {	#	Check if the positions in the array are on the same frame

	my $tab = shift;	#	It's an array reference
	
	if (scalar (@$tab) <= 1) { # if there is one or less, it's on the same frame
	    return 1;
	}
	my $frame = @$tab[0] % 3;
	foreach (@$tab)
	{
		if (($_ % 3) ==  $frame) {
			next;	#	If it's still the same frame continue
		}
		else {
			return -1;	
		}
	}
	
	return 1;
}

sub IsSameStrand {	#	Check if the data in the array are on the same strand

	my $tab = shift;	#	It's an array reference
	
	my $strand = @$tab[0];
	foreach (@$tab)
	{
		if ($ ==  $strand) {
			next;	#	If it's still the same frame continue
		}
		else {
			return -1;	
		}
	}
	
	return 1;
}
		

sub GetFlipBlastProtByNAmeAndContigName {	
				# 	this function gives a FlipBlastProt with his name and contig name
	my $name = shift;	#	This the name of the GetFlipBlastProt
	my $contigname = shift;	#	This is the contigname of the FlipBlastProt
	
	foreach (@$FLIPBLASTPROTS) {
		if ($_->name eq $name and $_->contigname eq $contigname) {
			return $_;
		}
	}
	
	return undef;		# 	in the case where any object has been found
	
}


sub ParseCommandLineOptions {
    my $config = shift; # A PirObject::MfAnnotConfig
    my $argv = shift;

    $config->SetCurrentConfigToAllUnset();
    my $inputs = PirObject::MfAnnotConfig->InputFiles();

    my $concatswitches = "";
    my %switch2key = ();
    for (my $n=0;$n<@$inputs;$n+=3) {
        my ($switch,$key,$desc) = @$inputs[$n,$n+1,$n+2]; # array slice
        $switch2key{$switch}=$key;
        $concatswitches .= $switch;
    }

    for (;@$argv;) {
        my ($opt,$arg) = ($argv->[0] =~ /^-([\@agtf$concatswitches])(.*)$/o);
        last if ! defined $opt;
        if ($opt =~ /[gt$concatswitches]/ && $arg eq "") {
            if (@$argv < 2) {
                print "Argument required for option \"$opt\".\n";
                exit 1;
            }
            shift @$argv;
            $arg=$argv->[0];
        }

        $DEBUG=($arg ? $arg : 1)                     if $opt eq '@';
        $AUTOMATIC=1                                 if $opt eq 'a';
        $GENCODE=$arg                                if $opt eq 'g';
        $TAGNAME=$arg                                if $opt eq 't';
        $FORCEANNOT=1                                if $opt eq 'f';

        if ($switch2key{$opt}) {
            my $key = $switch2key{$opt};
            $config->StoreConfigValue($key,$arg);
        }

        shift @$argv;
    }
}




sub AddGeneFeatureUsingtRNAscanSE {

	#Description of the sub
	#1st : put the dna sequence into a temporary fastafile
	#2nd : run tRNAscanSE with the temporary fasta file  
	#3rd : parse the blast output
	#4th : annotate with the output
	
	#1st : put the dna sequence into a temporary fastafile
	
	my $pirmaster   = shift;			#get the masterfile object
	my $contigs = [];				#create a reference to a config file
	my $tag = shift;		
	
	$contigs = $pirmaster->get_contigs();		#get the masterfiles contigs
	
	my $contig=undef;                          # An array containing all the contig name
	my $countcontig = 1;
	
	foreach $contig (@$contigs)			#parse all the contig
	{
		my $name=$contig->get_name();		#get the name for the contig
		my $seq=$contig->get_sequence();	#get the sequence for each contig
		
		$seq =~ s/[^atcgATCG]//g;
		
		#2nd : run tRNAscanSE with the temporary fasta file
		
		my $fastatmp = "$TMPDIR/fasta.tmp";	#temporary fasta file
		#my $outputtrnascansetmp = "$TMPDIR/tRNAscanSEoutput.tmp";	#tRNAscanSE output temporary file
		my $outputtrnascansetmp = "cetRNAnouvscanSEoutputamacr.tmp";	#tRNAscanSE output temporary file
		
		 
		open (FASTATMP, ">$fastatmp")
		or die "can't open fasta tmp file\n";	      #put into a temporary fasta file	
		print FASTATMP ">contig$countcontig\n$seq";   #put the sequence into the temporary file with fasta format
		close FASTATMP;				      #close the temporary file	
	
		
		#2nd : run tRNAscanSE with the temporary fasta file
		if (! -r "$fastatmp")
		{
			die "
			can't open fasta tmp file\n";
			
		}

		#my $tRNAscanSEcmd = "tRNAscan-SE -O -o $outputtrnascansetmp $fastatmp  > $TMPDIR/tRNAscanSE.output 2>&1";
		my $tRNAscanSEcmd = "tRNAscan-SE -O -o $outputtrnascansetmp $fastatmp";
		print "$tRNAscanSEcmd\n" if $DEBUG;
		my $restRNAscanSE = system ($tRNAscanSEcmd);	#-O for searching tRNA in organellar
                                                                #-C for unsing coves
                                                                #-o to write the result in a output file	
		my $parser = new PirObject::tRNAscanSEparser;					#Open the parser for tRNAscanSE
		$parser->loadObjectfromFile("$outputtrnascansetmp");				#Parse the file with the file and fill the object
		
		my @annotat = $parser->get_annotations;
		
		my $table = $parser->get_annotations; #this is a reference to an array
		
		
		TRNA : foreach (@$table)	#Correspond to the tRNAscanSE annotation 
		{								

			my $start;
			my $end;
			my $arrow = ($_->get_begin > $_->get_end ? "<=="   : "==>");
			
			if ($arrow eq "==>") {			
				$start = ($_->get_begin > $_->get_end ? $_->get_end   : $_->get_begin);
				$end =   ($_->get_begin > $_->get_end ? $_->get_begin : $_->get_end);
			}
			else {			
				$start = ($_->get_begin > $_->get_end ? $_->get_begin : $_->get_end);
				$end =   ($_->get_begin > $_->get_end ? $_->get_end : $_->get_begin);
			}		
			
			my $type = $_->get_type;
			my $acodon = $_->get_anti_codon;
			my $score = $_->get_score;
			if ($score < $TRNACUTOFF) {         # if hte score value is under the tRNA cutoff
			                                    # go to the next tRNA
			    next TRNA;
			}
			
			my %CodonTable = Bio::SeqUtils->valid_aa(2);			#get the amino acide code
			
			my $aaSymbol= uc(substr($type, 0, 1)).lc(substr($type, 1, 2));	#case treatment
			if ($aaSymbol = $CodonTable{$type})				#change the amino acid in one to 3 letter
			{}
			else {$aaSymbol=$type;}
			
			
			#----- Create annotation -----#
			chomp ($aaSymbol) if (defined $aaSymbol);
			my $genename = "trn$aaSymbol";
										
			my $annot = new PirObject::AnnotPair (
              			type      => "G", 
				genename  => "$genename",                     # Before : genename  => "tRNA-$type($acodon)",
                        	startpos  => $start,
                        	endpos    => $end,
                        	direction => $arrow,
               
                    	);
			
			my $number = $ANNOTSEEN->{$annot->genename} || 0;
			my $arnname = $genename;
			
			$number += 1;
			if ($number > 1)
			{ 
			    $arnname .= "_$number";
			}
			
			$acodon =~ tr/UTCGAutcga/uucgauucga/;
			$arnname .= "($acodon)";
			my $startline = ";     G-$arnname $arrow start";
			$startline .= " ;; MFFEAT=$tag score=$score" if $ADDCOMMENTS;
			my $endline = ";     G-$arnname $arrow end";
			$endline .= " ;; MFFEAT=$tag" if $ADDCOMMENTS;
			$annot->set_startline ($startline);
			$annot->set_endline ($endline);
		
        		&AddAnnotToPirMaster($pirmaster,$name,$annot);

			
			
		} # end of each trna
	
	$countcontig ++;    
		
	} # each contig	
	
}



my $GeneNameToAnnot_Cache = undef;  # just a hash used for efficiency

sub AddAnnotToPirMaster {

    #### MEANING CODE FOR THIS FUNCTION
    #### return 1 means ok, it has been added
    #### return 0 means function quit before the end, => rediscovered 
   
    my $pirmaster  = shift;
    my $contigname = shift;
    my $annot      = shift;
    my $contig = $pirmaster->GetContigByName($contigname) || die "Can't get contig by name\n";
    my $annotations = $contig->get_annotations;
    
     
    # Here we compare all the annotations, with the one we try to add 
    ANNOTATION : foreach my $annotation (@$annotations){
        my $annotname = $annotation->genename;
	my $annottype = $annotation->type || "C";
	my $annotstart = $annotation->startpos;
	my $annotend = $annotation->endpos;
	$annotname = "comment" if (!defined  $annotname);
	$annotstart = -1 if (!defined  $annotstart);
	$annotend = -1 if (!defined  $annotend);
	
	
	##--First case : if both are same comment on the same line 
	if (($annottype eq "C") && ($annot->type eq "C") && ($annot->startpos == $annotstart) && $annot->startline eq $annotation->startline) {
	    #Nothing is done in this case,
	    #print "On est bien dans ce cas\n";
	    return 0;
	}
	
	##--Second case : No comment, both have same start end, and genename;
	#print "ca c le name : $annotname ",  $annot->genename, "\n";
	if (($annottype ne "C") && ($annotname eq $annot->genename) && ($annotstart == $annot->startpos) && ($annotend == $annot->endpos)) {
            $ANNOT_STATS->{'Rediscovered'}->{$annot->genename} ||= {   'I' => 0, 'E' => 0, };
	    return 0;
	}
	
	##--Third case : Exons
	if ($annot->type eq "E") { # it's an exon. The protein has normally already been added
	    if (defined ($annot->genename)) {
	        $ANNOT_STATS->{'Added'}->{$annot->genename}->{'E'} ++;
	    }
	    push (@$annotations, $annot);
	    return 1;
	}	
		
    }
    
    if ($FORCEANNOT) {       #   If Force annot, you can add a new one 
        $ANNOT_STATS->{'Added'}->{$annot->genename} ||= {  'I' => 0, 'E' => 0, } if ($annot->genename ne "comment");
        push (@$annotations, $annot);
	$ANNOTSEEN->{$annot->genename} += 1;
	return 1;
    }
    else {                       #   If force annot does not exist
    
        if ($annot->type eq "C") {
	    push (@$annotations, $annot);
	    return 1;
	}
    
	if (defined $ANNOTSEEN->{$annot->genename}) {     #  It mean,, this annotation has already been seen
            $ANNOT_STATS->{'Rediscovered'}->{$annot->genename} ||= {  'I' => 0, 'E' => 0, } if ($annot->genename ne "comment");
	    return 0;
            #$ANNOTSEEN->{$annot->genename} = 'defined';
	}
	else {                                            #  It means, force annot but this annotations doesn't seems to have an other copy    
 	    $ANNOT_STATS->{'Added'}->{$annot->genename} ||= {  'I' => 0, 'E' => 0, } if ($annot->genename ne "comment");
            $ANNOTSEEN->{$annot->genename} += 1;    
	    push (@$annotations, $annot);
	    return 1;
	}
    }    #    end of if forceannot .......
    
}


sub LogInfo {
    my $pirmaster = shift;
    my $header = $pirmaster->header() || [];

    my @report = ();
    my $added  = $ANNOT_STATS->{'Added'};
    my $redisc = $ANNOT_STATS->{'Rediscovered'};

    my @added  = sort keys %$added;
    my @redisc = sort keys %$redisc;

    push(@report,
        ";;    - Gene Totals: " . scalar(@added) . " added; " . scalar(@redisc) . " rediscovered.",
    );

    push(@report,
        ";;    - List of genes added:",
    ) if @added;

    #foreach my $genename (@added) {
    #    my ($e,$i) = ($added->{$genename}->{'E'},$added->{$genename}->{'I'});
    #    push(@report,
    #    ";;        $genename" . ($e > 1 ? " ($e exons)" : ""),
    #    );
    #}

    my $COLS=3;
    my $cnt=0;
    my $rep = "";
    print "Added : ", scalar(@added), "\n" if $DEBUG;
    print LOGFILE "Added : ", scalar(@added), "\n" if $ISLOGFILE;
    foreach my $genename (@added) {
        my ($e,$i) = ($added->{$genename}->{'E'},$added->{$genename}->{'I'});
        $rep = ";;     " if !$cnt;
        $rep .= sprintf(" %-20s", ("$genename" . ($e > 1 ? " ($e exons)" : "")));
        $cnt++;
        if ($cnt >= $COLS) {
            push(@report, $rep);
            $cnt=0;
        }
    }
    push(@report, $rep) if $cnt;

    push(@report,
        ";;    - List of genes rediscovered:",
    ) if @redisc;

    $cnt=0;
    $rep = "";
    print "Rediscovered : ", scalar(@redisc), "\n" if $DEBUG;
    print LOGFILE "Rediscovered : ", scalar(@redisc), "\n" if $ISLOGFILE;
    foreach my $genename (@redisc) {
        my ($e,$i) = ($redisc->{$genename}->{'E'},$redisc->{$genename}->{'I'});
        $rep = ";;     " if !$cnt;
        $rep .= sprintf(" %-20s", ("$genename" . ($e > 1 ? " ($e exons)" : "")));
        $cnt++;
        if ($cnt >= $COLS) {
            push(@report, $rep);
            $cnt=0;
        }
    }
    push(@report, $rep) if $cnt;

     
    push(@$header,
        ";; Masterfile modified automatically by $BASENAME version $VERSION");
    push (@$header,
        ";;    - New annotations labeled with: MFFEAT=$TAGNAME") if $ADDCOMMENTS;  # we only put this sentence if option addcomments is activated
    push (@$header,    
        @report,
        ";;",
    );

    $pirmaster->set_header($header);
}

END {              # With exit, programm will go here
                   # Cleanup temp directory when program exits.

    return unless defined($TMPDIR) && $TMPDIR =~ m#^/tmp/#;
    #if (defined($DEBUG) && $DEBUG > 0) {
    #    print STDERR "Debug mode warning: temporary work directory '$TMPDIR' not cleaned up.\n";
    #    return;
    #}
    
    print "temporary work directory $TMPDIR cleaned up ...\n" if $DEBUG; 
    system("/bin/rm","-rf",$TMPDIR) if -d $TMPDIR;           # r for recursive and f for for force
    system("/bin/rmdir",$TMPDIR) if -d $TMPDIR;              # delete tmp directory
    
}

# End Of File. Or is it? What's beyond? Maybe the lost characters of all the sentences that were trunca
