#!/usr/bin/perl -w -- -*-Perl-*-

##############################################################################
#
#                                 mfannot.pl
#
# DESCRIPTION:
# Attempts to do a quick first pass at annotating a masterfile
# with meaningfull start/stop lines by calling blast on collections
# of known genes. Manual intervention is still required to check/adjust
# the new annotations.
#
# Known issues: - Annotations for START/STOP introns are interleaved (they
#                 are at the correct position, though).
#
##############################################################################

#############################################################################
#                                 MFANNOT                                   #
#                                                                           #
#                          Copyright (C) 2008                               #
#                         Departement de Biochimie,                         #
#                          Universite de Montreal,                          #
#                     C.P. 6128, succursale Centre-ville,                   #
#                      Montreal, Quebec, Canada, H3C 2J7                    #
#                                                                           #
#                       Programming:  Natacha Beck, Pierre Rioux,           #
#                                     David To, Thomas Hoellinger.          #
#                Project management: Franz Lang (OGMP)                      #
#                E-Mail information: Franz.Lang@Umontreal.ca                #
#                                                                           #
#     This software is distributed under the GNU GENERAL PUBLIC LICENSE, as #
# published by the Free Software Foundation. A copy of version 2 of this    #
# license should be included in a file called COPYING. If not, write to the #
# Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.   #
#############################################################################
#
#    $Id: mfannot,v 2.23 2009/02/17 20:33:30 nbeck Exp $
#
#    $Log: mfannot,v $
#    Revision 2.23  2009/02/17 20:33:30  nbeck
#    Checked format of the Masterfile.
#    Checked the existence of the directory for HMMweasel models.
#    Improved the definition of homologous.
#    Removed multicomments and simplified comments.
#
#    Revision 2.22  2009/02/06 21:46:44  nbeck
#    Added option -F F to blast.
#
#    Revision 2.21  2009/02/06 21:17:02  nbeck
#    Replaced ClustalW by Muscle.
#    Changed method to define gene start.
#    Changed method to annote gene fusion.
#    Remove useless option and changed option for blast.
#
#    Revision 2.20  2008/12/23 21:48:02  nbeck
#    *** empty log message ***
#
#    Revision 2.19  2008/10/10 21:10:17  nbeck
#    Fixed bug for usage of clustalW
#
#    Revision 2.18  2008/10/03 22:12:28  riouxp
#    Added de-escaping of certain XML entities (apos and quot) when
#    looking up protein sequences from library.
#
#    Revision 2.17  2008/09/19 21:31:14  nbeck
#    Fixed annotation of genes with introns
#
#    Revision 2.16  2008/09/13 19:06:19  riouxp
#    Added date, time, user and hostname in masterfile header.
#
#    Revision 2.15  2008/09/12 19:51:47  nbeck
#    Added support for fusioned genes.
#
#    Revision 2.14  2008/09/12 18:33:10  riouxp
#    Changed field "score" to "evalue" in many PirObjects. Made
#    sure CompareHighPrecisionFloats() is used for evalue comparisons.
#
#    Revision 2.13  2008/09/10 22:13:16  riouxp
#    Re-engineered the Blast Output parsing code; we now generate
#    the blast reports in XML and use PirObject::BlastOutput as
#    our model class instead of Bio::SearchIO. This improves efficiency
#    by 4x ! Also, the internal routine to extract protein sequences
#    from the library has been redesigned such that the sequences
#    are cached in memory in the first place.
#
#    Revision 2.12  2008/09/09 20:30:36  nbeck
#    Added a comment when a gene presents a frameshift and skipped research of
#    mini-exons for this case.
#
#    Revision 2.11  2008/09/09 16:49:59  nbeck
#    Added option in order to annote partial or incomplete genome.
#
#    Revision 2.10  2008/09/08 22:26:36  riouxp
#    Properly ignores empty exonerate outputs.
#
#    Revision 2.9  2008/09/08 22:17:39  riouxp
#    Real defensive code added.
#
#    Revision 2.8  2008/09/08 22:06:29  riouxp
#    Defnesive programming when exonerate doesn't produce a report.
#
#    Revision 2.7  2008/09/03 15:51:20  riouxp
#    Adjusted routine that compares high precision floats.
#
#    Revision 2.6  2008/08/29 19:11:50  nbeck
#    Added step to adjust gene starts position.
#    Changed default parameters for Blast.
#    Added step to check the validity of Multicomments.
#
#    Revision 2.5  2008/08/18 20:57:54  riouxp
#    Fixed bug with renumbering of gene sequences.
#
#    Revision 2.4  2008/08/18 18:34:59  nbeck
#    Fixed annotation of intronic ORFs.
#
#    Revision 2.3  2008/08/14 20:27:29  nbeck
#    Fixed adjustement of gene starts.
#
#    Revision 2.2  2008/08/13 21:36:32  nbeck
#    Fixed problem with intron type annotation.
#
#    Revision 2.1  2008/08/13 21:12:40  nbeck
#    Added identification of mini Exons.
#    Adjusted start position for gene identified by Exonerate.
#    Changed default parameters for Exonerate.
#
#    Revision 2.0  2008/06/27 18:35:14  nbeck
#    Adjusted the nucleotidic scores for defining the intron/exon boundaries.
#    Cleaned the code :
#        - Revised the indentation.
#        - Added comments in order to get the code more readable.
#        - Removed subroutines and options no longer used.
#        - Reordered all subroutines.
#        - Revision number bumped to 2.0 !
#
#    Revision 1.96  2008/06/03 20:16:37  nbeck
#    Add step to adjust exon/intron junction according to splice site models.
#
#    Revision 1.95  2008/05/01 15:54:22  riouxp
#    Modularized subroutine for launching external programs.
#
#    Revision 1.94  2008/04/25 17:01:40  riouxp
#    Added better handling of keyword 'none' for -ext_select.
#
#    Revision 1.93  2008/04/23 20:07:33  riouxp
#    Improved API between external commands and mfannot.
#
#    Revision 1.92  2008/03/20 21:04:56  nbeck
#    Cleaned old code.
#
#    Revision 1.91  2008/03/20 20:20:20  riouxp
#    Fixed tiny bug in support of multiple GeneNames args.
#
#    Revision 1.90  2008/03/20 20:10:32  riouxp
#    Added support for multiple genenames supplied on the GeneName
#    directive of the external programs configuration file. The
#    directive can now also be rewritten as "GeneNames" (with an S).
#
#    Revision 1.89  2008/03/19 21:49:58  riouxp
#    Added ability to run external programs in multiple distinct blocks
#    of commands, where the first one that returns a useful result is
#    taken. This required extending the format of the external programs
#    config file, and adjusting its parser and execution methods.
#
#    Revision 1.88  2008/03/18 21:40:47  nbeck
#    Add annotation of Intron using external programs.
#    Fixed bug for annotation of ORF.
#
#    Revision 1.87  2008/03/06 20:59:09  nbeck
#    Adding an option to choose which external programs to run.
#
#    Revision 1.86  2008/03/04 19:47:26  nbeck
#    Fixed bug : set a default value for evalue in subroutine ChoiceORF.
#
#    Revision 1.85  2008/03/03 16:56:26  nbeck
#    Fixed protein name for exonerate.
#
#    Revision 1.84  2008/02/27 21:26:19  nbeck
#    Improved mechanism for executing external programs (API).
#
#    Revision 1.83  2008/02/26 20:12:00  riouxp
#    Made endpos optional for AnnotPairs returned by external programs.
#
#    Revision 1.82  2008/02/22 21:26:47  riouxp
#    Added ability to trust the fields of the AnnotPairs obtained
#    from an AnnotPairCollection generated by external programs.
#    Default is still to recreate fields as needed.
#
#    Revision 1.81  2007/08/10 19:37:20  nbeck
#    Added support for calling external analasys programs
#
#    Revision 1.80  2007/07/26 19:28:53  nbeck
#    fixed bug for Exonerate

##########################
# Initialization section #
##########################

require 5.00;
use strict;
use vars qw( $VERSION $RCS_VERSION );
use IO::File;
use IO::Dir;
use Cwd;
use File::Basename;
use File::Path;
use PirObject;                                        # Pir module treatment 
use Bio::AlignIO;                                     # Bioperl (used for parsing alignement)
use Bio::SeqUtils;                                    # Some biological tools
use Bio::Tools::CodonTable;                           # To create a codon table, to be used with genewise
use Bio::Matrix::IO;                                  # Used for read matrix like PAM
use List::Util qw(max);
use List::Util qw(min);
use File::Copy;
use Sys::Hostname;

BEGIN {
# Load PirObject
PirObject->LoadDataModel("Masterfile");               # Masterfile object
PirObject->LoadDataModel("MfAnnotExternalProgs");     # Support for execution of external programs
PirObject->LoadDataModel("AnnotPairCollection");      # Also for external programs.
PirObject->LoadDataModel("ExonerateOutput");          # Parser for Exonerate output
PirObject->LoadDataModel("FlipBlastProt");            # Objects for storing ORFs predicted by Flip and kept with blast
PirObject->LoadDataModel("HypProt");                  # Hypothetical protein : We believe its a protein after flip, blast an
                                                      # organization of the results
PirObject->LoadDataModel("HypFusion");                # Contain information about gene fusion                                      
PirObject->LoadDataModel("Option");                   # A module for options gestion
PirObject->LoadDataModel("EmptyOrf");                 # Object containing Orfs having no corresponding genes
PirObject->LoadDataModel("BlastOutput");              # Model of blast results in XML (blastall -m 7)
} # End Begin

# Default umask
umask 027;

# Program's name and version number.
$RCS_VERSION='$Id: mfannot,v 2.23 2009/02/17 20:33:30 nbeck Exp $';
($VERSION) = ($RCS_VERSION =~ m#,v ([\w\.]+)#);
my ($BASENAME) = ($0 =~ /([^\/]+)$/);

# Get login name
my $USER = getpwuid($<) or getlogin or die "Can't find USER from environment!\n";

##################################
# Global variables and constants #
##################################

# Command-line args (first, original program)
my $TAGNAME          = undef;                   # Tag : is present in masterfile within the annotations made with Mfannot
my $FORCEANNOT       = 0;
my $ANNOT_STATS      = {
                         'Added'        => {},  # It means, never see it before
                         'Rediscovered' => {},  # Means exist at the same place (not added into the file)
                       };
my $EMPTYORFS;                                  # An array containing, EmptyOrf object. It means ORFs having
                                                # no corresponding genes
my %PENAMEDISPLAY;                              # An hash array, containing the name to display, associate with peplibraries and pepfiles

# General options
my $DEBUG;                                      # Debug mode. If true, display message on the screen
my $GENCODE          = undef;                   # Genetique code
my $TMPDIR           = "/tmp/mfannot.$$";       # Temporary directory
my $LOG_FILE;                                    # Log file : store all the information about run
my $SIMILARITYSEARCH;                           # Usefull for running similaritie gene process for annot.
my $ISLOGFILE        = 0;                       # Just to know if the $LOG_FILE is not empty (0 or 1)
my $MASTERFILE       = undef;                   # Path for Masterfile
my $PEPFILE;                                    # Path for the peptide file used
my $CACHE_PEPLIBRARY = {};                      # Cache of all proteins in library
my $TAKEINPUTFILE;
my $FLIPBLASTPROTS;                             # Array containing the Proteins predicted by Blast and Flip
my @PROT_FOR_EXONERATE;                         # Array with homolog protein for Exonerate
my $HYPPROTS;                                   # Array containing the Proteins predicted by Blast and Flip and reprocessed after
my $OUTPUTFILE;                                 # Path for the new
my $ORFPROCESS;                                 # Allows ORF appearing in the masterfile as annotations
my $LOADSTRICT;                                 # Load strict Masterfile
my $ADDCOMMENTS;                                # Add comments into masterfile (0 or 1) as mfeat=.....
my $CHECKORFS;                                  # Say if yes or not have to check for orf, if no all orfs appears in mf
my $PEPLIBRARIES;                               # The libraries, in input, by default datagenescollection and dataorfcollection
my $INPUTPEPFILES;                              # The input files
my @PEPFILES;                                   # The pepfiles, used in the programm. They come from $PEPLIBRARIES and $INPUTPEPFILES
my $SIZE;                                       # The sensitivite of warning for the long protein, it's a percentage
my $EXTCONFIGFILE;                              # The path for configuration file, it's use for annotation of rnpB, rnl and rns;
my $EXTSELECTPROG;                              # List of name for external programs.
my $ALL_INTRONS;                                # Indicate if all introns detected by RNAweasel must be annotated
my $BLASTOUTPUT       = "";                     # The path for blast file results
my $BLASTEVALUECUTOFF;                          # Cutoff value for the blast
my $MINLENGTHORF;                               # This is the minimum length for creating an ORF with flip
my $MAXLENGTHFORGROUPINGORF;                    # Minimum size of a gap between 2 ORf. If 2 same ORF
my $MAXLENINTRONS;                              # Max intron size for exonerate.
my $MINLENEMPTYORF;                             # Minimum length for ORF empty orfs (non corresponding orfs)
my $OVERLAPPINGCUTOFF;                          # Overlapping cutoff for ORFs
my $MININTRONSIZE;                              # Opposite of MAXLENGTHFORGROUPINGORF. Minimum size for intron
my $MINEXONSIZE;                                # Minimum exon size for intron. In genewise.
my $MATRIX;                                     # The matrix used in genewise alignement
my $CODON_TABLE;                                # Hashtable with genetic code
my $NBCONTIGS        = 0;                       # The number of contigs
my $PARTIAL;                                    # This will cause mfannot to only run a subset of all its built-in analysis

# Two booleans used in order to know if annotation of introns has been made
my ($annotate_intron_typeI,$annotate_intron_typeII)  = (0,0);

# Command line Program's paths
my $PATH = $ENV{"PATH"} || "";
my @PATH = split(/:/, $PATH);

my $HOME                    = $ENV{"HOME"};
my $BLASTPATH               = &GetPath("blastall");#"$h/blast-2.2.18/bin/blastall";#"$h/blast-2.2.18/bin/blastall";
my $FORMATDBPATH            = &GetPath("formatdb");
my $FLIPPATH                = &GetPath("flip");
my $EXONERATEPATH           = &GetPath("exonerate");
my $MUSCLEPATH              = &GetPath("muscle");
my $HWCOMBINERPATH          = &GetPath("HWcombiner");
my $POTRES2APCOLPATH        = &GetPath("PotRes2APCol");
my $TRNA_RES2APCOLPATH      = &GetPath("tRNA_res2APcol");
my $INTRONIC_RES2APCOLPATH  = &GetPath("Intronic_res2APcol");
my $RNAWEASEL_RES2APCOLPATH = &GetPath("RNAweasel_res2APcol");

# First get option in order to check some variables.
&GetOptions ;     # Get the different options and put them into global variables

my $Exonerate_parameter = "--model protein2genome --showcigar T --useaatla F --showquerygff T --showtargetgff T --minintron 142 --maxintron $MAXLENINTRONS --intronpenalty -35 --nosplicesignal T"; 

# Models and lib path
my @MOD_PATH      = (
    # You can add other search directories here
    ($HOME || ".") . "/mfannot_models",
);

push(@MOD_PATH,split(/:/,$ENV{"MFANNOT_MOD_PATH"}))
    if $ENV{"MFANNOT_MOD_PATH"};
    
my $MODEL_PATH = "";
foreach my $path (@MOD_PATH) {
    next if !(-d $path);
    $MODEL_PATH = $path;
}

$MODEL_PATH =~ s/\/$//;
die "No path for ErpinModels and HMMweaselModels were found\n"
    if !$MODEL_PATH;

#---------------------------#
my @LIB_PATH      = (
# You can add other search directories here
($HOME || "."));

push(@LIB_PATH,split(/:/,$ENV{"MFANNOT_LIB_PATH"}))
    if $ENV{"MFANNOT_LIB_PATH"};

#Check for directory
my $intronic_lib    = "";
foreach my $dir (@LIB_PATH) {
    next if !( -e "$dir/intronic/intronic_orfs.pep" );
    $intronic_lib    = "$dir/intronic/intronic_orfs.pep";
    last;
}
die "No file was found for intronic orfs library\n"
     if !$intronic_lib;

die "Please make sure the BLASTMAT environment variable is set\n".
    "to point to a directory where the blast matrices are stored.\n"
    unless defined($ENV{"BLASTMAT"}) and (-d $ENV{"BLASTMAT"}) and (-f ($ENV{"BLASTMAT"} . "/PAM70"));

my $matrix_path = $ENV{"BLASTMAT"}."/PAM70";

# Check if ~/.HMMweasel.cache exist and create them if they doesn't
my $HMM_cache = "$HOME/.HMMweasel.cache";
unless(-d $HMM_cache){
    mkdir $HMM_cache or die "Cannot create '$HMM_cache'";
}

my $parser           = new Bio::Matrix::IO(-format => 'scoring',
                                           -file   => $matrix_path);
my $matrix           = $parser->next_matrix;

    
# Parameters that don't have (yet) options on the command-line
my $SHORT_HSPS_MIN_EVALUE = "1e-11";
my $MULTIORFS             = 1;         # Permit 2 annotations for an ORF, before it was an option


################
# Trap Signals #
################
$SIG{'INT'}  = \&SigCleanup;
$SIG{'TERM'} = \&SigCleanup;
$SIG{'HUP'}  = \&SigCleanup;
$SIG{'QUIT'} = \&SigCleanup;
$SIG{'PIPE'} = \&SigCleanup;
$SIG{'ALRM'} = \&SigCleanup;

###############################
#   M A I N   P R O G R A M   #
###############################

my $LOG_F = new IO::File ">$LOG_FILE" if $ISLOGFILE;
#----------HEADER PRINTED OUT----------------------------------------------------------
my $header = "\n".
             "######################################################################\n".
             "MFANNOT, ORGANELLAR GENOME ANNOTATION PROGRAM                         \n".
             "VERSION $VERSION                                                      \n".
             "Programmed by P. Rioux, T. Hoellinger, D. To and N. Beck              \n".
             "######################################################################\n\n";

print $header;
print $LOG_F "$header" if $ISLOGFILE;
my $add_text_in_header = "";

# OPTIONS OF THE PROGRAM #
my $options ="----------------------------------\n".
             "        General Options           \n".
             "----------------------------------\n";
$options .= "Masterfile used : $MASTERFILE\n";
$options .= "new Masterfile created : $OUTPUTFILE\n";
$options .= "Genetic code : $GENCODE\n";
$options .= "Tag for annotation : $TAGNAME\n" if $ADDCOMMENTS;
$options .= "Logfile : $LOG_FILE\n" if $ISLOGFILE;
$options .= "Add comments in Masterfile\n" if $ADDCOMMENTS;
$options .= "Usage of RNAweasel\n";
$options .= "Warning if the protein make +/- $SIZE percent of homologous protein\n";
$options .= "The Path of configfile is : $EXTCONFIGFILE\n";
$options .= "Look in the peptide library $PEPLIBRARIES\n";

print $LOG_F "$options" if $ISLOGFILE;           # Print options in the logfile
print $options if $DEBUG;                        # Print the options on the screen 

# CREATE THE TMPDIR #
mkdir($TMPDIR,0700) or die "Error: can't create work directory '$TMPDIR': $!\n";

# Initialization of $CODON_TABLE (Hashtable with genetic code)
my $BIOCODONTABLE   = Bio::Tools::CodonTable->new( -id => $GENCODE);
$CODON_TABLE        = &CacheCodonTableWithGeneticId ($BIOCODONTABLE);

# LIB CREATION #
die "'$PEPLIBRARIES' isn't a directory\n" 
    if (not -d $PEPLIBRARIES);
my $LIB_FILE                   = "$TMPDIR/library.pep";
   $CACHE_PEPLIBRARY           = &CreatePepfileWithLibrary($PEPLIBRARIES , $LIB_FILE);
   $PENAMEDISPLAY{"$LIB_FILE"} = $PEPLIBRARIES;     # Associate, the name of the library for each peplibraries
die "Unable to read '$LIB_FILE'\n" 
    if (not -r $LIB_FILE);

# ANNOTATION # 
# Print option of the annotation
print "----------------------------------\n",
      "         Gene Annotation          \n",
      "----------------------------------\n";
print $LOG_F  "----------------------------------\n",
              "         Gene Annotation          \n",
              "----------------------------------\n" if $ISLOGFILE;


$options  = "Options : \n";                  # Options & parameters used for the blast
$options .= "Minimum size ORF, for flip running $MINLENGTHORF\n";
$options .= "Blast e-value cutoff : $BLASTEVALUECUTOFF\n";
$options .= "Minimum exon size : $MINEXONSIZE\n";
$options .= "Maximum intron size : $MAXLENGTHFORGROUPINGORF\n";
$options .= "Minimum intron size : $MININTRONSIZE\n";
$options .= "Force annotation\n" if ($FORCEANNOT);
$options .= "Matrix : $MATRIX\n";
$options .= "Minimum length for non corresponding ORFs : $MINLENEMPTYORF\n";
$options .= "Overlapping cutoff for non corresponding ORFs: $OVERLAPPINGCUTOFF\n";

print $options if $DEBUG;
print $LOG_F $options if $ISLOGFILE;


# - Create a masterfile object
# - Load the annotations
# - Load the sequence of each contig 

print "Parsing masterfile $MASTERFILE...\n";
my $pirmaster     = PirObject::Masterfile->ObjectFromMasterfile($MASTERFILE, $LOADSTRICT);
my $contigs       = $pirmaster->get_contigs();
my $numbercontigs = scalar (@$contigs);        # Number of contigs in the masterfile
die "No contig header can be found in the masterfile '$MASTERFILE'\n" if $numbercontigs == 0;
my $numberannot   = 0;                         # Number of annotations detected in the program

my %Intron_are_already_annot = ();

foreach my $contig ( @$contigs) {
    my $annotations = $contig-> get_annotations();
    $numberannot += scalar (@$annotations);
    foreach my $annot (@$annotations) {
        $Intron_are_already_annot{$annot} = $annot if ($annot->type() eq "I");
    }
}

print "Number of contigs in Masterfile : $numbercontigs\n",
      "Number of annotations (or comments) detected : $numberannot\n" if $DEBUG;

print $LOG_F "Number of contigs in Masterfile : $numbercontigs\n",
            "Number of annotations (or comments) detected : $numberannot\n" if $ISLOGFILE;

# START THE PROCESS #
my $step        = 1;

# Create a reference for the different general arrays
$FLIPBLASTPROTS = [];    # Array containing the Proteins predicted by Blast and Flip
$HYPPROTS       = [];    # Array for the hypothetical proteins  
$EMPTYORFS      = [];    # Array containing the emptys ORF

# Print the name of each pepfile if it's a library, name begin with libarary....
my $displayfile = $PENAMEDISPLAY{"$LIB_FILE"} || "$LIB_FILE";    # Get the associate name, so if it's a library, get the name of the library         
my @tabname     = split ("/", $displayfile);
print "\n****** Annotation from " . $tabname [$#tabname] . " ******\n";

# Core #
# Run the programm step by, to know the right step  

# Flip running, generate ORFS
print "$step) Run Flip...\n";
$step += 1; 
&RunFlip;

# Blast the flip result with the blast
print "$step) Run Blast...\n";
$step += 1;  
&BlastFlipVSGene;

# Parse the blast result, create a flipblastprot object
print "$step) Parse Information From Blast Results...\n";
$step += 1;
&ParseInformationFromBlastResult ($pirmaster, $TAGNAME);

# Selection of protein
print "$step) Select hypotetical protein for Exonerate...\n";
$step += 1; 
&Select_protein;

# Create hypothetical proteins  
print "$step) Identify similar ORFs...\n";
$step += 1; 
&FillHYPPROTSArrayWithFLIPBLASTPROTSArray;

# Make the alignement and give the exons
print "$step) Internal structure prediction...\n"; 
$step += 1; 
&FindExonsInHypProtArray ($pirmaster);

# Organise the hypothetical proteins (find the real start)
print "$step) Treatment for gene fusion...\n"; 
$step += 1; 
&TreatGeneFusion ($pirmaster);

# Search mini exons
if (!$PARTIAL) {
    print "$step) Annotation of mini exons...\n";
    $step += 1; 
   &AnnotateMiniExons ($pirmaster);
}

# Annotate -> change hypothetical proteins into an object annotation
print "$step) Annotation in the masterfile...\n";
$step += 1; 
&AnnotateMfFromHYPPROTSArray ($pirmaster);

# Annotate rRNA -> Use RNAweasel for 5SrRNA and rnpB, Use HMMweasel for rns and rnl
print "$step) Annotation with external programs...\n"; 
$step += 1; 
&Annotate_Using_external_programs($pirmaster,$EXTSELECTPROG);

# Adjust intronic boundaries with rules for type I and type II 
print "$step) Adjust intronic boundaries...\n"; 
$step += 1; 
&Adjust_all_intronic_junctions($pirmaster);

print "$step) Adjust start and add comment for fusion...\n"; 
$step += 1; 
&CommentFusion($pirmaster);

# Process empty orfs, -> annotate empty ORFs in the masterfile (whose who correspond to something good)
if ($ORFPROCESS) {
    print "$step) Process Empty ORFs...\n"; 
    $step += 1; 
    &AnnotateEmptyOrfs ($pirmaster);
}

# Process intronical ORF -> annotate intronicale ORF not detected by Blast
print "$step) Process intronic ORFs...\n"; 
$step += 1; 
&AnnotateIntronicOrfs ($pirmaster);

&MulticommentConfidence($pirmaster);
# PROGRAMME ENDING #

print "----------------------------------\n",
      "       End of the Programme       \n",
      "----------------------------------\n";  

# Unreferencing 
undef $FLIPBLASTPROTS;
undef $HYPPROTS;
undef $EMPTYORFS;

# Renumber genes with _1, _2 etc correctly this time.
&RenumberFeatures($pirmaster);

# Add informations in the masterfile     
&LogInfo ($pirmaster);

# Dump it
print "Dumping new masterfile in $OUTPUTFILE\n";
$pirmaster->ObjectToMasterfile("$OUTPUTFILE");

if (0) {
print "Dumping PirMaster object to $OUTPUTFILE.xml\n";
$pirmaster->ObjectToFile("$OUTPUTFILE.xml");
}

if ($ISLOGFILE == 1) {
    print "close Logfile : $LOG_FILE\n" if $DEBUG;
    $LOG_F->close() or print "Logfile not closed\n";
}
exit 0;

END { 
    # With exit, programme will go here
    # Cleanup temp directory when program exits.

    return unless defined($TMPDIR) and $TMPDIR =~ m#^/tmp/#;

    print "Temporary work directory $TMPDIR NOT cleaned up ...\n" if $DEBUG; 
    #system("/bin/rm","-rf",$TMPDIR) if -d $TMPDIR && !$DEBUG;
    rmtree($TMPDIR) unless $DEBUG;
}

#############################
#   S U B R O U T I N E S   #
#############################

#-------------------------------------------------------------#
# Subs calling at beginning before to run the core of Mfannot #
#-------------------------------------------------------------#
sub GetPath {
    my $name_prog = shift;
    
    foreach my $dir (@PATH) {
        if (-f "$dir/$name_prog") {
            if (-r _ && -x _) {
                return "$dir/$name_prog";
            }
            else {
                die "   -> ERROR: $name_prog is not readable and executable! Please run:\n",
                    "             chmod 755 \"$dir/ $name_prog\"\n";
            }
        last;
        }
        # Just for clustaw
        if (-f "$dir/${name_prog}2") {
            if (-r _ && -x _) {
                return "$dir/$name_prog";
            }
            else {
                die "   -> ERROR: $name_prog is not readable and executable! Please run:\n",
                    "             chmod 755 \"$dir/ $name_prog\"\n";
            }
        last;
        }
    }
    die "-> ERROR: Could not find '$name_prog' in your search path. Please install\n",
        "   $name_prog from the source (see INSTALL.txt).\n";
}

sub SigCleanup {
     die "\nExiting: received signal \"" . $_[0] . "\".\n";
     # Note that some cleanup will be performed in the END block at this point.
} # End sub

sub CreatePepfileWithLibrary {
    my $library = shift;         # The name of the library
    my $pepfile = shift;         # The name of the file wanted.
                                 # This one contains after the all peptides from the library

    opendir (DIR, $library) or die "Can not open directory '$library': $!\n"; # Open the directory
    my @files = grep((/\.pep$/ and -f "$library/$_"), readdir(DIR));   # Keep the existing *.pep files
    close (DIR);                                                      # Close the directory

    my $outfh = new IO::File ">$pepfile"
        or die "Can't write to library file '$pepfile': $!\n";

    my $desc_to_prot = {}; # Save all proteins 
    # Concatenate all the file from the library
    my $desc = "";
    foreach my $file (@files) {
        my $loc_file = "$library/$file";
        
        my $PEP_F = new IO::File "<$loc_file" or die "Can not open the pepfile '$loc_file': $!\n";
        while (my $line = <$PEP_F>) {
            next if $line =~ /^;|^\s*$/;
            if ($line =~ /^>/) {
                die "The library file \"$loc_file\" has incorrect FASTA syntax.\nThe line faulty line is: $_"
                    if (!($line =~ /\s*([\S]*)\s*;/));
                $desc = $line;
                $desc =~ s/^>?\s*//;
                $desc =~ s/\s*$//;
                print $outfh ">$desc\n";
                die "Error in library $library: duplicated FASTA header '$desc'.\n"
                    if exists $desc_to_prot->{$desc};
                next;
            }
            print $outfh $line; # seq line
            $line =~ s/^\s*//; # cleanup seq line
            $line =~ s/\s*$//;
            $desc_to_prot->{$desc} .= $line;
        }
        $PEP_F->close();
    }

    return $desc_to_prot; # cache of all proteins in library
} # End sub

sub GetOptions {
    # This function is here to manipulate options
    my $option = new PirObject::Option ();      #  Buil a new option model
    $option->FillOption ();                     #  This one buil with the default option and look for a rc file

    # Now The object contains all the options

    # General options
    $TAGNAME                 = $option->tagname;           # Adds a tag  
    $FORCEANNOT              = $option->force;             # Force the annotation when 2 annotations have the same name
    $DEBUG                   = $option->debug;             # Debug mode. If true, display message on the screen
    $GENCODE                 = $option->genetic;           # Genetique code
    $MASTERFILE              = $option->masterfile;        # Path for Masterfile
    $OUTPUTFILE              = $option->outputfile;        # Path for the new
    $ORFPROCESS              = $option->orf;               # For Orf process, allowing presence or not in the masterfile
    $LOADSTRICT              = $option->loadstrict;        # Load strict masterfile
    $ADDCOMMENTS             = $option->addcomments;       # Add comments in the masterfile
    my $allorfs              = $option->allorfs;           # All orfs will apear and won't be checked if option is checked
    $CHECKORFS               = 0 if ($allorfs == 1);       # A little calculation 
    $CHECKORFS               = 1 if ($allorfs == 0);       # To find the opposite
    $PEPLIBRARIES            = $option->pepdirectory;      # List of path for peplibrary directory
    $SIZE                    = $option->size;              # The sensitivite of warning for the long protein, it's a percentage
    $EXTCONFIGFILE           = $option->ext_config;        # Path for configfile
    $EXTSELECTPROG           = $option->ext_select;        # List of names for external prog
    $ALL_INTRONS             = $option->all_introns;       # Indicate if all introns detected by RNAweasel must be annotated
    $BLASTEVALUECUTOFF       = $option->blast2;            # Cutoff value for the blast
    $MINLENGTHORF            = $option->flip2;             # This is the minimum length for creating an ORF with flip
    $MAXLENGTHFORGROUPINGORF = $option->maxintronsize;     # Minimum size of a gap between 2 ORf. If 2 same ORF
    $MAXLENINTRONS           = $option->maxintronsize;     # Max intron size for exonerate.
    $MINLENEMPTYORF          = $option->minlenemptyorf;    # Minimum length for ORF empty orfs (non corresponding orfs)
    $OVERLAPPINGCUTOFF       = $option->overlappingcutoff; # Overlapping cutoff for ORFs 
    $MININTRONSIZE           = $option->minintronsize;     # Opposite of $MAXLENGTHFORGROUPINGORF. Minimum size for intron
    $MINEXONSIZE             = $option->minexonsize;       # Minimum exon size for intron. In genewise.
    $MATRIX                  = $option->matrix;            # The matrix used in genewise alignement
    $PARTIAL                 = $option->partial;           # This will cause mfannot to only run a subset of all its built-in analysis

    my $gentable = Bio::Tools::CodonTable->new();
    die "Unexisting genetic id\n" if   (not $gentable->id($GENCODE));
    
    if($option->islogfile and defined($option->logfile)) {
        if(-w (dirname($option->logfile))) {
            $ISLOGFILE       = $option->islogfile;      #  Just to know if the $LOG_FILE is not empty (0 or 1)
            $LOG_FILE         = $option->logfile;       #  log file : store all the information about run
        }
        else {
            print "\nThe path to your logfile \"" . ($option->logfile). "\" is not writable by you.\n";
            print "No file logging will be performed\n";
            $ISLOGFILE       = 0;
            $LOG_FILE         = undef;
        }
    }

    my $count = "";
    my $name  = $OUTPUTFILE;

    # Checking to see if the path to the output file is writable
    die "\nThe path to where your outputfile will be produced is not writable by you ($name).\nPlease resolve this problem before running again\n"
        if (!-w (dirname($name)));

    # Determing new name of output file if file already exists
    chomp ($name);
    $name =~ s/\d*$//; 
    while (-r ("$name"."$count")) {
        if ($count eq "") {$count = 1;}
        else              {$count++;} 
    }
    $OUTPUTFILE = "$name"."$count";
} # End sub

sub CacheCodonTableWithGeneticId {
    # This function create a file
    # Having a codon table.
    # ATT F....
    # ATG M...
    # Comment will begin with "!"

    my $codontable = shift;   # The bio::tools::codontable
    
    my $ct_cache = {};
    my @letter = qw (A T C G N);
    my $i      = 0;
    my $j      = 0;
    my $z      = 0;

    while ($i < scalar(@letter)) {
        $j = 0;
        while ($j < scalar(@letter)) {
            $z = 0;
            while ($z < scalar(@letter)) {
                my $codon = $letter[$i].$letter[$j].$letter[$z];
                my $aa    = $codontable->translate($codon);
                $ct_cache->{$codon} = $aa;
                $z++;
            }
            $j++;
        }
        $i++;
    }
    return $ct_cache; 
} # End sub



#-----------------------------------#
# Subs forming the core of Mfannot  #
#-----------------------------------#


#------------------------#
# Subs for running flip  #
#------------------------#

sub RunFlip {
    # This function run flip with the masterfile
    # Flip is a program generating ORF
    my $cwd  = cwd();          # Let's get the current working directory name

    # We need to change to the temporary directory to run flip - just so the flip files are written here.
    chdir ("$TMPDIR");

    # Just check if Flip outfiles exist here already, if so get rid of them
    unlink("prot.lst") if (-e "prot.lst");
    unlink("prot.src") if (-e "prot.src");
    unlink("compl")    if (-e "compl");
    unlink("uncompl")  if (-e "uncompl");

    # Checking the see if the masterfile path is aboslute or relative
    my $tmpMasterfile;
    if ($MASTERFILE =~ m!^/!) {
        # Absolute
        $tmpMasterfile = $MASTERFILE;
    }
    else {
        # Relative
        $tmpMasterfile = "$cwd/$MASTERFILE";
    }

    # Need to remove CR from masterfile, so let's make a local copy
    print "Making local copy of masterfile with no CRs.\n" if $DEBUG;
    my $ifh = new IO::File "<$tmpMasterfile"
        or die "Cannot read from masterfile '$tmpMasterfile': $!\n";
    my $ofh = new IO::File ">mf_noCr.all"
        or die "Cannot write to temp file 'mf_noCr.all': $!\n";  # in TMPDIR
    while (my $line = <$ifh>) {
        $line =~ s/\s+$/\n/;
        print $ofh $line;
    }
    $ofh->close();
    $ifh->close();

    my $cmdflip = "$FLIPPATH -m -l $MINLENGTHORF -g $GENCODE mf_noCr.all > $TMPDIR/flip.output";
    # -s start codon
    # -m With this switch, flip will translate the first codon of a protein by 'M' if the codon is a start codon
    # -l minimum length ORF
    # -g genetic codes

    my $resultat = system ("$cmdflip >/dev/null 2>/dev/null");

    print "$cmdflip\n" if $DEBUG;

    # Changing back to the original directory
    chdir($cwd);
} # End sub


#--------------------------#
# Subs for running Blast   #
#--------------------------#

sub BlastFlipVSGene {
    # It runs blast with the flip results against file containing genes 
    $BLASTOUTPUT     = $TMPDIR . "/blastoutput.xml";
    my $file         = $LIB_FILE;                                # Undef should never happen in fact.
    my $escaped_file = $file;
    $escaped_file    =~ s#'#'\\'#g;         
    my $command      = "$FORMATDBPATH -p 'T' -t banque -i $escaped_file -n $TMPDIR/mf -l $TMPDIR/fdb_1.log >/dev/null 2>/dev/null";
    print "$command\n" if $DEBUG;
    my $resformatdb  = system($command);

    # RUN FOR BLAST : run blast with the db created and the flip results        
    my $cmdblast     = "$BLASTPATH -m 7 -p blastp -M $MATRIX -d $TMPDIR/mf -i $TMPDIR/prot.lst -D $GENCODE -o $BLASTOUTPUT -F F2> $TMPDIR/blasterr_1.txt";
    print "$cmdblast\n" if $DEBUG;
    my $resblast = system ($cmdblast);
} # End sub


#--------------------------------------------------#
# Subs for parsing information from Blast results  #
#--------------------------------------------------#

sub ParseInformationFromBlastResult {
    my $pirmaster   = shift;
    my $tag         = shift || "aVwXyZ";

    my $type        = 'PROT';
    my $file        = $LIB_FILE;
    my $blastoutput = $BLASTOUTPUT;

    die "Error: can't find $type report from blastall ?!?\n"
        if (! -r $blastoutput); # It's supposed to be here at this point
        
    my $searchfh = new IO::File "<$blastoutput"
        or die "Can't read from '$blastoutput': $!\n";
                                     
    while (my $result = PirObject::BlastOutput->FileHandleToObject($searchfh)) {
        my $iterations = $result->BlastOutput_iterations() || next;
        foreach my $iteration (@$iterations) {
            &FillFLIPBLASTPROTArrayFromBlastResult($pirmaster,$type,$result,$iteration,$tag);
        }
    }

    $searchfh->close();
    
    foreach my $flipblastprot (@$FLIPBLASTPROTS) {
        my $homologous = $flipblastprot->homologous();
        my @sorted = sort {
            &CompareHighPrecisionFloats($a->get_evalue(),$b->get_evalue());
        } @$homologous;
        my $length = scalar(@sorted);
           $length = ($length < 10 ? $length : 10 );
        
        my %already_here = ();
        my @best_homologous = ();
        foreach my $similar (@sorted) {
            next if scalar(@best_homologous) >= $length;
            my $ident = $similar->get_similarprot();
            push(@best_homologous,$similar) unless ($already_here{$ident}++); 
        }
        $flipblastprot->set_homologous( \ @best_homologous );
    }
} # End sub

sub CompareHighPrecisionFloats {
    # Only for floats that are in NORMALIZED scientific form.
    # Examples of different cases :
    #
    #    1       1.      1.2
    #    1.2e    1.2e3   1.2e-3
    #    e-3     1e3
    #
    # Each of these can optionally be prefixed with "+" or "-".
    #
    # Unlike Math::BigFloat, this routine handles "e-3".

    my ($x,$y) = @_;
    
    die "Unparsable number '$x'\n"
        unless $x =~ m/^([\+\-]?)             # sign
                        ([\d\.]*)             # significand
                        (?:e(-?\d*))?         # exponent
                       $/x;
    my ($xsig,$xman,$xexp) = ($1,$2,$3);
    
    die "Unparsable number '$y'\n"
        unless $y =~ m/^([\+\-]?)             # sign
                        ([\d\.]*)             # significand
                        (?:e(-?\d*))?         # exponent
                       $/x;
    my ($ysig,$yman,$yexp) = ($1,$2,$3);
    
    # Define missing optional components of number representation
    $xsig ||= "+";
    $ysig ||= "+";
    $xman = 1 if !defined($xman) || $xman eq "";
    $yman = 1 if !defined($yman) || $yman eq "";
    $xexp = 0 if !defined($xexp) || $xexp eq "";
    $yexp = 0 if !defined($yexp) || $yexp eq "";  
    
    # Compare numbers when $x or $y are effectively zero
    return 0
        if $xman == 0 && $yman == 0;  # $x == 0 and $y == 0
    return ($xsig eq '-' ? -1 : +1)
        if $xman != 0 && $yman == 0;  # $x != 0 and $y == 0
    return ($ysig eq '-' ? +1 : -1)
        if $xman == 0 && $yman != 0;  # $x == 0 and $y != 0
    
    # Easy comparisons when signs differ
    if ($xsig ne $ysig) {
        return $xsig eq '+' ? 1 : -1;
    }

    # Permutate X <=> Y if both signs are negative
    ($xman,$xexp,$yman,$yexp) = ($yman,$yexp,$xman,$xexp)
        if $xsig eq '-'; # $ysig is '-' too at this point.
    
    # At this point, $x and $y both have mantissas > 0
    return ($xexp <=> $yexp) if $xexp != $yexp;  # $x and $y have different EXP, so compare EXP
    return ($xman <=> $yman);                    # $x and $y have same EXP, so compare mantissas
}

sub FillFLIPBLASTPROTArrayFromBlastResult {
    my $pirmaster = shift; # Pirmaster object
    my $type      = shift; # 'DNA' or 'PROT'
    my $result    = shift; # An object implementing PirObject::BlastOutput
    my $iteration = shift; # An object implementing PirObject::BlastOutput::Iteration
    my $tag       = shift || "bVwXyZ";

    return if (!$result);

    my $rdesc = $iteration->Iteration_query_def() ||   # priority to iteration's value
                $result->BlastOutput_query_def()  ||
                "Unknown Query Description";
    $rdesc =~ m/^\s*(\S+)/;
    my $contigname = $1 || "Unknown contig name";
    $contigname =~ s/;$//; # spurious semicolon introduced by flip

    my $hitslist = $iteration->Iteration_hits() || return;
    return if @$hitslist < 1; # normally, only one.

    # Note: the significance() method is defined in Hit.pir
    my @hits = sort { &CompareHighPrecisionFloats($a->significance(), $b->significance() ) } @$hitslist;

    # We have an hypothetical protein and we want to know if it'real
    my ($strand, $start, $end) = ($rdesc =~ /(orig|compl).\s+(\d+)\s+to\s+(\d+)\s+;\s+[\w\.\!]+/);
    $strand   = ($strand eq 'orig' ? 1 : -1);

    # Quit the function if evalue is too weak #
    # Note: CompareHighPrecisionFloats(a,b) returns: 1 if a > b, -1 if a < b, 0 if a == b
    my $hit   = $hits[0];    
    if (&CompareHighPrecisionFloats($hit->significance(),$BLASTEVALUECUTOFF) == 1) { 
        # If the e-value is not enough for these ORF you can create an Empty ORF 
        my $newemptyorf = new PirObject::EmptyOrf (
                                                   start      => $start,
                                                   end        => $end,
                                                   strand     => $strand,
                                                   evalue     => $hit->significance(),
                                                   contigname => $contigname,
                                                  );
        push (@$EMPTYORFS, $newemptyorf);          # Put into the array, to be processed after   
        return;                                    # Exit the function, because there is no significant ORF 
    }
    
    # Now we have the start, we have the end, the strand and we would like to know if more than one hit is allowed
    my @overlapping;

    my $homo_hash = {};
    for (my $i = 0 ;; $i++) {
        my $hit         = $hits[$i] || last;
        my $fullheader  = $hit->Hit_def();
        my $name = $1 if $fullheader =~ /\s*(\S+)\s*;/;
        next if (not (defined ($name)) or $name eq "");
        my $evalue      = $hit->significance();
        last if &CompareHighPrecisionFloats($evalue,$BLASTEVALUECUTOFF) == 1; # $eva > $BL
        my $prot        = &TakeProteinFromPepfile ($fullheader, $LIB_FILE);
        
        my $homo_tab = $homo_hash->{$name} || ();
        my $newhomologous = new PirObject::Homologous (
                                                        similarprot      => $prot,
                                                        evalue           => $evalue,
                                                       );
        push(@$homo_tab, $newhomologous) unless $homo_tab && scalar(@$homo_tab) >= 10;  # hash ref
        $homo_hash->{$name} = $homo_tab;
    }
    
    # Now we have the start, we have the end, the strand and we would like to know if more than one hit is allowed
    my $hypfusiongene = 0;
    HIT : foreach my $hit (@hits) {
        my $fullheader   = $hit->Hit_def();  # Get the description of the query sequence
        my $hypprotein   = $1 if $fullheader =~ /\s*(\S+)\s*;/; # prot name is before the semicolon
        next if (not (defined ($hypprotein)) or $hypprotein eq "");
        my $evalue       = $hit->significance(); # Get the e-value
        my @hsps         = @{$hit->Hit_hsps()};  # High Scoring pairs
        
        last if (scalar(@hsps) == 0); # An ORF that has a good evalue but no HSP => impossible but ...
        last if &CompareHighPrecisionFloats($evalue,$BLASTEVALUECUTOFF) == 1; # ev > $BL
        last if $hsps[0]->frac_identical() < 0.5 && &CompareHighPrecisionFloats($evalue,$SHORT_HSPS_MIN_EVALUE) == 1;
        
        my $prot = &TakeProteinFromPepfile ($fullheader, $LIB_FILE);   # Take the protein corresponding to the hit
       
        #------- Calculate a sort of frame to see what's the region covered by this ORF
        #  Story : You can have, for some case, more than one protein per gene.
        #  It's a sort of fusion protein.
        #  Each of both have a functional part
        #-----------------------------------------------------------------------------#
        # To make distinction between a protein fusion and a protein annotated as twice
        # We have to check the High Scoring Pair frame. If there is no overllapping between 
        # HSP frames, it means you have many proteins on the same frame
        # If there is, it's probably because many similar proteins corresponds to the same gene
        
        my $frame      = {};
        my ($framestart,$frameend) = ($hsps[0]->start,$hsps[0]->end);

        # We don't need to check for strand because HSP are sorted as if there were on the right strand
        foreach my $hsp (@hsps) {
            next if &CompareHighPrecisionFloats($hsp->significance,$BLASTEVALUECUTOFF) == 1; # si > BL
            $framestart     = $hsp->start if ($hsp->start < $framestart);
            $frameend       = $hsp->end   if ($hsp->end   > $frameend);
        }

        $frame -> {"start"} = $framestart;
        $frame -> {"end"}   = $frameend;

        my $isoverlapping = 0; # Indiquate if wheter or not, accept the hit as annotation of the ORF 

        CURRENTFRAME : foreach my $currentframe (@overlapping) {
            # For each strand there is 4 cases when frame are overlapping

            # 1)     |----------------|             first frame
            #               |-----------------|     second frame
            
            # 2)            |----------------|      first frame
            #        |-----------------|            second frame

            # 3)          |---------|               first frame
            #        |-----------------|            second frame

            # 4)    |-----------------|             first frame
            #         |---------|                   second frame

            #       Case were we are on the right strand
            $isoverlapping = 1 if (($currentframe->{"start"} <=  $frame -> {"start"}) and ($currentframe->{"end"} >=  $frame -> {"start"}));
            $isoverlapping = 1 if (($frame -> {"start"} <=  $currentframe->{"start"}) and ($frame -> {"end"} >=  $currentframe->{"start"}));
            $isoverlapping = 1 if (($frame -> {"start"} <=  $currentframe->{"start"}) and ($currentframe -> {"end"} <=  $frame->{"end"})); 
            $isoverlapping = 1 if (($currentframe -> {"start"} <=  $frame->{"start"}) and ($frame -> {"end"} <=  $currentframe->{"end"}));  

            last CURRENTFRAME  if $isoverlapping == 1; # Go out of the loop if there is a overlapping frame  
        }
        next HIT if ($isoverlapping == 1); # If there is an overlapping, the HIT isn't good for annotation
        push (@overlapping, $frame);

        my $neworf = new PirObject::Orf (
                                         start      => $start,
                                         startBlast => [],
                                         end        => $end,
                                         strand     => $strand,
                                         evalue     => $evalue,
                                         protein    => $prot,    # Assign the protein to the ORF 
                                         hsps       => []
                                        );

        my @start_b;
        my $refhsparray = $neworf->hsps;           # An array reference,                          
        foreach my $hsp (@hsps) {
            next if &CompareHighPrecisionFloats($hsp->significance,$BLASTEVALUECUTOFF) == 1; # si > BL
            my $newhsp = new PirObject::Hsp_query_sbjct (
                                                         start_q  => $hsp->Hsp_query_from(),
                                                         end_q    => $hsp->Hsp_query_to(),
                                                         start_s  => $hsp->Hsp_hit_from(),
                                                         end_s    => $hsp->Hsp_hit_to(),
                                                         strand   => 0,
                                                        );
            push (@$refhsparray, $newhsp);

            if ($hsp->Hsp_query_from() > $hsp->Hsp_hit_from()) {
                my $start_cor = $start + ( ($hsp->Hsp_query_from() *3) - ($hsp->Hsp_hit_from() *3) ) if $strand == 1;
                   $start_cor = $start - ( ($hsp->Hsp_query_from() *3) - ($hsp->Hsp_hit_from() *3) ) if $strand != 1;
                push (@start_b, $start_cor);
            }
        }

        my $newstartblast = $neworf->startBlast;
        my $start_bl      = min(@start_b) if $strand == 1;
           $start_bl      = max(@start_b) if $strand == -1; 
        push (@$newstartblast, $start_bl);

        my $newflipblastprot = GetFlipBlastProtByNameAndContigName($hypprotein, $contigname);
        
        # If we can't find it, create it once, and push it on @$FLIPBLASTPROTS
        if (! defined ($newflipblastprot)) {
            $newflipblastprot = new PirObject::FlipBlastProt (
                                                                 name           => $hypprotein, # First we create the flipblast prot
                                                                 contigname     => $contigname,
                                                                 orfs           => [],
                                                                 homologous     => []
                                                                );
            if ($hypfusiongene != 0) {
                my $index = &FindIndexOfGeneFusion($start,$end,$FLIPBLASTPROTS);
                @$FLIPBLASTPROTS[$index]->set_hypfusiongene($hypprotein);
                $newflipblastprot->set_hypfusiongene(@$FLIPBLASTPROTS[$index]->get_name());
            }
            push (@$FLIPBLASTPROTS, $newflipblastprot);
        }
        $hypfusiongene++;
       
        my $ref_orf_array        = $newflipblastprot->get_orfs();
        my $ref_homologous_array = $newflipblastprot->get_homologous();
        push (@$ref_orf_array, $neworf);    #    And we just add a new orf
        my $homo = $homo_hash->{$hypprotein};
        push (@$ref_homologous_array, @$homo);

        last if (! $MULTIORFS);             # Exit the function after the first hit if multi ORFS not allowed
    } # End foreach $hit
} # End sub

sub TakeProteinFromPepfile {
    # This function takes a protein from the blast result with a descritpion line
    # A kind of pareser of fasta file
    my $description = shift;
    my $pepfile     = shift; # not used anymore

    $description =~ s/^>?\s*//;
    $description =~ s/\s*$//;

    # Certain XML entitites are produced by blastall's XML output,
    # but not handled by PirObject XML parser. Replace them here.
    $description =~ s/&apos;/'/g;
    $description =~ s/&quot;/"/g;

    my $protein     = $CACHE_PEPLIBRARY->{$description}
       || die "Internal error: can't find library protein with description '$description'.\n";
    
    return ">$description\n" . $protein;
} # End sub

sub GetFlipBlastProtByNameAndContigName {
    # This function gives a FlipBlastProt with his name and contig name
    my $name       = shift;  #    This the name of the GetFlipBlastProt
    my $contigname = shift;  #    This is the contigname of the FlipBlastProt

    foreach my $result (@$FLIPBLASTPROTS) {
         return $result if ($result->name eq $name and $result->contigname eq $contigname);
    }
    return undef; # In the case where any object has been found
} # End sub

sub FindIndexOfGeneFusion {
    my $start_orf        = shift;
    my $end_orf          = shift;
    my $all_prev_hypprot = shift;

    my $index = 0;
    foreach my $prot (@$all_prev_hypprot) {
        my $orfs  = $prot->get_orfs();
        foreach my $orf (@$orfs){
            my $start = $orf->get_start();
            my $end   = $orf->get_end();
            return $index if $start == $start_orf && $end == $end_orf;
        }
        $index++;
    }
}

#-----------------------------------------------------------#
# Subs for selecting hypotetical protein for identification #
# of protein with exon/intron (In order to run Exonerate)   #
#-----------------------------------------------------------#

sub Select_protein {
    # This function is create in order to selection the protein for run Exonerate or not
    my $compt = 0;
    my @index;
    foreach my $flipblastprot (@$FLIPBLASTPROTS) {
        my $name           = $flipblastprot->get_name();
        my $contigname     = $flipblastprot->get_contigname();
        my $orfs           = $flipblastprot->get_orfs();
        my $homologous     = $flipblastprot->get_homologous();
        my $genefusionname = $flipblastprot->get_hypfusiongene();
        my $number_orfs    = scalar (@$orfs);
        my %strand;  # Hashtable with the number of each strand for one flipblastprot

        next if ($number_orfs < 1); # Impossible but ..........
        
        if ($number_orfs > 1) {
            my @prot_score; # Tab for score of blast and protein
            foreach my $orf(@$orfs) {
                $strand{1}++  if $orf->strand == 1;
                $strand{-1}++ if $orf->strand == -1;
                my $info_prot_score = [$orf->evalue(), $orf->protein()];
                push (@prot_score, $info_prot_score);
            }
 
            @prot_score = sort { $a->[0] <=> $b->[0] } @prot_score; # Sort @protein_score by score
            my $prot = $prot_score[0]->[1];                         # Protein who have bigger score

            if ($strand{1} && $strand{-1}) {
                my $info = [$name, $contigname, $prot, 2];
                push(@PROT_FOR_EXONERATE, $info);
                push(@index, $compt);
            }
            elsif ($strand{1} || $strand{-1}) {
                my @start_end_orf;
                my $strand = 1 if $strand{1};
                   $strand = -1 if $strand{-1};
                foreach my $orf(@$orfs){
                    my @start_hsp =();
                    my @end_hsp   =();
                    my $hsps      = $orf->get_hsps();
                    my $evalue    = $orf->get_evalue();
                    foreach my $hsp(@$hsps){
                        push (@start_hsp, $hsp->start_q);
                        push (@end_hsp, $hsp->end_q);
                    }
                    my $min_start_hsp  = min(@start_hsp);                                     # Give the lower start of hsp
                    my $max_end_hsp    = max(@end_hsp);                                       # Give the bigger end of hsp
                    my $cor_start      = $orf->start + (3 * $min_start_hsp) if $strand ==  1; # The really start of orf if strand +
                       $cor_start      = $orf->start - (3 * $min_start_hsp) if $strand == -1; # The really start of orf if strand -
                    my $cor_end        = $orf->start + (3 * $max_end_hsp)   if $strand ==  1; # The really end of orf if strand +
                       $cor_end        = $orf->start - (3 * $max_end_hsp)   if $strand == -1; # The really end of orf if strand -
                    my $pair_start_end = [ $cor_start, $cor_end, $evalue ];
                    push (@start_end_orf, $pair_start_end);
                }

                @start_end_orf  = sort { $a->[0] <=> $b->[0] } @start_end_orf if $strand ==  1; # Sort @start_end_orf by start for strand +
                @start_end_orf  = sort { $b->[0] <=> $a->[0] } @start_end_orf if $strand == -1; # Sort @start_end_orf by start for strand -
            
                for (my $i=0; $i < @start_end_orf - 1; $i++) {
                    my $diff = abs($start_end_orf[$i]->[1]-$start_end_orf[$i+1]->[0]);
                    if ( 142 <= $diff ) {
                        # if distance between 2 orf who have match with one protein is higher than 142 nt => Run exonerate
                        my $info = [$name, $contigname, $prot, $strand, $homologous, $genefusionname, [$start_end_orf[$i], $start_end_orf[$i+1]]];
                        push(@PROT_FOR_EXONERATE, $info);
                        push(@index, $compt);
                    }
                    else {
                       $flipblastprot->set_frameshift(1);
                       print "   The gene coding for $name present probably a frameshift\n"; 
                    }
                } # End for $i
            } # End elsif
        } # End if
        $compt++;
    } # End foreach $flipblastprot

    # In order to run exonerate only one time foreach protein
    my %index_deja_vu = ();
    my @index_uni; 
    foreach my $index (@index) {
        push(@index_uni,$index) unless $index_deja_vu{$index}++; 
    }

     my %prot_deja_vu = (); 
     my @prot_uni; 
     foreach my $prot (@PROT_FOR_EXONERATE) {
         my $ident = $prot->[1] . "-" . $prot->[2];
         push(@prot_uni,$prot) unless ($prot_deja_vu{$ident}++); 
     }

     @PROT_FOR_EXONERATE = @prot_uni; 

     @index_uni = sort {$b <=> $a} @index_uni;

     # In order to remove the protein of flipblastprot when we run Exonerate
     for (my $i=0; $i < @index_uni; $i++) {
         splice(@$FLIPBLASTPROTS,$index_uni[$i],1);
     }
} # End sub

#------------------------------------#
# Subs for identifying similar ORFs  #
#------------------------------------#

sub FillHYPPROTSArrayWithFLIPBLASTPROTSArray {
    # This function fill the HYPPROTS array (array of hypothetical proteins with
    # FLIPBLASTPROTS array (array of ORF and hsp)

     mkdir("$TMPDIR/Muscle_for_start",0700) or die "Error: can't create work directory '$TMPDIR/Muscle_for_start': $!\n";
    
    # This is mainly the algorithm given by Franz
    foreach my $flipblastprot (@$FLIPBLASTPROTS) {        # For each flip blast protein
        my $name           = $flipblastprot->get_name();
        my $contigname     = $flipblastprot->get_contigname();
        my $orfs           = $flipblastprot->get_orfs();
        my $namefusiongene = $flipblastprot->get_hypfusiongene() || undef;
        my $homologous     = $flipblastprot->get_homologous()    || undef;
        my $frameshift     = $flipblastprot->get_frameshift()    || undef;
        my $numberorfs     = scalar (@$orfs);

        next if ($numberorfs < 1); # Impossible but ..........
        
        my $contig      = $pirmaster->GetContigByName ($contigname);
        my $seq         = $contig->get_sequence();
           $seq         =~ s/!//g;

        
        # if there is more than one orf
        my $neworfs = [];

        # Sort the orf #
        # The ORFs are classified and sorted by strand and start, stop positions
        @$orfs = sort { 
            my ($stranda,$strandb) = ($a->strand,$b->strand);
            if ($stranda != $strandb) {
                $a->strand <=> $b->strand;
            }
            elsif ($stranda == 1) {
                $a->start  <=> $b->start;
            }
            else {
                $a->end    <=> $b->end;
            }    
        } @$orfs;    

        my $newhypprot = undef;

        foreach my $orf(@$orfs) {
            # Now the thing is to create a new hyp prot if the conditions are not required
            # First : if the $currentprot is not defined 

            my $start_bl = $orf->startBlast;
            my $start_cor = ( !(@$start_bl[0]) ? $orf->start : @$start_bl[0]);

            # Case 1 : first ORF
            if (not defined($newhypprot)) {
                # Here we create a new protein
                $newhypprot = new PirObject::HypProt (
                                                      name       => $name,
                                                      contigname => $contigname,
                                                      blaststart => $start_cor,
                                                      start      => $start_cor,
                                                      end        => $orf->end,
                                                      strand     => $orf->strand,
                                                      numorfs    => 1,
                                                      remark     => "",
                                                      protein    => $orf->protein,
                                                      evalue     => $orf->evalue(), 
                                                      exons      => [],
                                                      introns    => [],
                                                      homologous => $homologous,
                                                      idbyblast  => 1,
                                                      frameshift => $frameshift
                                                     );
                    next; 
            }

            # Case 2 : not the same strand
            if ($newhypprot->strand !=  $orf->strand) {
                push (@$HYPPROTS,  $newhypprot);
                $newhypprot = new PirObject::HypProt (
                                                      name       => $name,
                                                      contigname => $contigname,
                                                      blaststart => $start_cor,
                                                      start      => $start_cor,
                                                      end        => $orf->end,
                                                      strand     => $orf->strand,
                                                      numorfs    => 1,
                                                      remark     => "",
                                                      protein    => $orf->protein,
                                                      evalue     => $orf->evalue(),  
                                                      exons      => [],
                                                      introns    => [],
                                                      homologous => $homologous,
                                                      idbyblast  => 1,
                                                      frameshift => $frameshift
                                                     );                 
                next;
            }

            # Case 3-4 : Check space between 2 ORFs, including overlapping
            if ($orf->strand == 1) {
                # Two case : right strand or opposite strand
                if (($newhypprot->end > $orf->start) or (abs ($orf->start - $newhypprot->end) < $MAXLENGTHFORGROUPINGORF)) {
                    
                    my $newstart = ( $orf->start < $newhypprot->start ? $orf->start : $newhypprot->start);
                    $newhypprot->set_start ($newstart);
                    
                    my $newend = ( $orf->end   > $newhypprot->end ? $orf->end : $newhypprot->end);
                    $newhypprot->set_end ($newend);

                    # Check which protein is the best
                    if (&CompareHighPrecisionFloats($orf->evalue(),$newhypprot->evalue()) == -1) {
                        $newhypprot->set_protein($orf->protein);
                        $newhypprot->set_evalue($orf->evalue());
                    }

                    # Increase from 1, the number of orf, if we concatenate
                    my $numorfs = $newhypprot->numorfs;
                    $numorfs++;
                    $newhypprot->set_numorfs($numorfs);
                    next;
                }
                else {
                    push (@$HYPPROTS,  $newhypprot);
                    $newhypprot = new PirObject::HypProt (
                                                          name       => $name,
                                                          contigname => $contigname,
                                                          blaststart => $start_cor,
                                                          start      => $start_cor,
                                                          end        => $orf->end,
                                                          strand     => $orf->strand,
                                                          numorfs    => 1,
                                                          remark     => "",
                                                          protein    => $orf->protein,
                                                          evalue     => $orf->evalue(), 
                                                          exons      => [],
                                                          introns    => [],
                                                          homologous => $homologous,
                                                          idbyblast  => 1,
                                                          frameshift => $frameshift
                                                        );
                    next;
                }
            }
            else {
                # Opposite strand
                if (($newhypprot->start > $orf->end) or (abs ($orf->end - $newhypprot->start) < $MAXLENGTHFORGROUPINGORF)) {

                    my $newstart = ( $orf->start > $newhypprot->start ? $orf->start : $newhypprot->start);
                    $newhypprot->set_start ($newstart);
                    
                    my $newend = ( $orf->end < $newhypprot->end ? $orf->end : $newhypprot->end);
                    $newhypprot->set_end ($newend);

                    # Check which protein is the best
                    if (&CompareHighPrecisionFloats($orf->evalue(),$newhypprot->evalue()) == -1) {
                        $newhypprot->set_protein ($orf->protein);
                        $newhypprot->set_evalue($orf->evalue());
                    }

                    # Add 1 to the number of orf if there is concatenation
                    my $numorfs = $newhypprot->numorfs;
                    $numorfs++;
                    $newhypprot->set_numorfs($numorfs);
                    next;
                }
                else {
                    push (@$HYPPROTS,  $newhypprot);
                    $newhypprot = new PirObject::HypProt (
                                                          name       => $name,
                                                          contigname => $contigname,
                                                          blaststart => $start_cor,
                                                          start      => $start_cor,
                                                          end        => $orf->end,
                                                          strand     => $orf->strand,
                                                          numorfs    => 1,
                                                          remark     => "", 
                                                          protein    => $orf->protein,
                                                          evalue     => $orf->evalue(), 
                                                          exons      => [],
                                                          introns    => [],
                                                          homologous => $homologous,
                                                          idbyblast  => 1,
                                                          frameshift => $frameshift
                                                         );
                    next;
                }
            }
        }  # End for each ORF
        if ($namefusiongene) {
            my $info_gene_fusion = new PirObject::HypFusion ( name => $namefusiongene );
            $newhypprot->set_hypfusiongene($info_gene_fusion);
        }
        &AdjustStart($newhypprot, $seq);
        push (@$HYPPROTS,  $newhypprot);
    } # End for each Flip Blast Prot
} # End sub

sub AdjustStart {
    my $hypprot = shift;
    my $seq        = shift;

    my $genename   = $hypprot->get_name();
    my $isMinus    = $hypprot->get_strand() == 1 ? 0 : 1;
    my $start      = $hypprot->get_start();
    my $end        = $hypprot->get_end();
    my $old_start  = $hypprot->get_blaststart() || $start;
    my $exons      = $hypprot->get_exons();
    my $introns    = $hypprot->get_introns();

    my $WithIntrons = (scalar(@$exons) != 0 ? 1 : 0);

    my $this_prot = &GetProteinForGeneWithoutIntrons($hypprot, $seq, $start, $end, $isMinus) if !$WithIntrons;
       $this_prot = &GetProteinSequenceAndIntronsPos($exons,$introns,$seq,$hypprot)          if  $WithIntrons;

    my $full5     = &GetFull5($seq,$isMinus,$this_prot,$start);

    $hypprot->set_thisprot($this_prot);
    $hypprot->set_full5($full5);
    my $hyp_st_full5 = length($full5) - length($this_prot);

    # Make the alignment
    my $file_for_alignment = &MakeFileForAlignment($hypprot,"Muscle_for_start",10);
    my $result_file        = $file_for_alignment;
       $result_file        =~ s/.fasta$/.aln/;
    my $cmd = "$MUSCLEPATH -in $file_for_alignment -stable -clwstrict -out $result_file >/dev/null 2>/dev/null";
    print "\n$cmd\n" if $DEBUG;
    my $resultat = system ("$cmd");

    my $alignio      = new Bio::AlignIO(-format => 'clustalw',
                                           -file   => $result_file);
    my $align        = $alignio->next_aln();

    my $each_st      = &DefEachStartInAli($align);
    my $hyp_st_ali   = $each_st->{"mfaprot"};
    delete $each_st->{"mfaprot"};

    my $st_pos_cmp_st_orf = {};
    while (my ($id, $homo_st_ali) = each(%$each_st)) {
        $st_pos_cmp_st_orf->{$id} = $hyp_st_full5 + ($homo_st_ali - $hyp_st_ali);
    }
    my ($right_lim_for_st,$left_lim_for_st) = &DefMaxAndMinStartInAli($st_pos_cmp_st_orf);
    
    my $first_exon = undef;
    if ($WithIntrons) {
           $first_exon      = $exons->[0];
        my $end_first_exon  = $first_exon->get_protend();
           $full5           = substr($full5,0,$end_first_exon);
    }
    
    my $aa_accepted          = { "M" => 1, "v" => 1};
    my $all_possible_st      = &DefineAllPossibleStart($full5, $right_lim_for_st,$aa_accepted);
    my ($best_start,$median) = &ChooseBestStart($st_pos_cmp_st_orf,$all_possible_st,$right_lim_for_st);

    # If no M or v was found
    if (!(defined $best_start)) {
        $hypprot->set_startwarning("No start found");
        return;
    }

    # Add info about alternative start
    my $first_M = undef;
    foreach my $st_pos (sort { $a <=> $b } keys %$all_possible_st) {
        next if $all_possible_st->{$st_pos}->{"aa"} ne "M";
        $first_M = $st_pos;
        last;
    }

    my $alt_start = $first_M    - $hyp_st_full5 if $first_M;
    my $new_start = $best_start - $hyp_st_full5;

    if ( defined($alt_start) && $alt_start != $new_start) {
        my $alternative_st_in_seq = $isMinus ? ($old_start - ($alt_start*3)) : ($old_start + ($alt_start*3));
        $hypprot->set_altstart($alternative_st_in_seq);
    }

    # Change start value and add comment or not
    if (abs($best_start-$right_lim_for_st) > 2 && $best_start > $right_lim_for_st) {
        &ChangeHypProtVal($hypprot, $new_start, $isMinus);
        $hypprot->set_starttoodown(abs($best_start-$median)) if $best_start > $right_lim_for_st;
    }    
    else {
        &ChangeHypProtVal($hypprot, $new_start, $isMinus);
        $hypprot->set_starttooup(abs($best_start-$median)) if $best_start < $left_lim_for_st;
    }
    return if !$WithIntrons;
    &SearchForEndIfGeneHaveIntron($hypprot,$exons,$isMinus,$seq);
}

sub GetProteinForGeneWithoutIntrons {
    my ($hypprot, $seq, $start, $end, $isMinus) = @_;
    
    # 1. Make hyp prot def by blast
    my $g_length =  !$isMinus ? $end - $start + 1 : $start - $end +1;
    my $nt_seq   =  !$isMinus ? substr($seq, $start - 1 , $g_length) : substr($seq, $end - 1 , $g_length);
       $nt_seq   =~ tr/ACGT/TGCA/    if $isMinus;
       $nt_seq   = reverse $nt_seq   if $isMinus;
   
    my $protein    = "";
    foreach (my $i = 0; $i <= length($nt_seq) - 3; $i += 3) {
        my $tri_nt   = uc (substr($nt_seq, $i , 3));
        my $aa       = $CODON_TABLE->{$tri_nt} || "X";
           $aa       = lc($aa) if $tri_nt eq "GTG" && $CODON_TABLE->{$tri_nt} eq "V";
           $protein .= $aa;
    }
    return $protein;
}

sub GetFull5 {
    my ($seq, $isMinus, $prot_seq, $start) = @_;
    
    my $use_seq =  $seq;
    $use_seq =~ tr/ACGT/TGCA/    if $isMinus;
    $use_seq =  reverse $use_seq if $isMinus;
    
    my $full_5  = $prot_seq;
    $prot_seq   = uc($prot_seq);
    my $len_seq = length($seq);
       $start   = $len_seq - $start + 1 if $isMinus;
       
     my $shift  = -3;
     my $tail_5 = [];
     for (my $currentpos = $start - 3; ; $currentpos += $shift) {
         last if $currentpos < 0;
         my $tri_nt = uc (substr($use_seq, $currentpos - 1,3));
         my $aa     = $CODON_TABLE->{$tri_nt};
         $aa        = lc($aa) if $tri_nt eq "GTG" && $CODON_TABLE->{$tri_nt} eq "V";
         last if $aa eq "*";
         push(@$tail_5, $aa);
     }
    @$tail_5  = reverse(@$tail_5);
    my $tail  = join("",@$tail_5);
    $full_5   = $tail.$full_5;
    return $full_5;
}

sub DefEachStartInAli {
    my $align = shift;
    
    my $each_start = {};
    foreach my $seq ($align->each_seq) {
        my $id             = $seq->display_id();
        my $sequence       = $seq->seq();
        my $dash_chain     = $1 if $sequence =~ m/^(-*)/;
        my $len_dash       = length($dash_chain);
        $each_start->{$id} = $len_dash;
    }
    return $each_start;
}

sub DefMaxAndMinStartInAli {
    my $each_start = shift;
    
    my $max_start  = 0;
    my $min_start  = 999999;
    while ( my ($seq_id, $val) = each(%$each_start) ) {
        $max_start = $val if $val > $max_start;
        $min_start = $val if $val < $min_start;
    }
    return ($max_start,$min_start);
}

sub DefineAllPossibleStart {
    my $full5               = shift;
    my $right_lim_for_start = shift;
    my $aa_accepted         = shift;
    
    my $all_possible_start = {};
    my @t_full5 = split(//, $full5);
    
    for (my $i = 0 ; $i <= $#t_full5 ; $i++) {
        my $aa = $t_full5[$i];
        next if !$aa_accepted->{$aa};
        $all_possible_start->{$i}->{"aa"} = $aa;
        last if $i > $right_lim_for_start;
    }
    return $all_possible_start;
}

sub ChooseBestStart {
    my $each_st          = shift;
    my $all_possible_st  = shift;
    my $right_lim_for_st = shift;
    
    # No start was found before last start in alignment
    my $best_start  = undef;
       $best_start  = &ChooseStartIfTooFar($all_possible_st,$right_lim_for_st);
       my $median   = &Median($each_st);
    return ($best_start,$median) if $best_start;
    
    foreach my $st_pos (sort { $a <=> $b } keys %$all_possible_st) {
        #xxxxxxx attention + 2 doit etre ici d une variable.
        delete $all_possible_st->{$st_pos} if $st_pos > ($right_lim_for_st + 2);
    }
    my $aa_accepted = ["M","v"];
    my $alt_start   = undef;
    my $min_diff    = 100000;
    foreach my $aa (@$aa_accepted) {
        &AddInfoForPosStart($each_st,$all_possible_st,$aa);
        my $nb_homo  = scalar(keys %$each_st);
        my $diff     = "";
        
        # Start is defined with close homologous.
        $alt_start   = &ChooseStartWithCloseHomo($all_possible_st,$nb_homo);
        if (defined $alt_start) {
            $best_start = $alt_start if !(defined $best_start);
            my $diff    = $all_possible_st->{$alt_start}->{"min"};
            $min_diff   = $diff if $diff < $min_diff;
            if ($best_start != $alt_start) {
                $best_start = $alt_start if $diff <= $min_diff;
            }
        }
        next if $alt_start;
        
        # Start is defined with median.
        $alt_start   = &ChooseStartWithAllHomo($each_st,$all_possible_st,$median,$aa);
        next if !(defined $alt_start); # Normally this situation can't be happened.
        $best_start  = $alt_start if !$best_start;
        $diff        = abs($median - $alt_start);
        $min_diff    =  $diff if $diff < $min_diff;
        if ($best_start != $alt_start) {
                $best_start = $alt_start if $diff <= $min_diff && $alt_start < $best_start;
        }
    }
    return ($best_start,$median);
}

sub ChooseStartIfTooFar {
    my $all_possible_st = shift;
    my $limite          = shift;
    
    foreach my $st_pos (sort { $a <=> $b } keys %$all_possible_st) {
        return $st_pos if $st_pos > $limite;
        last;
    }
    return undef;
}

sub AddInfoForPosStart {
    my $each_st         = shift;
    my $all_possible_st = shift;
    my $aa_accepted     = shift;
    
    while (my ($id, $st_homo) = each(%$each_st)) {
        next if $id gt "d";
        my $close_hyp_st = undef;
        my $min_diff  = 100000;  #very hight value
        foreach my $st_pos (sort { $a <=> $b } keys %$all_possible_st) {
            my $aa   = $all_possible_st->{$st_pos}->{"aa"};
            delete  $all_possible_st->{$st_pos}->{"count"} if $aa ne $aa_accepted 
                                                           && $all_possible_st->{$st_pos}->{"count"};
            next if $aa ne $aa_accepted;
            my $diff = abs($st_homo-$st_pos);
            ($close_hyp_st,$min_diff) = ($st_pos,$diff) if $diff < $min_diff;
        }
        next if !(defined $close_hyp_st);
        next if $all_possible_st->{$close_hyp_st}->{"aa"} ne $aa_accepted;
        $all_possible_st->{$close_hyp_st}->{"count"}++;
        $all_possible_st->{$close_hyp_st}->{"min"}  = $min_diff if ( (not defined ($all_possible_st->{$close_hyp_st}->{"min"}))
                                                                   || $min_diff <= $all_possible_st->{$close_hyp_st}->{"min"});
    }
}

sub ChooseStartWithCloseHomo {
    my $all_possible_st = shift;
    my $nb_homo         = shift;
         
    while ( my ($st_pos, $hash) = each(%$all_possible_st) ) {
        my ($aa,$count) = ($hash->{"aa"},$hash->{"count"});
        next if !$count;
        if ($nb_homo >= 4) {
           return $st_pos if $count >= 3;
        }
        elsif ($nb_homo == 2 || $nb_homo == 3) {
            return $st_pos if $count >= 2;
        }
        elsif ($nb_homo == 1) {
            return $st_pos if $count >= 1;
        }
    }
    return undef;
}

sub ChooseStartWithAllHomo {
    my $each_st         = shift;
    my $all_possible_st = shift;
    my $median          = shift;
    my $aa_accepted     = shift;
    
    foreach my $st_pos (sort (keys(%$all_possible_st))) {
        delete $all_possible_st->{$st_pos}->{"count"};
    }
    
    my $close_hyp_st = undef;
    my $min_diff     = 100000;  #very hight value
    foreach my $st_pos (sort { $a <=> $b } keys %$all_possible_st) {
        my $aa   = $all_possible_st->{$st_pos}->{"aa"};
        delete $all_possible_st->{$st_pos}->{"min"};
        delete $all_possible_st->{$st_pos}->{"count"};
        next if $aa ne $aa_accepted;
        my $diff = abs($median-$st_pos);
        ($close_hyp_st,$min_diff) = ($st_pos,$diff) if $diff < $min_diff;
    }
    return $close_hyp_st;
}

sub Median {
    my $each_st = shift;
    
    my @all_pos = ();
    while ( my ($id, $pos) = each(%$each_st) ) {
        push(@all_pos,$pos);
    }
    @all_pos = sort { $a <=> $b } @all_pos;
    my $median   = "";
    my $nb_elem  = scalar(@all_pos);
    my $last_ind = $nb_elem - 1;
    if ($nb_elem == 1) {
        $median = $all_pos[0];
    }
    elsif (($nb_elem % 2) == 0) {
        $median = $all_pos[($last_ind / 2)];
    }
    else {
        $median = int ( $all_pos[int($last_ind / 2)] 
                    + (($all_pos[int($last_ind / 2) + 1] 
                      - $all_pos[int($last_ind / 2)]) / 2));
    }
    $median = $median >= 0 ? $median : 0;
    return $median;
}

sub ChangeHypProtVal {
    my $hypprot    = shift; 
    my $new_start  = shift;
    my $isMinus    = shift;
    
    my $old_start  = $hypprot->get_start;
    my $new_st_pos = $isMinus ? ($old_start - ($new_start*3)) : ($old_start + ($new_start*3));
    my $exons      = $hypprot->get_exons();
    my $first_exon = $exons->[0] if scalar(@$exons);
    $first_exon->set_dnastart($new_st_pos) if $first_exon;
    $hypprot->set_start($new_st_pos);
}

sub SearchForEndIfGeneHaveIntron {
    my $hypprot     = shift;
    my $exons       = shift;
    my $isMinus     = shift;
    my $seq         = shift;
    
    my $len_seq    = length($seq);
    my $first_exon = $exons->[0];
    my $end_exon   = $exons->[-1];
    my $end_e      = $end_exon->get_dnaend();

    if (!$isMinus) {
        for (my $i = -3;; $i += 3) {
            last if $end_e + $i > $len_seq -3;
            my $tri_nt  = uc (substr($seq, $end_e + $i, 3));
            my $codon   = $CODON_TABLE->{$tri_nt};
            next if $codon ne "*";
            my $new_end = $end_e + $i + 3;
            $end_exon->set_dnaend($new_end);
            $hypprot->set_end($new_end);  # Set the new end to the protein
            last; 
        }
    }
    elsif ($isMinus) {
        for (my $i = 0;; $i -= 3) {
            last if $end_e +$i-1 < 0;
            my $tri_nt = uc (substr($seq, $end_e + $i - 1 , 3));
               $tri_nt =~ tr/ATUGCatugc/TAACGTAACG/;
               $tri_nt = reverse ($tri_nt);# Reverse and complementary
            my $codon  = $CODON_TABLE->{$tri_nt};
            next if $codon ne "*";
            my $new_end = $end_e + $i;
            $end_exon->set_dnaend($new_end);
            $hypprot->set_end($new_end);       # Set the new end to the protein
            last; 
        }
    }
}

#-----------------------------------------#
# Subs for internal structure prediction  #
#-----------------------------------------#

sub FindExonsInHypProtArray {
    # The main is to find exons by making a local alignement
    my $pirmaster = shift;        # The masterfile object
    
    mkdir("$TMPDIR/Exonerate",0700) or die "Error: can't create work directory '$TMPDIR/Exonerate': $!\n";
    for (my $i=0; $i < @PROT_FOR_EXONERATE ; $i++) {

        my $info = $PROT_FOR_EXONERATE[$i]; # table with values for each prot
        my ($name, $contigname, $protein, $strand, $homologous, $namefusiongene) = @$info;

        # In order to have the contig sequence
        my $contig  = $pirmaster->GetContigByName($contigname)
            or die "Internal error: can't find contig named '$contigname'.\n";
        my $dna_seq = $contig->sequence;
           $dna_seq =~ s/\!//g;
        my $seq     = ">sequence\n";
           $seq    .= $dna_seq;

        my $length = 0;
        my @tab_prot = split(/\n/, $protein);  # check this, it may not work properly
        for (my $i = 0 ; $i <= $#tab_prot ; $i++) {
            my $line = uc $tab_prot[$i];
            next if $line =~ /^>/;
            $line =~ tr/A-Z//cd;
            $length += length($line);
        }
        my $overlappe_authorized = ((5*$length)/100);

        # Write protein and gene in fasta files
        my $cleancontigname = $contigname;
        $cleancontigname =~ s/\W/_/g;
        my $fileprot      = "$TMPDIR/Exonerate/prot_for_exonerate_${i}_${name}";
        my $filecontig    = "$TMPDIR/Exonerate/gene_for_exonerate_${cleancontigname}";
        my $exonerate_out = "$TMPDIR/Exonerate/exonerate_${i}_${name}";

        # Check if it exists
        unlink($fileprot)      or die "Impossible to delete $fileprot\n"      if (-f $fileprot);
        unlink($exonerate_out) or die "Impossible to delete $exonerate_out\n" if (-f $exonerate_out);

        # Create protein for exonerate
        my $FILEPROT = new IO::File ">$fileprot" or die "Impossible to open $fileprot\n";
        print $FILEPROT $protein, "\n";
        $FILEPROT->close() or die "Impossible to close $fileprot\n";

        # Create genome for exonerate
        if (! -f $filecontig) {
            my $FH = new IO::File ">$filecontig" or die "Impossible to open $filecontig\n";
            print $FH $seq, "\n";
            $FH->close() or die "Impossible to close $filecontig\n";
        }

        my $cmd = "$EXONERATEPATH $Exonerate_parameter --geneticcode $GENCODE $fileprot '$filecontig' > $exonerate_out"; # $Exonerate_parameter $fileprot $filecontig
        print "\n$cmd\n" if $DEBUG;

        my $resultat = system("$cmd");
        
        my $hascoredump = ($resultat & 128) >> 7;  # 0 if no core dump, 1 if core dump
        my $signal      = $resultat & 127;  # SIGNAL received by subprocess, from 0 to 127;
        my $returncode  = $resultat >> 8;   # exit status of subprogram
        if ($returncode > 1 || $signal > 0 || $hascoredump == 1) {
            print "Error in execution of Exonerate \n";
        }

        my $infh  = new IO::File "<$exonerate_out"
            or die "Can't read from file '$exonerate_out': $!\n";
        my @tab   = <$infh>;
        $infh->close();

        my $flobj = new PirObject::ExonerateOutput();
        $flobj->FillFeaturesFromTextOutput(\@tab);

        my $ExoReports          = $flobj->report;   # One report contain information about one C4 section present in exonerate Output

        my @sorted_report  = sort { $a->get_query_start() <=> $b->get_query_start()
                               ||   $a->get_query_stop()  <=> $b->get_query_stop()   } @$ExoReports;

        
        my $FirstC4Report = shift(@sorted_report);
        next if !defined $FirstC4Report;
        my @grouped_reports = ( [ $FirstC4Report ] );

        while (@sorted_report) {
            my $NextC4Report     = shift(@sorted_report);
            my $PreviousGroup    = $grouped_reports[-1];
            my $PreviousC4Report = $PreviousGroup->[-1];

            my $NextStart        = $NextC4Report->get_query_start();
            my $PreviousStop     = $PreviousC4Report->get_query_stop();

            if ($NextStart > $PreviousStop || $PreviousStop-$NextStart < $overlappe_authorized) {
                push(@$PreviousGroup,$NextC4Report);
            } 
            else {
                push(@grouped_reports, [ $NextC4Report ]); # A brand new group is created
            }
        }
        
        my %group_len_covered = ();
        foreach my $groupref (@grouped_reports) {
           my $covered = 0;
           foreach my $report (@$groupref) {
               my $cover = abs($report->query_stop() - $report->query_start()) + 1;
               $covered += $cover;
           }
           $group_len_covered{$groupref} = $covered;
        }
        
        @grouped_reports = sort { $group_len_covered{$b} <=> $group_len_covered{$a}
                                                         ||
                                             scalar(@$a) <=> scalar(@$b)     
                                } @grouped_reports;

        foreach my $group (@grouped_reports) {
            my @exon_start_end = ();                                  # Tab with information about start and end of all exons present in Exonerte Output
            my %strand;
            foreach my $report (@$group) {
                my $features                 = $report->dnafeatures;  # $features contains all information present in the part GFF DNA per lines
                my $query_range              = $report->query_range;
                my ($start_query,$end_query) = ($query_range =~ m#(\d+)\s*->\s*(\d+)#);
                foreach my $lineobj (@$features) {
                    my $feat = $lineobj->feature;
                    next if $feat ne "exon";
                    my $strand_exon = $lineobj->strand;
                    $strand{1}++ if  $strand_exon eq "+";         # Just in order to know if we have a transpliced gene
                    $strand{-1}++ if $strand_exon eq "-";
                 }

                 my $isMinus = (($strand{1} && !$strand{-1}) ? 0 : 1);
                 $strand     =  1 if  !$isMinus;
                 $strand     = -1 if   $isMinus;
                 foreach my $lineobj (@$features) {
                     my $feat        = $lineobj->get_feature();
                     next if $feat ne "exon";
                     
                     my $start       = ($isMinus ? $lineobj->get_end() : $lineobj->get_start());
                     my $end         = ($isMinus ? $lineobj->get_start() : $lineobj->get_end());
                     my $strand_exon = $lineobj->get_strand();
                     my $attributes  = $lineobj->get_attributes();
                     
                     my $pair_start_end  = [ $start, $end, $strand_exon, $start_query, $attributes ];
                     push(@exon_start_end, $pair_start_end);           # @exon_start_end contain information about exon with start end and strand of each exons
                 }
             }

             if ($strand{1} && $strand{-1}) {
                 # If we have a transpliced gene 
                 my $path     = $OUTPUTFILE;
                 my $dirname  = dirname($path); # We must add condition in order to know if it isn't 2 genes
                 my $new_file = "$path".".Exonerate_"."$name";
                 my $number   = 1;
                 
                 &Add_comment_for_transpliced($contigname,$name,\@exon_start_end,$number);
                 
                 $add_text_in_header .= ";; The gene coding for $name is probably transpliced (see annotation in comments)\n";
                 next;
                 }

             @exon_start_end = sort {    ($a->[3] <=> $b->[3])
                                     ||  ($a->[0] <=> $b->[0])} @exon_start_end if $strand != -1; # Sort exons_start_end by start strand-

             @exon_start_end = sort {    ($a->[3] <=> $b->[3]) 
                                     ||  ($b->[0] <=> $a->[0])} @exon_start_end if $strand == -1; # Sort exons_start_end by start strand+
             
             # Correction about start and end of exon if two exons is overlapping #
             my $isMinus = ($strand == -1 ? 1 : 0);
             my @exon_start_end_cor =();                                             # Correction about start and end of exon if two exons is overlapping 
             for (my $i = 0; $i < (@exon_start_end-1); $i++) {                       
                 if ($strand != -1) {
                     if (!( ($exon_start_end[$i]->[1] < $exon_start_end[$i+1]->[0]) || ($exon_start_end[$i+1]->[1] < $exon_start_end[$i]->[0]) )) {  
                         # Take the minus start and the bigger stop if exons is on strand +
                         my $boolean = (($exon_start_end[$i]->[1] > $exon_start_end[$i+1]->[0]) == 1 ? 0 : 1);
                         my $start   = $exon_start_end[$i]->[0]   if !$boolean; # if E1_end > E2_start
                         my $end     = $exon_start_end[$i+1]->[1] if !$boolean; # if E1_end > E2_start
                            $start   = $exon_start_end[$i+1]->[0] if  $boolean; # if E2_end > E1_start
                            $end     = $exon_start_end[$i]->[1]   if  $boolean; # if E2_end > E1_start
                         my $strand_exon = $exon_start_end[$i]->[2];
                         my $quad_start_end = [ $start, $end, $strand_exon, $i , $exon_start_end[$i]->[3]]; # Start, End, Strand and Index 
                         push(@exon_start_end_cor, $quad_start_end);
                     }
                 }

                elsif ($strand == -1) {
                    if (!( ($exon_start_end[$i+1]->[0] < $exon_start_end[$i]->[1]) || ($exon_start_end[$i]->[0] < $exon_start_end[$i+1]->[1]) )) { 
                        # Take the minus start and the bigger stop if exons is on strand +
                        my $boolean = (($exon_start_end[$i+1]->[0] > $exon_start_end[$i]->[1]) == 1 ? 0 : 1);
                        my $start   = $exon_start_end[$i]->[0]   if !$boolean; # if E2_start > E1_end
                        my $end     = $exon_start_end[$i+1]->[1] if !$boolean; # if E2_start > E1_end
                           $start   = $exon_start_end[$i+1]->[0] if  $boolean; # if E1_start > E2_end
                           $end     = $exon_start_end[$i]->[1]   if  $boolean; # if E1_start > E2_end
                        my $strand_exon = $exon_start_end[$i]->[2];
                        my $quad_start_end  = [ $start, $end, $strand_exon, $i, $exon_start_end[$i]->[3]]; # Start, End, Strand and Index 
                        push(@exon_start_end_cor, $quad_start_end);
                    }
                }
            }

            @exon_start_end_cor = sort { $b->[3] <=> $a->[3] } @exon_start_end_cor; # Sort by index

            for (my $i=0; $i < @exon_start_end_cor; $i++) {
                splice(@exon_start_end,$exon_start_end_cor[$i]->[3],2); # Splice information about overlapping exons
            }

            for (my $i=0; $i < @exon_start_end_cor; $i++) {  # Push information about the new exon 
                my $start       = $exon_start_end_cor[$i]->[0];
                my $end         = $exon_start_end_cor[$i]->[1];
                my $strand_exon = $exon_start_end_cor[$i]->[2];
                my $start_query = $exon_start_end_cor[$i]->[4];
                my $tri         = [ $start, $end, $strand_exon, $start_query];
                push(@exon_start_end, $tri );  # Push information about the exon corrected into @exons_start_end
            }
    
            @exon_start_end = sort { $a->[3] <=> $b->[3] || $a->[0] <=> $b->[0] || $a->[1] <=> $b->[1] } @exon_start_end if $strand != -1;
            @exon_start_end = sort { $a->[3] <=> $b->[3] || $b->[0] <=> $a->[0] || $b->[1] <=> $a->[1] } @exon_start_end if $strand == -1;
            
            # Check if we haven't an exon that's makes no sense
            my ($gene_start,$gene_end) = ($exon_start_end[0]->[0],$exon_start_end[-1]->[1]);
            ($gene_start,$gene_end)    = ($gene_end,$gene_start) if $strand == -1;
            
            my $isTranspliced = 0;
            for (my $i = @exon_start_end - 1; $i >= 0 ; $i--) {
                my $start       = $exon_start_end[$i]->[0];
                my $end         = $exon_start_end[$i]->[1];
                next if !$start || !$end;
                if (($start < $gene_start ) || ($end > $gene_end)) {
                  my $file_with_alt = &Create_alternative_prot($dna_seq,\@exon_start_end,$i,$name);
                  my $delete_or_not = &Choose_best_solution($file_with_alt,$fileprot,$i,$name);
                  $isTranspliced = 1 if !$delete_or_not;
                  splice(@exon_start_end, $i, 1); # if !$isTranspliced;
                  &Add_comment_for_transpliced($contigname,$name,\@exon_start_end) if $isTranspliced;
                  $add_text_in_header .= ";; The gene coding for $name is probably transpliced (see annotation in comments)\n";
                  last if $isTranspliced;
                }
            }
            next if $isTranspliced;
            
            # Define the tab of intron with the information about exons localisation
            my @intron_start_end; 
            for (my $i = 0; $i < (@exon_start_end-1); $i++) {
                my $start  = $exon_start_end[$i]->[1] + 1;
                   $start  = $exon_start_end[$i]->[1] - 1   if $strand == -1;
                my $end    = $exon_start_end[$i+1]->[0] - 1;
                   $end    = $exon_start_end[$i+1]->[0] + 1 if $strand == -1;
                my $strand_intron = $exon_start_end[$i]->[2];
                my $tri = [$start,$end,$strand_intron];
                push(@intron_start_end, $tri);
            }

            my $newhypprot = undef;
            my $start = $exon_start_end[0]->[0];
            my $end   = $exon_start_end[-1]->[1];
            my $FirstExonerateMatch = $exon_start_end[0]->[3];
            $newhypprot = new PirObject::HypProt (
                                                  name       => $name,
                                                  contigname => $contigname,
                                                  exostart   => $start,
                                                  start      => $start,
                                                  end        => $end,
                                                  strand     => $strand,
                                                  numorfs    => 1,
                                                  remark     => "",
                                                  protein    => $protein,
                                                  exons      => [],
                                                  introns    => [],
                                                  homologous => $homologous,
                                                  firstExonerateMatch => $FirstExonerateMatch,
                                                  idbyexo    => 1
                                                 );
            push (@$HYPPROTS,  $newhypprot);
            
            if ($namefusiongene) {
                my $info_gene_fusion = new PirObject::HypFusion ( name => $namefusiongene );
                $newhypprot->set_hypfusiongene($info_gene_fusion);
            }

            my $newhypprotexonarray = $newhypprot->exons;
            for (my $i = 0; $i < @exon_start_end; $i++){
                # Fill information about exon
                my $attributes      = $exon_start_end[$i]->[4] || "";
                my $frameshift_size = $1 if $attributes =~ m/frameshifts\s+(\d+)/;
                my $hypprotexon = new PirObject::Exon (
                                                       dnastart  => $exon_start_end[$i]->[0],
                                                       dnaend    => $exon_start_end[$i]->[1],
                                                       strand    => $exon_start_end[$i]->[2],
                                                       frameshiftsize => $frameshift_size
                                                      );
                push (@$newhypprotexonarray, $hypprotexon); 
            }
            
            my $newhypprotintronarray = $newhypprot->introns;
            for (my $i = 0; $i < @intron_start_end; $i++){
                # Fill information about intron
                my $hypprotintron = new PirObject::Intron (
                                                           start  => $intron_start_end[$i]->[0],
                                                           end    => $intron_start_end[$i]->[1],
                                                           strand => $intron_start_end[$i]->[2],
                                                          );
                push (@$newhypprotintronarray, $hypprotintron);
            }
            &AdjustStart($newhypprot,$dna_seq);
        }
    }  # End of each prot
} # End sub

sub Create_alternative_prot {
    my $dna_seq        = shift;
    my $exon_start_end = shift;
    my $i              = shift;
    my $name           = shift;
    
     my $r_dna_seq = $dna_seq;
        $r_dna_seq =~ tr/ACGT/TGCA/;
        $r_dna_seq = reverse $r_dna_seq;
    my ($with_exons,$without_exons) = "";
    my $count = 0;
    foreach my $exon_coord (@$exon_start_end) {
       my $use_seq   = ( $exon_coord->[2] eq "-" ? $r_dna_seq : $dna_seq );
       my ($start,$stop) = ( $exon_coord->[2] eq "-" ? 
                           ( (length($use_seq) + 1 - $exon_coord->[0]),(length($use_seq) + 1 - $exon_coord->[1])) 
                           : ($exon_coord->[0],$exon_coord->[1]));
        my $exon_seq = substr($use_seq,$start-1,$stop-$start+1);
        $with_exons    .= $exon_seq;
        $without_exons .= $exon_seq if $count ne $i;
        $count++;
    }
    my $prot_with_exons     = ">With_exon\n";
       $prot_with_exons    .= &TranslateInProt($with_exons);
    my $prot_without_exons  = ">Without_exon\n";
       $prot_without_exons .= &TranslateInProt($without_exons);
    my $proteins            = "$prot_with_exons\n$prot_without_exons";
    
    my $fileprot = "$TMPDIR/Exonerate/for_blast_${name}_e$i";
    
    unlink($fileprot) or die "Impossible to delete $fileprot\n" if (-f $fileprot);
    # Create protein for exonerate
    my $FILEPROT = new IO::File ">$fileprot" or die "Impossible to open $fileprot\n";
    print $FILEPROT $proteins, "\n";
    $FILEPROT->close() or die "Impossible to close $fileprot\n";
    
    return $fileprot;
}

sub Choose_best_solution {
    # return 1 if we must to delete the exon else 0
    my $file_for_blast = shift;  # file with the 2 alternative seq
    my $protein_file   = shift;  # file with reference.
    my $i              = shift;
    my $name           = shift;
    
    # 1. FORMATDB
    my $base_name    = "$TMPDIR/Exonerate/mf_${name}_e$i";
    unlink($base_name) or die "Impossible to delete $base_name\n" if (-f $base_name);
    my $command      = "$FORMATDBPATH -p 'T' -t banque -i $protein_file -n $base_name -l $TMPDIR/Exonerate/fdb_exon.log >/dev/null 2>/dev/null";
    print "$command\n" if $DEBUG;
    my $resformatdb  = system($command);
    
    # 2. BLAST
    my $output         = "$TMPDIR/Exonerate/out_${name}_e$i";
    unlink($output) or die "Impossible to delete $output\n" if (-f $output);
    my $cmdblast = "$BLASTPATH -m 7 -p blastp -M $MATRIX -d $base_name -i $file_for_blast -o $output 2> $TMPDIR/Exonerate/blasterr_1.txt";
    print "$cmdblast\n" if $DEBUG;
    my $resblast = system ($cmdblast);
    
    my $searchfh = new IO::File "<$output"
       or die "Can't read from '$output': $!\n";
    
    my ($eval_with_exons,$eval_without_exons) = (9999,9999); # Very bad evalue 
    while (my $result = PirObject::BlastOutput->FileHandleToObject($searchfh)) {
        my $iterations = $result->BlastOutput_iterations() || next;
        foreach my $iteration (@$iterations) {
           my $rdesc = $iteration->Iteration_query_def() ||   # priority to iteration's value
                       $result->BlastOutput_query_def()  ||
                       "Unknown Query Description";

           my $hitslist = $iteration->Iteration_hits();
           return if @$hitslist < 1; # normally, only one.

           # Note: the significance() method is defined in Hit.pir
           my @hits = sort { &CompareHighPrecisionFloats($a->significance(), $b->significance() ) } @$hitslist;
           next if !$hits[0];
           my $evalue          = $hits[0]->significance(); # Get the e-value
           $eval_with_exons    = $evalue if $rdesc eq "With_exon";
           $eval_without_exons = $evalue if $rdesc eq "Without_exon";
        }
    }
    return ( $eval_without_exons < $eval_with_exons  ? 1 : 0);
}

sub Add_comment_for_transpliced {
    my $contigname     = shift;
    my $name           = shift;
    my $exon_start_end = shift;
    my $number         = shift || 1;
    
    foreach my $exon (@$exon_start_end) {
        my $start_exon  = $exon->[0];
        my $end_exon    = $exon->[1];
        my $strand_exon = $exon->[2];
        my $attributes  = $exon->[4];
        
        my $frameshift_size = $1 if $attributes =~ m/frameshifts\s+(\d+)/;
        
        my $arrow = "==>" if $strand_exon eq "+";
           $arrow = "<==" if $strand_exon eq "-";
        my $start_line  = ";; $name-E$number $arrow start";
           $start_line .= ";; frameshift of $frameshift_size nt" if $frameshift_size;
        my $end_line    = ";; $name-E$number $arrow end";
        
        my $hyp_prot = new PirObject::AnnotPair(
                                                 type      => "C",  
                                                 genename  => $name,
                                                 startpos  => $start_exon,
                                                 endpos    => $end_exon,
                                                 direction => $arrow,
                                                 startline => $start_line,
                                                 endline   => $end_line,
                                                 );
        &AddAnnotToPirMaster($pirmaster,$contigname,$hyp_prot);
        $number++;
     }
}


#------------------------------------#
# Subs for processing ORFs => genes  #
#------------------------------------#

sub TreatGeneFusion {
    # This function is supposing to find start
    # to find end for gene with exons and introns
    # to treat the case of gene fusion
    my $pirmaster      = shift;
    
    &AddInfoAboutGeneFusion($HYPPROTS);

    foreach my $hypprot (@$HYPPROTS) {
        my $strand      = $hypprot->get_strand();
        my $isMinus     = ($strand == 1 ? 0 : 1);
        my $contig      = $pirmaster->GetContigByName ($hypprot->get_contigname());
        my $exons       = $hypprot->get_exons();
        my $idByExo     = (scalar(@$exons) != 0 ? 1 : 0);
        
        my $seq         = $contig->get_sequence();                                   
           $seq         =~ s/!//g;
        my $len_seq     = length($seq);
        
        # We have a gene fusion.
        my $isFusioned = $hypprot->get_hypfusiongene() || undef;
        if ($isFusioned) {
            &TreatmentOfFusion($pirmaster,$hypprot,$contig,$isMinus,$len_seq,$exons);
        }
    } # End foreach $hypprot
} # End function

sub AddInfoAboutGeneFusion {
    my $hypprots = shift;
    
    foreach my $hypprot1 (@$hypprots) {
        my $contigname1 = $hypprot1->get_contigname();
        
        my $infofusiongene1 = $hypprot1->get_hypfusiongene() || undef;
        next if !$infofusiongene1;
        
        my $namefusiongene1 = $infofusiongene1->get_name() || undef;
        next if !$namefusiongene1;
        
        foreach my $hypprot2 (@$hypprots) {
            next if $hypprot1 eq $hypprot2;
            
            my $contigname2 = $hypprot2->get_contigname();
            next if $contigname1 ne $contigname2;
             
            my $genename2   = $hypprot2->get_name();
            next if $genename2 ne $namefusiongene1;
            my $start_f = $hypprot2->get_blaststart() || $hypprot2->get_exostart();
            $infofusiongene1->set_start($start_f);
            $infofusiongene1->set_end($hypprot2->get_end());
        }
    }
}

sub TreatmentOfFusion {
    my $pirmaster = shift;
    my $hypprot   = shift;
    my $contig    = shift;
    my $isMinus   = shift;
    my $len_seq   = shift;
    my $exons     = shift;
    my $idByExo   = (scalar(@$exons) != 0 ? 1 : 0);
        
    my $start_gene   = $hypprot->get_start();
       $start_gene   = ( $isMinus ? $len_seq - $start_gene + 1 : $start_gene);
    my $fusion_info  = $hypprot->get_hypfusiongene();
    my $startwarning = $hypprot->get_startwarning() || "";
    my $start_fusion = $fusion_info->get_start();
       $start_fusion = ( $isMinus ? $len_seq - $start_fusion + 1 : $start_fusion);
    my $fusion_name  = $fusion_info->get_name();
     
    # Add comment for the second gene
    if ($start_gene > $start_fusion) {
        my $simi_start = $hypprot->get_blaststart() || $hypprot->get_exostart();
        $hypprot->set_start($simi_start);
        my $first_exon =  $exons->[0]          if $idByExo;
        $first_exon->set_dnastart($simi_start) if $idByExo;
        $startwarning .= $startwarning ne "" ?
                         " / contiguous and in phase with $fusion_name" 
                         : "contiguous and in phase with $fusion_name";
        $hypprot->set_startwarning("$startwarning") if $startwarning;
        $hypprot->set_posiffusion(2);
        return;
    }
    
    $hypprot->set_posiffusion(1);
    # Adjust end if it's first gene
    my $newendpos  = ( $isMinus ? $len_seq - $start_fusion + 2 : $start_fusion - 1);
    $hypprot->set_end($newendpos);
    
    # Adjust end of last exon
    my $end_exon = $exons->[-1]       if $idByExo;
    $end_exon->set_dnaend($newendpos) if $idByExo;
}

#-------------------------------------------------#
# Subs for making annotations of mini exons       #
#-------------------------------------------------#

sub AnnotateMiniExons {
    # This fonction is used in order to identify mini exons
    my $pirmaster = shift;
    
    mkdir("$TMPDIR/Muscle_for_exons",0700) or die "Error: can't create work directory '$TMPDIR/Muscle_for_exons': $!\n";
    mkdir("$TMPDIR/Intron",0700) or die "Error: can't create work directory '$TMPDIR/Intron': $!\n";
    foreach my $hypprot (@$HYPPROTS) {
        my $name       = $hypprot->get_name();
        my $contigname = $hypprot->get_contigname();
        next if (not (defined ($name)) or ($name eq ""));
        
        my $contig      = $pirmaster->GetContigByName ($hypprot->contigname);  
        my $seq         = $contig->get_sequence();                                   
           $seq         =~ s/!//g;
        my $reverse_seq = $seq;
           $reverse_seq =~ tr/ACGT/TGCA/;
           $reverse_seq = reverse $reverse_seq;
           
        my $exons   = $hypprot->get_exons();
        my $introns = $hypprot->get_introns();
        next if scalar(@$exons) < 2;    # For protein with exon/intron
        
        my $prot_sequence      = &GetProteinSequenceAndIntronsPos($exons,$introns,$seq,$hypprot);
        next if $prot_sequence eq "Frame-Shift-Detected";
        $prot_sequence      = substr($prot_sequence, 0, -1);
        next if (index($prot_sequence,"*") >= 0 );
        
        my $file_for_alignment = &MakeFileForAlignment($hypprot,"Muscle_for_exons",3);
        
        my $result_file = $file_for_alignment;
           $result_file =~ s/.fasta$/.aln/;

        my $cmd = "$MUSCLEPATH -in $file_for_alignment -stable -clwstrict -out $result_file >/dev/null 2>/dev/null";
        print "\n$cmd\n" if $DEBUG;
        
        my $resultat = system ("$cmd");
        
        my $alignio = new Bio::AlignIO(-format => 'clustalw',
                                       -file   => $result_file);
                                       
        my $align = $alignio->next_aln();
        my $percent_id =  $align->percentage_identity();
        
        my $nt_frame    = 15;
INTRON: for (my $i = 0; $i < @$introns; $i++) {
            my $intron             = $introns->[$i];
            my $intron_pos_hypprot = $intron->get_intronpos();
            my $isMinus            = ($intron->get_strand() eq "+" ? 0 : 1);
            my $use_seq            = ($isMinus ? "$reverse_seq" : "$seq");
            my $len_seq            = length($seq);
            my ($hypprot_seq, $intron_pos_align) = &DefineSeqOfHypprotAndPosOfIntronInAlignment($align,$intron_pos_hypprot);
            
            # Make sub-alignement
            my ($sub_align_homologous,$intron_pos_sub) = &MakeSubAlignment($align,$hypprot_seq,$intron_pos_align,$nt_frame); 
            # Alignment of hypprot
            my $sub_align_hypprot    = &RemoveHypprotInAlignment($sub_align_homologous);
            # Percent of each aa on each pos in homologous prot
            my $percent              = &AaPercentInHomologous($sub_align_homologous);
            
            # Indicate if the position is conserved on hypprot 
            # compare hypprot aa with the other aa in alignment
            my $conserved_seq        = &CompareEachPosOfHypprotWithHomologous($sub_align_hypprot,$percent);
            # position of missing exon in sub-align
            my ($length_adjust_previous,$length_adjust_next) = &DefineAdjustIntron($conserved_seq,$intron_pos_sub,$percent_id);
            next if $length_adjust_previous eq "-" && $length_adjust_next eq "-"; # special convention
            next if $length_adjust_previous == 0 && $length_adjust_next == 0;
            my $sub_percent         = &DefineSeqOfResearchExon($percent,$intron_pos_sub,$length_adjust_previous,$length_adjust_next);
            foreach my $hash (@$sub_percent) {
                 while ( my ($nt_in_ref, $percent) = each(%$hash)) {
                     next INTRON if $nt_in_ref eq "-";
                     # Escape if we have a gap in homologous sequence around intron must be conserved. 
                 }
            }
            my $previous_exon = @$exons[$i]   || next;
            my $next_exon     = @$exons[$i+1] || next;
            &AdjustExonsIntron ($intron,$previous_exon,$next_exon,$length_adjust_previous,$length_adjust_next,"deconstruct",$isMinus);
            &LocateIntrons($seq,$intron,$name,$contigname,$pirmaster,$isMinus);
            my $apc = $intron->get_idbyRNAw() || die "idbyRNAw() is Empty\n";
            my $apl = $apc->get_annotpairlist();
            my $nb_intron = scalar(@$apl);
            if ($nb_intron > 2) {
                my $comment = "three introns found";
                $intron->set_comment($comment);
                next;
            }
            &SortAPL($apl,$isMinus) if $nb_intron > 1;
            if ($nb_intron < 2 && $length_adjust_previous + $length_adjust_next == 1) {
                # Initial annotation is considered to be true, let's return to it.
                &AdjustExonsIntron($intron,$previous_exon,$next_exon,$length_adjust_previous,$length_adjust_next,"reconstruct",$isMinus);
                next;
            }
            my $list_of_hyp_exons = &FindHypMiniExon($use_seq,$intron,$sub_percent,$isMinus,$nb_intron,$apl);
            #@$list_of_hyp_exons  = a tab with [seq,score,$length_prefix,$length_core,$length_suffix,$pos] foreach hyp exons
            if (@$list_of_hyp_exons == 0) {
                # No solution found, reconstruction of initial annnotation
                &AdjustExonsIntron($intron,$previous_exon,$next_exon,$length_adjust_previous,$length_adjust_next,"reconstruct",$isMinus);
                next; #next intron
            }
            &DefineEachIntronType($list_of_hyp_exons,$nb_intron,$apl,$isMinus,$len_seq);
            &AddSpliceScore($use_seq,$intron,$list_of_hyp_exons,$isMinus);
            @$list_of_hyp_exons   = sort {   $b->{"pam_score"} <=> $a->{"pam_score"}
                                          || $b->{"splice_score"} <=> $a->{"splice_score"}} @$list_of_hyp_exons;
            $list_of_hyp_exons    = &SelectBestHypExons($list_of_hyp_exons);
            if (@$list_of_hyp_exons == 0) {
                # No solution found
                &AdjustExonsIntron($intron,$previous_exon,$next_exon,$length_adjust_previous,$length_adjust_next,"reconstruct",$isMinus);
                next; #next intron
            }
            # At this point, all pam_scores are the same
            @$list_of_hyp_exons   = sort {   $b->{"splice_score"} <=> $a->{"splice_score"}
                                          || $a->{"core"}         <=> $b->{"core"}
                                          || $a->{"position"}     <=> $b->{"position"}} @$list_of_hyp_exons;
            my $best_solution     = shift(@$list_of_hyp_exons);
            &AddCommentsForOtherSolutions($hypprot,$i,$list_of_hyp_exons,$isMinus,$pirmaster,$contigname) if scalar(@$list_of_hyp_exons) > 0 ;
            &AddMiniExon($introns,$exons,$i,$best_solution,$isMinus);
            $i++; # Because we add an entry in @$introns
        }
    }
}

sub GetProteinSequenceAndIntronsPos {
    my $exons   = shift;
    my $introns = shift;
    my $seq     = shift;
    my $hypprot = shift;
    
    my $name         = $hypprot->get_name();
    my $dna_sequence = "";
    my $length_tot   = 0;
    for (my $i = 0 ; $i < scalar(@$exons) ; $i++) {
        my $hasFrameshift = $exons->[$i]->frameshiftsize();
        return "Frame-Shift-Detected" if $hasFrameshift;
        my $start         = $exons->[$i]->dnastart()   || next;
        my $end           = $exons->[$i]->dnaend()     || next;
        my $isMinus       = ($exons->[$i]->strand eq "+" ? 0 : 1);
        ($start,$end)     = ($end,$start) if $isMinus;
        my $length_exon   = $end - $start + 1;
        my $exon_seq      = uc (substr($seq, $start - 1 , $length_exon ));
        my $reverse_exon  = $exon_seq;
           $reverse_exon  =~ tr/ACGT/TGCA/;
           $reverse_exon  = reverse $reverse_exon;
           $dna_sequence .= (!$isMinus ? $exon_seq : $reverse_exon);
        my $start_pos     = int($length_tot/3) + 1;
        $length_tot      += $length_exon;
        my $end_pos       = int($length_tot/3);
        my $phase         = $length_tot % 3;
        $exons->[$i]->set_protstart($start_pos);
        $exons->[$i]->set_protend($end_pos);
        $introns->[$i]->set_intronpos($end_pos) if defined($introns->[$i]);
        $introns->[$i]->set_phase($phase)       if defined($introns->[$i]);
    }
    
    my $dna_length    = length($dna_sequence);
    die "The protein $name is not valid, its length is not a multiple of three\n"
       if $dna_length % 3 != 0;
       
    my $prot_sequence = &TranslateInProt($dna_sequence);
    $hypprot->set_thisprot($prot_sequence);
    return $prot_sequence;
}

sub MakeFileForAlignment {
    my $hypprot = shift;
    my $dir     = shift;
    my $length  = shift;
    
    my $name       = $hypprot->get_name();
    my $contigname = $hypprot->get_contigname();
    my $homologous = $hypprot->get_homologous();
    my $prot       = $hypprot->get_thisprot();
    my $flag       = $1 if  scalar($hypprot) =~ m/0x(.+)\)/;
    
    my $full_5 = "";
    my $name_of_file = "$TMPDIR/$dir/$contigname"."_$name"."_$flag.fasta";
    
    die "The file $name_of_file already exist"
        if (-e $name_of_file);
    
    # Open the file
    my $file_for_alignment = new IO::File ">$name_of_file" or die "Impossible to open $name_of_file\n";
    
    # Write into the file
    
    my $format_prot = &Format($prot); 
    print $file_for_alignment $format_prot;
    
    my $id = "a"; # Use in order to be sure that's two seq use by muscle have differnt name
    
    for (my $i = 0; $i < $length; $i++) {
        my $homologous = @$homologous[$i];
        last if !$homologous;
        my $similar_prot = $homologous->get_similarprot();
           $similar_prot =~ s/\n+$//;
           $similar_prot =~ s/^>(.+)/>$id $1/;
        print $file_for_alignment "$similar_prot\n\n";
        $id++;
    }
    
    # Close the file
    $file_for_alignment->close() or die "Impossible to close $name_of_file\n";
    return ($name_of_file);
}

sub Format {
    my $seq  = shift;
    
    my $format_seq = ">mfaprot\n";
    for (my $i = 0 ; $i <= length($seq); $i += 60 ) {
        my $rest_length = length($seq) - $i;
        if ( $rest_length <= 60 ) {
            $format_seq .= substr($seq, $i , $rest_length);
            $format_seq .= "\n";
        }
        else {
            $format_seq .= substr($seq, $i , 60);
            $format_seq .= "\n";
        }
    }
    return $format_seq;
}

sub DefineSeqOfHypprotAndPosOfIntronInAlignment {
    # In order to define the sequence of the hyppothetical protein
    # and to define the position of intron on the alignment.
    my $align              = shift;
    my $intron_pos_hypprot = shift;
    
    my $hypprot_seq        = undef;
    my $pos_in_alignment   = undef;
    foreach my $seq ($align->each_seq) {
        my $id = $seq->display_id();
        next if $id ne "mfaprot";
        $hypprot_seq      = $seq;
        $pos_in_alignment = $align->column_from_residue_number( $id, $intron_pos_hypprot);
        last;
    }
    return ($hypprot_seq, $pos_in_alignment);
}

sub MakeSubAlignment {
    # In order to make sub-alignment
    my $align       = shift;
    my $hypprot_seq = shift;
    my $pos         = shift;
    my $nt_frame    = shift;
    
    my $left_substring  = substr($hypprot_seq->seq(),0,$pos);
    my $right_substring = substr($hypprot_seq->seq(),$pos,length($hypprot_seq->seq())-$pos);
    my $left_length     = length($left_substring) - 1;
    my $right_length    = length($right_substring);
    my $num1            = ( $left_length >= ($nt_frame - 1) ? ($nt_frame - 1) : $left_length);
    my $num2            = ( $right_length >= $nt_frame ? $nt_frame : $right_length);
    my $sub_align       = $align->slice($pos - $num1 , $pos + $num2);

    return ($sub_align,$num1) ;
}

sub RemoveHypprotInAlignment {
    # Remove hypprot in each sub-alignment 
    # and return sub-alignment for hypprot.
    my $align = shift;
    
    my $sub_align_hypprot = undef;
    foreach my $seq ($align->each_seq) {
        next if $seq->display_id() ne "mfaprot";
        $sub_align_hypprot = $seq;
        $align->remove_seq($seq);
        last;
    }
    return $sub_align_hypprot;
}

sub AaPercentInHomologous {
    my $homologous_align = shift;
    
    my $position = [];
    my $length   = $homologous_align->length();
    my $nb_seq   = scalar($homologous_align->each_seq);
    for (my $pos = 1; $pos <= $length; $pos++) {
        my $count    = {};
        my $percent  = {};
        foreach my $seq ($homologous_align->each_seq) {
            my $sub = $seq->subseq($pos, $pos);
            $count->{$sub}++;
        }
        while ( my ($key, $value) = each(%$count) ) {
            my $percentage = ($value/$nb_seq);
            $percent->{ $key } = $percentage; 
        }
        $position->[$pos - 1] = $percent;
    }
    return $position;
}

sub CompareEachPosOfHypprotWithHomologous {
    my $sub_align_hypprot      = shift;
    my $percent_in_homologous  = shift;
    
    my $similarity = [];
    my $length     = $sub_align_hypprot->length();
    for (my $pos = 1; $pos <= $length; $pos++) {
        my $aa_in_homologous_same_pos = $percent_in_homologous->[$pos - 1];
        my $sub = $sub_align_hypprot->subseq($pos, $pos);
        my $aa  = ( $aa_in_homologous_same_pos->{$sub} ? "-" : $sub );
        $similarity->[$pos - 1] = $aa;
        # Put 1 in $pos when we have a similar aa in hypprot and in homologous protein.
        # Put a letter in $pos when we have a difference between hypprot and homologous.
    }
    return $similarity;
}

sub DefineAdjustIntron {
    # Define portion of non homologous region taking into account
    # of the accepeted separation between 2 disimilarity 
    my $conserved_seq  = shift;
    my $intron_pos     = shift;
    my $percent_id     = shift;
    
    my $string = join('', @$conserved_seq);
    # String is : -------------FLML---------- 
    # 1 is used for a similar aa in hypprot and in homologous protein.
    # Letters is used for when we have a difference between hypprot and homologous
    my $length       = length($string);
    
    my $left         = substr($string,0,$intron_pos+1);
    my $one_aa_left  = substr($string,$intron_pos,1);
    
    my $right        = substr($string,$intron_pos+1);
    my $one_aa_right = substr($string,$intron_pos+1,1);
    
    return ("-","-") if $one_aa_left eq "-"  && $one_aa_right eq "-" && $percent_id < 50; 
    
    my $missing_left  = &DefineMissingLeft($left);
    my $missing_right = &DefineMissingRight($right);
        
    my $length_left   = length($missing_left);
    my $length_right  = length($missing_right);
    my $length_tot    = $length_left + $length_right;
    return ("-","-") if $one_aa_left eq "-"  && $one_aa_right eq "-" && $length_tot < 2 && $percent_id < 50;
    return($length_left,$length_right);
}

sub DefineMissingLeft {
    my $substring = shift;
    
    my $length = length($substring);
    my $missing_left = "";
    my $max_similarity_accepted = 2;
    my $max_similarity_string = "";
    for (my $i = 0; $i < $max_similarity_accepted; $i++){
         $max_similarity_string .= "-";
    }
    for (my $i = $length; $i > 1; $i--){
        my $aa = substr($substring,$i - $max_similarity_accepted,$max_similarity_accepted);
        last if $aa eq $max_similarity_string;
        $aa = chop($aa) if $i != $max_similarity_accepted;
        $missing_left = $aa . $missing_left;
    }
    $missing_left =~ s/^-//;
    return $missing_left;
}

sub DefineMissingRight {
    my $substring = shift;
    
     my $length = length($substring);
    my $missing_right = "";
    my $max_similarity_accepted = 2;
    my $max_similarity_string = "";
    for (my $i = 0; $i < $max_similarity_accepted; $i++){
         $max_similarity_string .= "-";
    }
    for (my $i = 0; $i <= $length - $max_similarity_accepted; $i++){
        my $aa = substr($substring,$i,$max_similarity_accepted);
        last if $aa eq $max_similarity_string;
        $aa = substr($substring,$i,1) if $i != $length - $max_similarity_accepted;
        $missing_right .= $aa;
    }
    $missing_right =~ s/-$//;
    return $missing_right;
}

sub AdjustExonsIntron {
    my $intron                 = shift;
    my $previous_exon          = shift;
    my $next_exon              = shift;
    my $length_adjust_previous = shift;
    my $length_adjust_next     = shift;
    my $DeOrReConstruct        = shift;
    my $isMinus                = shift;
    
    my $first_adjust   = ($DeOrReConstruct eq "deconstruct" ? 1 : 0);
    my $phase          = $intron->get_phase();
    my $previous_m     = ($isMinus ?  3 : -3);
    my $next_m         = ($isMinus ? -3 :  3);
    my $adjust_i_start = ($isMinus ? -1 :  1);
    my $adjust_i_end   = ($isMinus ?  1 : -1);
    my $adjust_phase_previous = ($isMinus ? $phase : -$phase);
    my $adjust_phase_next     = ($isMinus ? (-(3 - $phase)) : (3 - $phase));
    
    my $adjust_end        = ($previous_m * $length_adjust_previous) + $adjust_phase_previous;
       $adjust_end        = -$adjust_end if !$first_adjust;
    my $previous_exon_end = $previous_exon->get_dnaend() + $adjust_end;
    my $intron_start      = $previous_exon_end + $adjust_i_start;
    $previous_exon->set_dnaend($previous_exon_end);
    $intron->set_start($intron_start);
    
    my $adjust_start      =  ($next_m * ($length_adjust_next-1)) + $adjust_phase_next;
       $adjust_start      = -$adjust_start if !$first_adjust;
    my $next_exon_start   = $next_exon->get_dnastart() + $adjust_start;
    my $intron_end        =  $next_exon_start + $adjust_i_end;
    $next_exon->set_dnastart($next_exon_start);
    $intron->set_end($intron_end);
}

sub DefineSeqOfResearchExon {
    my $percent                = shift;
    my $intron_pos_sub         = shift;
    my $length_adjust_previous = shift;
    my $length_adjust_next     = shift;
    
    my $start = $intron_pos_sub - $length_adjust_previous + 1;
    my $end   = $intron_pos_sub + $length_adjust_next;
    my $sub_percent  = [];
      @$sub_percent  = @$percent[$start..$end];
    return $sub_percent;
}

sub LocateIntrons {
    my $seq        = shift;
    my $intron     = shift;
    my $name       = shift;
    my $contigname = shift;
    my $pirmaster  = shift;
    my $isMinus    = shift;
    
    my $start = $intron->get_start();
    my $end   = $intron->get_end();
    ($start,$end) = ($end,$start) if $isMinus;
    my $length       = $end - $start + 1;
    my $intron_seq   = substr($seq,$start - 1,$length);
    
    my $conf_file       = PirObject::MfAnnotExternalProgs->ImportFromTextFile($EXTCONFIGFILE);
    my $genecomsets     = $conf_file->get_geneprogs(); # This is a HASH genename => <MfAnnotGeneCommandSet>
    my $commandobjectII = $genecomsets->{"IntronII"};
    my $commandobjectI  = $genecomsets->{"IntronI"};
    
    my $flag = $1 if  scalar($intron) =~ m/0x(.+)\)/;
    
    my $name_of_file      = "$TMPDIR/Intron/$name.$flag.fasta";
    my $outputfile_prefix = "$TMPDIR/Intron/$name.$flag";
    
    die "The file $name_of_file already exist"
        if (-e $name_of_file);
   
    # Open the file
    my $intron_file = new IO::File ">$name_of_file" or die "Impossible to open $name_of_file\n";
    
    # Write into the file
    print $intron_file ">myintron\n";
    print $intron_file $intron_seq;
    
    # Close the file
    $intron_file->close() or die "Impossible to close $name_of_file\n";
    
    my $annotpaircollectionsII = &ExecuteExternalProgram($commandobjectII,"IntronII",undef,$name_of_file,"$outputfile_prefix-II.xml");
    my $annotpaircollectionsI  = &ExecuteExternalProgram($commandobjectI,"IntronI",  undef,$name_of_file,"$outputfile_prefix-I.xml");
    my $annotpaircollection    = &MakeOneApCollection($annotpaircollectionsII,$annotpaircollectionsI,$contigname);
    &AddGroup($intron,$annotpaircollection);
    &AddInfoAboutIdIntrons($intron,$annotpaircollection,$pirmaster,$contigname,$isMinus);
}

sub MakeOneApCollection {
    my $annotpaircollectionsII = shift;
    my $annotpaircollectionsI  = shift;
    my $contigname             = shift;
    
    my $annotpaircollection = new PirObject::AnnotPairCollection(
                                   genename   => "Intron",
                                   contigname => $contigname,
                                   annotpairlist => [],
    );
    
    my $annotpairlistarray = $annotpaircollection->get_annotpairlist();

    foreach my $AnnotPairCollection (@$annotpaircollectionsI,@$annotpaircollectionsII) {
        my $annotpairlist = $AnnotPairCollection->get_annotpairlist();
        push(@$annotpairlistarray, @$annotpairlist);
    }
    
    return $annotpaircollection;
}

sub AddGroup {
    my $intron = shift;
    my $annotpaircollection = shift;
    
    my $annotpairlist = $annotpaircollection->get_annotpairlist();
    foreach my $AnnotPair (@$annotpairlist) {
        my $AP_startline = $AnnotPair->get_startline();
        my $AP_endline   = $AnnotPair->get_endline();
            
        my $type        = $1    if $AP_startline =~ m#;;.*start\s*:\s*(.+)#;
        die "Internal error : external AP does not contain type on startline?!?\n" unless $type;
            
        my $intron_type  = $intron->get_type() || "";
           $intron_type .= "," if $intron_type;
           $intron_type .= $type;    
           $intron->set_type($intron_type);
    }
}

sub AddInfoAboutIdIntrons {
    # Used in order to define position of AP in whole masterfile
    my $intron               = shift;
    my $annotpaircollection  = shift;
    my $pirmaster            = shift;
    my $contigname           = shift;
    my $isMinus              = shift;
    my $i_start              = $intron->get_start();
    my $i_end                = $intron->get_end();

    
    my $annotpairlist = $annotpaircollection->get_annotpairlist();
    foreach my $AnnotPair (@$annotpairlist) {
        my $AP_start = $AnnotPair->get_startpos();
        my $AP_end   = $AnnotPair->get_endpos();
        my $new_start = $i_start + $AP_start - 1;
           $new_start = $i_end   + $AP_start - 1 if $isMinus;
        my $new_end   = $i_start + $AP_end   - 1;
           $new_end   = $i_end   + $AP_end   - 1 if $isMinus;
        $AnnotPair->set_startpos($new_start);
        $AnnotPair->set_endpos($new_end);
    }
    $intron->set_idbyRNAw($annotpaircollection);
}

sub SortAPL {
    my $apl     = shift;
    my $isMinus = shift;

    @$apl = sort { $a->get_startpos() <=> $b->get_startpos() } @$apl
        if !$isMinus;    
    @$apl = sort { $b->get_startpos() <=> $a->get_startpos() } @$apl
        if $isMinus;
}

sub FindHypMiniExon {
    my $seq          = shift;
    my $intron       = shift;
    my $research_seq = shift;
    my $isMinus      = shift;
    my $nb_intron    = shift;
    my $apl          = shift;
    
    my $len_seq = length($seq);
    my $intron_start = $intron->get_start();                           # Bio coord
    my $intron_end   = $intron->get_end();                             # Bio coord
       $intron_start = $len_seq + 1 - $intron_start if $isMinus;
       $intron_end   = $len_seq + 1 - $intron_end   if $isMinus;
    
    my $list_of_hyp_exons      = [];
    my $zones                  = &DefineZone($intron,$isMinus,$intron_start,$intron_end,$len_seq);
    my $aa_length_missing_exon = scalar(@$research_seq);
    my $region_nt_length       = $aa_length_missing_exon * 3;
    my $MIN_EXON_LENGTH        = 3;
    my $best_pam_score         = &Calculate_best_PamScore($research_seq);
    my $max_score_in_matrix    = $matrix->get_entry("W","W");                 # Max score on the diagonal of PAM matrix
    my $min_pam_score          = $best_pam_score - ($aa_length_missing_exon * 1/4 * $max_score_in_matrix);
    
    for (my $i = 0; $i < scalar(@$zones); $i++) {
        my $z_start = @$zones[$i]->[0];  # Computer coord
        my $z_end   = @$zones[$i]->[1];  # Computer coord
        my $length  = $z_end - $z_start + 1;
        next if $length < $MIN_EXON_LENGTH;
        foreach my $length_prefix (0 .. ($region_nt_length - $MIN_EXON_LENGTH)) {
#print STDERR "ZONE = $i    PREFIX = $length_prefix    TIME = ",(time - $^T),"\n";
            foreach my $length_suffix (0 .. ($region_nt_length - $MIN_EXON_LENGTH-$length_prefix)) {
                my $nt_length_missing_exon = $region_nt_length - ($length_prefix + $length_suffix);
                next if $nt_length_missing_exon > $region_nt_length;
                
                my $prefix = substr($seq,$intron_start - 1,$length_prefix);
                my $suffix = substr($seq,$intron_end - $length_suffix,$length_suffix);
                foreach my $pos ($z_start..($z_end-$nt_length_missing_exon)) {
                    my $core        = substr($seq,$pos,$nt_length_missing_exon);
                    my $length_core = length($core);
                    my $exon_seq    = $prefix.$core.$suffix;
                    my $prot_seq    = &TranslateInProt($exon_seq);
                    next if index($prot_seq, "*") >= 0 ;
                    my $pam_score        = &CalculatePamScore($prot_seq,$research_seq);
                    next if $pam_score < $min_pam_score;
                    my $len_fisrt_intron = $pos - $intron_start + 1;
                    my $info_about_hyp_exon = { seq       => $prot_seq,
                                                pam_score => $pam_score,
                                                prefix    => $length_prefix,
                                                core      => $length_core,
                                                suffix    => $length_suffix,
                                                position  => $pos,
                                                len_first_intron => $len_fisrt_intron
                                              };
                    push(@$list_of_hyp_exons,$info_about_hyp_exon);
                }
            }
        }
        @$list_of_hyp_exons   = sort { $b->{"pam_score"} <=> $a->{"pam_score"} } @$list_of_hyp_exons;
        next if !@$list_of_hyp_exons;
        return $list_of_hyp_exons if @$list_of_hyp_exons[0]->{"pam_score"} == $best_pam_score;
    }
    return $list_of_hyp_exons;
}

sub DefineZone {
    my $intron       = shift;
    my $isMinus      = shift;
    my $intron_start = shift;
    my $intron_end   = shift;
    my $len_seq      = shift; 
    
    my $apc        = $intron->get_idbyRNAw();
    my $apl        = $apc->get_annotpairlist();
    my $nb_intron  = scalar(@$apl);
    my $zone_coord = [];
    
    if ($nb_intron == 0) {
        my $start = $intron_start + $MININTRONSIZE - 1;
        my $end   = $intron_end   - $MININTRONSIZE - 1;
        push(@$zone_coord, [$start,$end]);
    }
    elsif ($nb_intron == 1) {
        my $ap = $apl->[0];
        my ($ap_start,$ap_end) = &ApPosStrandFW($ap,$len_seq);
        my $start1   = $intron_start + $MININTRONSIZE - 1;
        my $end1     = $ap_start - 2;
        my $start2   = $ap_end;
        my $end2     = $intron_end - $MININTRONSIZE - 1;
        push(@$zone_coord, [$start1,$end1]) if $end1   > $start1;
        push(@$zone_coord, [$start2,$end2]) if $end2   > $start2;
    }
    elsif ($nb_intron == 2) {
        my $ap1 = $apl->[0];
        my $ap2 = $apl->[1];
        my ($ap1_start,$ap1_end) = &ApPosStrandFW($ap1,$len_seq);
        my ($ap2_start,$ap2_end) = &ApPosStrandFW($ap2,$len_seq);
        
        my $start1   = $intron_start + $MININTRONSIZE - 1;
        my $end1     = $ap1_start - 2;
        my $start2   = $ap1_end;
        my $end2     = $ap2_start - 2;
        my $start3   = $ap2_end;
        my $end3     = $intron_end - $MININTRONSIZE - 1;
        push(@$zone_coord, [$start2,$end2]) if $end2   > $start2;  # Central zone in first
        push(@$zone_coord, [$start1,$end1]) if $end1   > $start1;
        push(@$zone_coord, [$start3,$end3]) if $end3   > $start3;
    }
    return $zone_coord;
}

sub Calculate_best_PamScore {
    my $research_seq = shift;
    
    my $length =  scalar(@$research_seq);
    my $score = 0;
    foreach my $pos (0 .. $length - 1){
        my $hash_of_nt     = $research_seq->[$pos];
        while ( my ($nt_in_ref, $percent) = each(%$hash_of_nt)) {
            $score += $percent * $matrix->get_entry($nt_in_ref,$nt_in_ref) if $nt_in_ref ne "-";
        }
    }
    return $score;
}

sub CalculatePamScore {
    my $seq_of_hyp_exon = shift;
    my $research_seq    = shift;
    
    die "Hypothetic exon have not the same length that research seq" 
        if scalar(@$research_seq) != length($seq_of_hyp_exon);
    my $length =  length($seq_of_hyp_exon);
    
    my $score = 0;
    foreach my $pos (0 .. $length - 1){
        my $nt_in_hyp_exon = substr($seq_of_hyp_exon,$pos,1);
        my $hash_of_nt     = $research_seq->[$pos];
        while ( my ($nt_in_ref, $percent) = each(%$hash_of_nt)) {
            $score += $percent * $matrix->get_entry($nt_in_hyp_exon,$nt_in_ref);
        }
    }
    return $score;
}

sub SelectBestHypExons {
    my $list_of_hyp_exons = shift;
    
    my $best_hyp_exons   = [];
    
    my $best_pam_score    = @$list_of_hyp_exons[0]->{"pam_score"};
    my $best_splice_score = @$list_of_hyp_exons[0]->{"splice_score"};
    my $best_position     = @$list_of_hyp_exons[0]->{"position"};
    my $best_core         = @$list_of_hyp_exons[0]->{"core"};
    
    foreach my $hyp_exon (@$list_of_hyp_exons) {
        my $pam_score    = $hyp_exon->{"pam_score"};
        my $splice_score = $hyp_exon->{"splice_score"};
        my $position     = $hyp_exon->{"position"};
        my $core         = $hyp_exon->{"core"};
        next if $pam_score < $best_pam_score;
        next if $splice_score < $best_splice_score - 0.05;
        next if abs($best_position - $position) < 6 && abs($best_position - $position) != 0;
        next if abs(($best_position + $best_core) - ($position + $core)) < 6 && abs(($best_position + $best_core) - ($position + $core)) != 0;
        push(@$best_hyp_exons,$hyp_exon);
    }
    return $best_hyp_exons;
}

sub DefineEachIntronType {
    my $best_hyp_exons = shift;
    my $nb_intron      = shift;
    my $apl            = shift;
    my $isMinus        = shift;
    my $len_seq        = shift;
    
    foreach my $best_hyp_exon (@$best_hyp_exons) {
        my $hyp_exon_pos = $best_hyp_exon->{"position"};
        if ($nb_intron == 0) {
             $best_hyp_exon->{"ap_first_intron"}  = undef;
             $best_hyp_exon->{"ap_second_intron"} = undef;
        }
        elsif ($nb_intron == 1) {
            my $ap = $apl->[0];
                        
            my ($ap_start,$ap_end) = &ApPosStrandFW($ap,$len_seq);
            $best_hyp_exon->{"ap_first_intron"}  = undef if $hyp_exon_pos <  $ap_start;
            $best_hyp_exon->{"ap_second_intron"} = $ap   if $hyp_exon_pos <  $ap_start;
            $best_hyp_exon->{"ap_first_intron"}  = $ap   if $hyp_exon_pos >= $ap_start;
            $best_hyp_exon->{"ap_second_intron"} = undef if $hyp_exon_pos >= $ap_start;
        }
        elsif ($nb_intron == 2) {
            my $ap1 = $apl->[0];
            my ($ap1_start,$ap1_end) = &ApPosStrandFW($ap1,$len_seq);
            
            my $ap2 = $apl->[1];
            my ($ap2_start,$ap2_end) = &ApPosStrandFW($ap2,$len_seq);
            
            $best_hyp_exon->{"ap_first_intron"}  = undef  if $hyp_exon_pos <  $ap1_start;
            $best_hyp_exon->{"ap_second_intron"} = $ap1   if $hyp_exon_pos <  $ap1_start;
            $best_hyp_exon->{"ap_first_intron"}  = $ap2   if $hyp_exon_pos >= $ap2_start;
            $best_hyp_exon->{"ap_second_intron"} = undef  if $hyp_exon_pos >= $ap2_start;
            $best_hyp_exon->{"ap_first_intron"}  = $ap1   if ($ap1_start < $hyp_exon_pos && $hyp_exon_pos < $ap2_start);
            $best_hyp_exon->{"ap_second_intron"} = $ap2   if ($ap1_start < $hyp_exon_pos && $hyp_exon_pos < $ap2_start);
         }
    }
}

sub AddSpliceScore {
    my $seq            = shift;
    my $old_intron     = shift;
    my $best_hyp_exons = shift;
    my $isMinus        = shift;

    foreach my $best_hyp_exon (@$best_hyp_exons) {
        my $score_nt_first_intron   = 0;
        my $score_nt_second_intron  = 0;
        my $start_old_intron        = $old_intron->get_start();
        my $end_old_intron          = $old_intron->get_end();
           $start_old_intron        = length($seq) + 1 - $start_old_intron if $isMinus;
           $end_old_intron          = length($seq) + 1 - $end_old_intron   if $isMinus;
        
        my $start_first_intron      = $start_old_intron + $best_hyp_exon->{"prefix"};
        my $end_first_intron        = $best_hyp_exon->{"position"};
        
        my $type_first_intron = "";
        if ($best_hyp_exon->{"ap_first_intron"}) { 
        my $first_intron            = $best_hyp_exon->{"ap_first_intron"};
        my $first_intron_startline  = $first_intron->get_startline();
        my $type_first_intron       = $1    if $first_intron_startline =~ m#;;.*start\s*:\s*(.+)#;
            die "Internal error : external AP does not contain type on startline?!?\n" unless $type_first_intron;
        }
        
        my $start_second_intron     = $end_first_intron + $best_hyp_exon->{"core"} + 1;
        my $end_second_intron       = $end_old_intron - $best_hyp_exon->{"suffix"};
        
        my $type_second_intron = "";
        if ($best_hyp_exon->{"ap_second_intron"}) { 
        my $second_intron           = $best_hyp_exon->{"ap_second_intron"} if $best_hyp_exon->{"ap_second_intron"};
        my $second_intron_startline = $second_intron->get_startline();
        my $type_second_intron      = $1    if $second_intron_startline =~ m#;;.*start\s*:\s*(.+)#;
            die "Internal error : external AP does not contain type on startline?!?\n" unless $type_second_intron;
        }
        
        my $best_splice_core    = 0;
           $best_splice_core   += 25   if $type_first_intron  ne "II";
           $best_splice_core   += 64.5 if $type_first_intron  eq "II";
           $best_splice_core   += 25   if $type_second_intron ne "II";
           $best_splice_core   += 64.5 if $type_second_intron eq "II";
        if ($type_first_intron eq "II") {
            $score_nt_first_intron = &ScoreNtLTypeII($seq,$start_first_intron,0) 
                                   + &ScoreNtRTypeII($seq,$end_first_intron,0);
        } else {
            $score_nt_first_intron = &ScoreNtLTypeI($seq,$start_first_intron,0) 
                                   + &ScoreNtRTypeI($seq,$end_first_intron,0);
        }
        if ($type_second_intron eq "II") {
            $score_nt_second_intron = &ScoreNtLTypeII($seq,$start_second_intron,0) 
                                    + &ScoreNtRTypeII($seq,$end_second_intron,0);
        } else {
            $score_nt_second_intron = &ScoreNtLTypeI($seq,$start_second_intron,0) 
                                    + &ScoreNtRTypeI($seq,$end_second_intron,0);
        }
        $best_hyp_exon->{"splice_score"} = ($score_nt_first_intron + $score_nt_second_intron) / $best_splice_core;
    }
}

sub AddMiniExon {
    my $introns        = shift;
    my $exons          = shift;
    my $i              = shift;
    my $best_solution  = shift;
    my $isMinus        = shift;
    
    my $prefix_len            = ( $isMinus ? -$best_solution->{"prefix"} :  $best_solution->{"prefix"});
    my $core_len              = ( $isMinus ? -$best_solution->{"core"}   :  $best_solution->{"core"});  
    my $suffix_len            = ( $isMinus ?  $best_solution->{"suffix"} : -$best_solution->{"suffix"}); 
    my $first_intron_len      = ( $isMinus ? -$best_solution->{"len_first_intron"} : $best_solution->{"len_first_intron"});
    my $strand                = ( $isMinus ? "-" : "+");
    my $adjust_start_new_exon = ( $isMinus ?  -1 :  1);
    my $adjust_end_new_exon   = ( $isMinus ?   1 : -1);
    my $adjust_start_intron   = ( $isMinus ?  -1 :  1);
    my $adjust_end_intron     = ( $isMinus ?   1 : -1);
    
    my $exon_prev    = $exons->[$i];
    my $large_intron = $introns->[$i];
    
    # Exons #
    # Adjust end of previous exon
    my $end_of_previous_exon = $exon_prev->get_dnaend() + $prefix_len;
    $exon_prev->set_dnaend($end_of_previous_exon);
    
    # Add the mini exon
    my $start_of_new_exon = $end_of_previous_exon - $prefix_len + $first_intron_len + $adjust_start_new_exon;
    my $end_of_new_exon   = $start_of_new_exon + $core_len + $adjust_end_new_exon;
    my $new_exon = new PirObject::Exon (
                                             dnastart  => $start_of_new_exon,
                                             dnaend    => $end_of_new_exon,
                                             strand    => $strand
                                           );
    splice(@$exons, $i + 1, 0, $new_exon);
    
    # Adjust start of next exon
    my $exon_next = $exons->[$i+2];
    my $start_of_next_exon  = $exon_next->get_dnastart() + $suffix_len;
    $exon_next->set_dnastart($start_of_next_exon);
    
    # Introns #
    my $apc                   = $large_intron->get_idbyRNAw();
    # The first intron
    my $start_of_first_intron = $end_of_previous_exon + $adjust_start_intron;
    my $end_of_first_intron   = $start_of_new_exon    + $adjust_end_intron;
    my $first_intron_apc      = $apc->DeepClone();
    
    my $first_intron = new PirObject::Intron (
                                             start    => $start_of_first_intron,
                                             end      => $end_of_first_intron,
                                             strand   => $strand,
                                             idbyRNAw => $first_intron_apc
                                           );
    my $ap_first_intron = $best_solution->{"ap_first_intron"};
    if ($ap_first_intron) {
        my $apc1               = $first_intron->get_idbyRNAw();
        my $annotpairlistarray = [$ap_first_intron];
        $apc1->set_annotpairlist($annotpairlistarray);
        my $startline  = $ap_first_intron->get_startline();           
        my $type       = $1    if $startline =~ m#;;.*start\s*:\s*(.+)#;
        die "Internal error : external AP does not contain type on startline?!?\n" unless $type;
        $first_intron->set_type($type);
    }

    # The second intron
    my $start_of_second_intron = $end_of_new_exon     + $adjust_start_intron;
    my $end_of_second_intron   = $start_of_next_exon  + $adjust_end_intron;
    my $second_intron_apc      = $apc->DeepClone();
    
    my $second_intron = new PirObject::Intron (
                                             start    => $start_of_second_intron,
                                             end      => $end_of_second_intron,
                                             strand   => $strand,
                                             idbyRNAw => $second_intron_apc
                                           );
    
    my $ap_second_intron = $best_solution->{"ap_second_intron"};
    if ($ap_second_intron) {
        my $apc2               = $second_intron->get_idbyRNAw();
        my $annotpairlistarray = [$ap_second_intron];
        $apc2->set_annotpairlist($annotpairlistarray);
        my $startline  = $ap_second_intron->get_startline();           
        my $type       = $1    if $startline =~ m#;;.*start\s*:\s*(.+)#;
        die "Internal error : external AP does not contain type on startline?!?\n" unless $type;
        $second_intron->set_type($type);
    }
    
    splice(@$introns, $i, 1);
    splice(@$introns, $i, 0, $first_intron,$second_intron);
}

sub AddCommentsForOtherSolutions {
    my $hyprot         = shift;
    my $i              = shift;
    my $best_hyp_exons = shift;
    my $isMinus        = shift;
    my $pirmaster      = shift;
    my $contigname     = shift;
    
    my ($introns,$exons) = ( $hyprot->get_introns(), $hyprot->get_exons());
    
    my $strand       = ( $isMinus ? "-" : "+");
    my $arrow        = ( $isMinus ? "<==" : "==>");
    my $exon_prev    = $exons->[$i];
    my $exon_next    = $exons->[$i+1];
    
    my $list_alt_exons = $hyprot->get_altexons();
    foreach my $solution (@$best_hyp_exons) {
        
        my $prefix_len            = ( $isMinus ? -$solution->{"prefix"} :  $solution->{"prefix"});
        my $core_len              = ( $isMinus ? -$solution->{"core"}   :  $solution->{"core"});
        my $suffix_len            = ( $isMinus ?  $solution->{"suffix"} : -$solution->{"suffix"});
        my $first_intron_len      = ( $isMinus ? -$solution->{"len_first_intron"} : $solution->{"len_first_intron"});
        my $adjust_start_new_exon = ( $isMinus ?  -1 :  1);
        my $adjust_end_new_exon   = ( $isMinus ?   1 : -1);
        my $number_exon           = $i+2;
        
        # Define end of previous exon.
        my $end_of_previous_exon = $exon_prev->get_dnaend() + $prefix_len;
        
        # Define pos of hypothetic exon.
        my $start_of_hyp_exon = $end_of_previous_exon - $prefix_len + $first_intron_len + $adjust_start_new_exon;
        my $end_of_hyp_exon   = $start_of_hyp_exon + $core_len + $adjust_end_new_exon;
        
        # Define start of next exon.
        my $start_of_next_exon  = $exon_next->get_dnastart() + $suffix_len;
        
        my $start_line = ";; Alternative solution for exon $number_exon, end previous exon = $end_of_previous_exon";
        my $end_line   = ";; Alternative solution for exon $number_exon, start next exon = $start_of_next_exon";
        
        my $AP = new PirObject::AnnotPair(
                                      type      => "G",
                                      genename  => "comment",
                                      startpos  => $start_of_hyp_exon,
                                      endpos    => $end_of_hyp_exon,
                                      direction => $arrow,
                                      startline => $start_line,
                                      endline   => $end_line,
                                      ); 
        push(@$list_alt_exons, $AP);
        &AddAnnotToPirMaster($pirmaster,$contigname,$AP);
    }
    $hyprot->set_altexons($list_alt_exons);
}

#-------------------------------------------------#
# Subs for putting annotations in the masterfile  #
#-------------------------------------------------#

sub AnnotateMfFromHYPPROTSArray {
    # This function annotates the masterfile from the blast results
    my $pirmaster = shift;

    foreach my $hyprot (@$HYPPROTS) {
        my $name = $hyprot->name;
        next if (not (defined ($name)) or ($name eq ""));
        
        my $contigname = $hyprot->get_contigname();
        my $contig     = $pirmaster->GetContigByName($contigname);
        my $start      = $hyprot->get_start();
        my $alt_start  = $hyprot->get_altstart();
        my $end        = $hyprot->get_end();
        my $prot       = $hyprot->get_protein();
        my $exons      =  $hyprot->get_exons();
        my $isMinus    = ($hyprot->get_strand() == 1 ? 0 : 1);
        my $fusion     = $hyprot->get_hypfusiongene();
        my $idByBlast  = $hyprot->get_idbyblast();
        my $idByExo    = $hyprot->get_idbyexo();
        my $frameshift = $hyprot->get_frameshift();
        my $homologous = $hyprot->get_homologous();
        my $arrow      = ($isMinus ? '<==' : '==>');
        my $tag        = $hyprot->get_remark();
        
        my $NotToAnnot = &CheckIfHypIsInAFamily($hyprot,$contig);
        next               if $NotToAnnot == 1;
        my $ToComment  = 1 if $NotToAnnot == 2;
        
        my ($startwarning,$endwarning) = &DefStartAndEndWarning($hyprot);
        
        # Annot the gene
        my $linename             = $name;                     # The name gene in start and endline
        my ($startline,$endline) = ( $ToComment ? (";",";") : ("",""));
        
        # Define start line and end line
        $startline  .= ";     G-$linename $arrow start";
        $startline  .= " ;; MFFEAT=$TAGNAME ;; $tag" if $ADDCOMMENTS; # Add comments if option is checked
        $endline    .= ";     G-$linename $arrow end";
        $endline    .= " ;; MFFEAT=$TAGNAME ;; $tag" if $ADDCOMMENTS; # Add comments if option is checked
        
        my $isFusioned      = $hyprot->get_hypfusiongene() || undef;
        my $startlinenumber = ( $isMinus && $isFusioned ? 0 : 2);
        my $endlinenumber   = ( $isMinus && $isFusioned ? 2 : 0);
        
        my $info_fusion     = $hyprot->get_hypfusiongene() || undef;
        my $fusion_name     = $info_fusion->get_name()     || undef if $info_fusion;
        my $posiffusion     = $hyprot->get_posiffusion()   || undef;
        
        my $len_orf = 0;
        if ( !(defined($isFusioned)) && $alt_start && (abs($start-$alt_start)/3 >= 100)  ) {
            $len_orf     = abs($start-$alt_start)/3;
            $fusion_name = "orf$len_orf";
            $posiffusion = 2;
            $startlinenumber = ( $isMinus ? 0 : 2);
            $endlinenumber   = ( $isMinus ? 2 : 0);
        }
        
        my $A_type           = "C" if $ToComment;
        my $altexons         = $hyprot->get_altexons();
        my $FirstMissingExon = ($hyprot->get_firstExonerateMatch() && $hyprot->get_firstExonerateMatch() > 10) ? 1 : 0;
        my $protannot = new PirObject::AnnotPair (
                                                   type              => $A_type || "G", 
                                                   genename          => "$name",
                                                   startpos          => $start,
                                                   endpos            => $end,
                                                   direction         => $arrow,
                                                   startline         => $startline,
                                                   endline           => $endline,
                                                   startlinenumber   => $startlinenumber,
                                                   endlinenumber     => $endlinenumber,
                                                   posiffusion       => $posiffusion,
                                                   namefusiongene    => $fusion_name,
                                                   idbyblast         => $idByBlast,
                                                   idbyexo           => $idByExo,
                                                   altexons          => $altexons,
                                                   firstmissingexon  => $FirstMissingExon
                                                 );
                                                 
        # Add comment for frameshift
        $startwarning .= ($startwarning ne "" ?
                         " / present probably a frameshift" 
                       : "present probably a frameshift") 
                           if $frameshift;

        # Add comment for alternative start
        $startwarning .= ($startwarning ne "" ?
                         " / alternative start at pos $alt_start" 
                       : "alternative start at pos $alt_start")
                           if (!$fusion && $alt_start && $len_orf < 100);
        
        # Annotation of fusion between Orf and gene
        if ($alt_start && $len_orf >= 100 && !$fusion) {
            my $orf_end                = ( $isMinus ? $start + 1 : $start - 1);
            my ($start_line,$end_line) = ( $ToComment ? (";",";") : ("",""));
               $start_line            .= ";     G-$fusion_name $arrow start";
               $end_line              .= ";     G-$fusion_name $arrow end";
            
            my $orfannot = new PirObject::AnnotPair (
                                       type              => $A_type || "G", 
                                       genename          => $fusion_name,
                                       startpos          => $alt_start,
                                       endpos            => $orf_end,             # gene start
                                       direction         => $arrow,
                                       startline         => $start_line,
                                       endline           => $end_line,
                                       startlinenumber   => $startlinenumber,
                                       endlinenumber     => $endlinenumber,
                                       namefusiongene    => $name,
                                       posiffusion       => 1
                                     );
            &AddAnnotToPirMaster($pirmaster,$contigname,$orfannot);
            $startwarning .= ($startwarning ne "" ?  
                         " / contiguous and in phase with $fusion_name" 
                       : "contiguous and in phase with $fusion_name");
        }
        
        my ($prot_startline,$prot_endline) = ($protannot->get_startline(),$protannot->get_endline());
        $prot_startline .= " ;; $startwarning" if $startwarning;
        $prot_endline   .= " ;; $endwarning"   if $endwarning;
        $protannot->set_startline($prot_startline);
        $protannot->set_endline($prot_endline);
        
        my $res = &AddAnnotToPirMaster($pirmaster,$contigname,$protannot);

        # Go out of the function if the protein has not been added
        if (!defined ($res) or $res == 0) {
            $ANNOT_STATS->{'Rediscovered'}->{$protannot->genename}->{'E'} += scalar (@$exons) if (scalar (@$exons) > 0);
            next;
        } 

        next if ($name =~ /^orf/);       # if it's an ORF, then it goes to through, because an ORF must not have
        next if (scalar (@$exons) <= 1); # if there is only one exon, and if option is not checked, go to the next prot
        
        # Annotating exons
        my $number = 1;
        foreach my $exon (@$exons) {
            my $start  = $exon->get_dnastart();
            my $end    = $exon->get_dnaend();
            my $strand = $exon->get_strand();
            my $frameshift_size = $exon->get_frameshiftsize();
            
            my ($start_line,$end_line) = ( $ToComment ? (";",";") : ("",""));

               $start_line .= ";     G-$linename-E$number $arrow start";
               $start_line .= ";; frameshift of $frameshift_size nt" if $frameshift_size;
               $start_line .= " ;; MFFEAT=$TAGNAME" if $ADDCOMMENTS;       # Option checked, add comments
               $end_line   .= ";     G-$linename-E$number $arrow end";
               $end_line   .= " ;; MFFEAT=$TAGNAME" if $ADDCOMMENTS;       # Option checked, add comments
            
            my $annot = new PirObject::AnnotPair (
                                                       type            => $A_type || "E",
                                                       genename        => "$name",
                                                       startpos        => $start,
                                                       endpos          => $end,
                                                       direction       => $arrow,
                                                       startline       => $start_line,
                                                       endline         => $end_line,
                                                     );
            $number++;
            my $res = &AddAnnotToPirMaster($pirmaster,$contigname,$annot);
        } # End foreach $exon

        # Annotating introns
        my $introns = $hyprot->get_introns();
        $number = 1;
        foreach my $intron (@$introns) {
            my $start    = $intron->get_start();
            my $end      = $intron->get_end();
            my $strand   = $intron->get_strand();
            my $type     = $intron->get_type();
            my $idbyRNAw = $intron->get_idbyRNAw();
            my $comment  = $intron->get_comment() || "";
            
            my ($start_line,$end_line) = ( $ToComment ? (";",";") : ("",""));
               $start_line .= ";     G-$linename-I$number $arrow start";
               $start_line .= " /group=$type" if $type;
               $start_line .= " ;; MFFEAT=$TAGNAME" if $ADDCOMMENTS;       # Option checked, add comments
               $end_line   .= ";     G-$linename-I$number $arrow end";
               $end_line   .= " ;; MFFEAT=$TAGNAME" if $ADDCOMMENTS;       # Option checked, add comments
               
           my $I_startwarning = "$comment" if $comment;

            my $annot = new PirObject::AnnotPair (
                                                         type         => $A_type || "I",
                                                         genename     => "$name",
                                                         startpos     => $start,
                                                         endpos       => $end,
                                                         direction    => $arrow,
                                                         startline    => $start_line,
                                                         endline      => $end_line,
                                                         introntype   => $type
                                                        );
            my $I_startline = $annot->get_startline();
            $I_startline   .= " ;; $I_startwarning" if $I_startwarning;
            $annot->set_startline($I_startline);                                          
            $number++;
            my $res = &AddAnnotToPirMaster($pirmaster,$contigname,$annot);
            if ($idbyRNAw && $ALL_INTRONS == 1) {
                my $apc             = $idbyRNAw;
                my $apl             = $apc->get_annotpairlist();
                foreach my $ap (@$apl) {
                    &AddAnnotToPirMaster($pirmaster,$contigname,$ap)
                }
            }
        } # End foreach $intron
    } # End foreach $hyprot
} # End sub

sub CheckIfHypIsInAFamily {
    my ($hyprot,$contig) = @_;
    my $HP_start     = $hyprot->get_start();
    my $HP_stop      = $hyprot->get_end();
    my $HP_idbyblast = $hyprot->get_idbyblast();
    
    ($HP_start, $HP_stop) = ($HP_stop, $HP_start) if $HP_start > $HP_stop;
    my $annot_who_overlap = &WhatOverlapsThis($HP_start,$HP_stop,$contig);
    
    my $IsInAP    = []; # If HP is in an other Gene
    my $ContainAP = []; # List of AP contained in HP
    
    foreach my $list_who_overlap (@$annot_who_overlap) {
        foreach my $AP_who_overlap (@$list_who_overlap ) {
            my $AP      = $AP_who_overlap->[2];
            my $All     = $AP_who_overlap->[3];
            my $AP_type = $AP->get_type();
            next if $AP_type ne "G";
            my ($AP_start, $AP_stop) = ($AP_who_overlap->[0],$AP_who_overlap->[1]);
               ($AP_start, $AP_stop) = ($AP_stop, $AP_start) if $AP_start > $AP_stop;
            if ($HP_start <= $AP_start && $HP_stop >= $AP_stop) { 
                # AP in HP
                push(@$ContainAP, $list_who_overlap);
                last;
            }
            elsif ($AP_start <= $HP_start && $AP_stop >= $HP_stop) {
                # HP in AP
                push(@$IsInAP, $list_who_overlap);
                last;
            }
        }
    }
    return 0 if scalar(@$ContainAP) ==  0 && scalar(@$IsInAP) == 0;
    
    if (scalar(@$IsInAP) != 0) {
        # HP is in AP
        my $to_rm            = [];
        foreach my $list_who_overlap (@$IsInAP) {
            my $HP_isIntronic = 0;
            my $G_AP                  = "";
            foreach my $AP_who_overlap (@$list_who_overlap ) {
                my $AP      = $AP_who_overlap->[2];
                my $AP_type = $AP->get_type();
                   $G_AP    = $AP if $AP_type eq "G";
                next if $AP_type ne "I"; # Was id by exo
                my ($I_start, $I_stop) = ($AP_who_overlap->[0],$AP_who_overlap->[1]);
                   ($I_start, $I_stop) = ($I_stop, $I_start) if $I_start > $I_stop;
                if ($I_start <= $HP_start && $I_stop >= $HP_stop) {
                    $HP_isIntronic = 1;
                    last;
                }
            }
            if ($HP_isIntronic == 0) {
                if ($HP_idbyblast) {
                    push(@$to_rm,$list_who_overlap);
                    next;
                }
                else {
                    return 2 if $G_AP->get_idbyexo();
                    return 1;
                }
            }
        }
        &RemoveAPlist($to_rm,$contig);
    }
    
   if (scalar(@$ContainAP) != 0) {
        # HP is in AP
        my $to_rm   = [];
        my $to_cm   = [];
        my $introns = $hyprot->get_introns();
        foreach my $list_who_overlap (@$ContainAP) {
            my $G_AP_isIntronic = 0;
            my $G_AP          = "";
            foreach my $AP_who_overlap (@$list_who_overlap ) {
                my $AP      = $AP_who_overlap->[2];
                my $AP_type = $AP->get_type();
                   $G_AP    = $AP if $AP_type eq "G";

                next if $AP_type ne "G";
                my ($AP_start, $AP_stop) = ($AP_who_overlap->[0],$AP_who_overlap->[1]);
                   ($AP_start, $AP_stop) = ($AP_stop, $AP_start) if $AP_start > $AP_stop;
                   
                foreach my $intron (@$introns) {
                    my ($I_start, $I_stop) = ($intron->get_start(),$intron->get_end());
                       ($I_start, $I_stop) = ($I_stop, $I_start) if $I_start > $I_stop;
                    if ($I_start <= $AP_start && $I_stop >= $AP_stop) {
                        $G_AP_isIntronic     = 1;
                        last;
                    }
                }
                last if $G_AP_isIntronic;
            }
            
            if ($G_AP_isIntronic == 0) {
                if ($HP_idbyblast) {
                    push(@$to_rm,$list_who_overlap);
                    next;
                }
                else {
                    push(@$to_cm,$list_who_overlap) if $G_AP->get_idbyexo();
                    next if $G_AP->get_idbyexo();
                    return 1;
                }
            }
        }
        &RemoveAPlist($to_rm,$contig);
        &CommentAPlist($to_cm)
    }
    return 0;
}

sub RemoveAPlist {
    my ($list_to_rm,$contig) = @_;
    
    my $all_annots = $contig->get_annotations();
    my $alt_exons = [];
    foreach my $list_who_overlap (@$list_to_rm) {
        foreach my $AP_who_overlap (@$list_who_overlap ) {
            my $AP_alt_exons  = $AP_who_overlap->[2]->get_altexons();
            push(@$alt_exons,$AP_alt_exons) if scalar(@$AP_alt_exons) != 0;
        }
    }
    
    # Remove Gene Exon and Intron.
    for (my $i = @$all_annots - 1; $i >= 0 ; $i--) {
        my $contig_AP    = @$all_annots[$i];
        my $id_contig_AP = $1 if  scalar($contig_AP) =~ m/0x(.+)\)/;
        
        foreach my $list_who_overlap (@$list_to_rm) {
            foreach my $AP_who_overlap (@$list_who_overlap ) {
                my $rm_AP         = $AP_who_overlap->[2];
                my $AP_alt_exons  = $rm_AP->get_altexons();
                my $id_rm_AP   =  $1 if  scalar($rm_AP) =~ m/0x(.+)\)/;
                splice(@$all_annots, $i, 1) if $id_rm_AP eq $id_contig_AP;
            }
        }
    }
    
    # Remove alt exons
    return if !$alt_exons;
    for (my $i = @$all_annots - 1; $i >= 0 ; $i--) {
        my $contig_AP    = @$all_annots[$i];
        my $id_contig_AP = $1 if  scalar($contig_AP) =~ m/0x(.+)\)/;
        
        foreach my $list_who_overlap (@$alt_exons) {
            foreach my $rm_AP (@$list_who_overlap) {
                my $id_rm_AP   =  $1 if  scalar($rm_AP) =~ m/0x(.+)\)/;
                splice(@$all_annots, $i, 1) if $id_rm_AP eq $id_contig_AP;
            }
        }
    }
}

sub DefStartAndEndWarning {
    my $hyprot = shift;

    my $startwarning  = $hyprot->get_startwarning() || "";
    my $endwarning    = $hyprot->get_endwarning()   || ""; # Normally empty at this point
    my $starttoodown  = $hyprot->get_starttoodown() || "";
    my $starttooup    = $hyprot->get_starttooup()   || "";
    my $posiffusion   = $hyprot->get_posiffusion()  || 0;
    
    my $message = "";
       $message = "~$starttoodown a.a shorter at start than expected" if $starttoodown && $posiffusion != 2;
       $message = "~$starttooup a.a longer at start than expected"    if $starttooup   && $posiffusion != 2;
       
    if ($message ne ""){
        $startwarning .= $startwarning ne "" ?  " / $message" : "$message";
    }
    return($startwarning,$endwarning);
}

sub CommentAPlist {
    my $list_to_comment = shift; 
    
    foreach my $list_who_overlap (@$list_to_comment) {
        foreach my $AP_who_overlap (@$list_who_overlap ) {
            my $cm_AP      = $AP_who_overlap->[2];
            my $genename   = $cm_AP->get_genename();
            next if $genename eq "comment";
            $cm_AP->set_type("C");
            my ($startline,$endline) = (";",";");
            $startline .= $cm_AP->get_startline();
            $endline   .= $cm_AP->get_endline();
            $cm_AP->set_startline($startline);
            $cm_AP->set_endline($endline);
        }
    }
}

#-----------------------------------#
# Subs for using external programs  #
#-----------------------------------#

sub Annotate_Using_external_programs {
    my $pirmaster       = shift;
    my $conf_file       = PirObject::MfAnnotExternalProgs->ImportFromTextFile($EXTCONFIGFILE);
    my $genecomsets     = $conf_file->get_geneprogs(); # This is a HASH genename => <MfAnnotGeneCommandSet>
    my $ext_select_prog = shift;
    # Here we build a list of external programs to run; by default all
    # of them are executed, but this can be modified by the option --ext_select, which
    # we parse here.

    # Default: all of them
    my @allprogs      = map { split(/\s*,\s*/,$_) } keys %$genecomsets;
    my %allprogs      = map { lc($_) => 1  }        @allprogs;
    my %progs_to_run  = %allprogs; # copy, which will be adjusted
   
    # What do we have in --ext_select? Parse it
    $ext_select_prog="" if $ext_select_prog eq "all";
    my @ext_selected  = split(/\s*,\s*/, $ext_select_prog);

    my @no_ext = grep(/^no/ && $_ ne "none",@ext_selected);
    if (@no_ext) { 
        # There are some 'no', which means ( ALL minus the 'no's )
        foreach my $noext (@no_ext) {
            $noext =~ s/^no//;
            delete $progs_to_run{lc $noext};
        }
    } 
    elsif (@ext_selected) { 
        # There are no 'nos', which means --ext_select is the full list
        %progs_to_run = map { lc($_) => 1 } @ext_selected;
    } # No else needed
   
    # Print warnings about unknown names in --ext_select
    foreach my $prog (sort keys %progs_to_run) {
        next if $prog eq "none";
        print "   Warning: no external programs specified for '$prog' in '$EXTCONFIGFILE'\n"
        unless $allprogs{lc $prog};
    }
   
    # Run each external program command set.
    my @extcomsets = sort {
        $genecomsets->{$a}->get_filerank() <=> $genecomsets->{$b}->get_filerank()
    } keys %$genecomsets; # Now sorted; these are keys with possible MULTIPLE names, e.g. "rns,rnl"

    foreach my $comsetnames (@extcomsets) {
        foreach my $genename (split(/\s*,\s*/,$comsetnames)) {
            next if ! $progs_to_run{lc $genename};
            my $commandobject = $genecomsets->{$comsetnames};
            my $annotpaircollection = &ExecuteExternalProgram($commandobject,$genename);
            &AnnotateFromExternalAPC($pirmaster,$genename,$annotpaircollection);
            $annotate_intron_typeI  = 1 if lc($genename) eq lc("IntronI");
            $annotate_intron_typeII = 1 if lc($genename) eq lc("IntronII"); 
        } # End foreach genename1, genename2, ...
    } # End foreach "genename1,genename2"
} # End sub

sub ExecuteExternalProgram {
    my $commandobject             = shift;
    my $genename                  = shift;
    my $alternate_masterfile      = shift;
    my $alternate_plainmasterfile = shift;
    my $alternate_outfile         = shift;

    my $outfile_gene = $alternate_outfile || "$TMPDIR/result_for_$genename.xml";
    print "    Using external programs for '$genename'...\n"
        if !$DEBUG && !$alternate_outfile && !$alternate_masterfile && !$alternate_plainmasterfile;

    my $substitutions = {
        "OUTFILE"        => "$outfile_gene",       # What will be created, a series of AnnotPairCollections
        "PLAINFASTAFILE" => ($alternate_plainmasterfile || "$TMPDIR/mf_noCr.all"),
        "MASTERFILE"     => ($alternate_masterfile || "$MASTERFILE"),
        "DEBUG"          => $DEBUG ? "#" : "",     # See the config file text
        "GENENAME"       => $genename,             # Optional; the Execute command use this but you can override it yourself)
        "TMPDIR"         => "$TMPDIR",             # Mfannot's tmp dir
        "GENCODE"        => "$GENCODE",
        "MODPATH"        => "$MODEL_PATH", 
    };

    $commandobject->set_debug($DEBUG);
    my ($outfile,$errfile) = $commandobject->Execute(
                                                     "$TMPDIR",
                                                     "$TMPDIR",
                                                      $substitutions,
                                                     );

    # Read back AnnotPairCollections;
    my $infh = new IO::File "<$outfile_gene"; # Which should be your %OUTFILE%
    if (! $infh){ 
        print "Cannot read result for '$genename'; maybe there were problems with the commands?\n";
        print "See outfile '$outfile' and errfile '$errfile' for more info.\n" if $DEBUG;
        return [];
    }

    my @annotpaircollections = PirObject->FileHandleToObject($infh);
    $infh->close();
    \@annotpaircollections;
}

sub AnnotateFromExternalAPC {
    my $pirmaster            = shift;
    my $genename             = shift;
    my $annotpaircollections = shift; # Ref to array of APC
    
    # Process each AnnotPairCollection
    foreach my $annotcollection (@$annotpaircollections) {
        my $header       = $annotcollection->get_contigname();
        my ($contigname) = ($header =~ m#^>?\s*(\S+)#)
            or die "Can't parse header line '$header'\n";
        next if $contigname eq "consensus";
        my $contig      = $pirmaster->GetContigByName($contigname) 
            or die "Can't get contig by name\n";
        my $seq_length  = $contig->get_sequencelength();
        # Annotate the results, using the annotpairlist field of
        # your annotcollection (an AnnotPairCollection object).
        my $annotpairs = $annotcollection->get_annotpairlist();
        foreach my $annot (@$annotpairs){
            my $type       = $annot->get_type()       || "G";
            my $a_genename = $annot->get_genename()   || $genename;
            my $startpos   = $annot->get_startpos()
               || die "Can't find startpos() from annotpair obtained from external analysis?!? Object=\n" . $annot->ObjectToXML() . "\n";
            my $endpos     = $annot->get_endpos(); # Can be undef
             # || die "Can't find endpos() from annotpair obtained from external analysis?!? Object=\n" . $annot->ObjectToXML() . "\n";
                
            my $arrow = "==";  # Woh.. that's not a legal masterfile arrow
               $arrow = "$arrow>" if defined($endpos) && $startpos < $endpos;
               $arrow = "<$arrow" if defined($endpos) && $startpos > $endpos;
            my $direction  = $annot->get_direction()  || $arrow;
            my $start_line = $annot->get_startline();
               $start_line = ";     G-$genename $arrow start" if !defined($start_line);
                
            my $end_line   = $annot->get_endline();  # Can be undef
               $end_line   = ";     G-$genename $arrow end"   if !defined($end_line) && $type eq "G";
            my $annot = new PirObject::AnnotPair(
                                                 type      => $type,
                                                 genename  => $a_genename,
                                                 startpos  => $startpos,
                                                 endpos    => $endpos,
                                                 direction => $direction,
                                                 startline => $start_line,
                                                 endline   => $end_line,
                                                 startlinenumber => $annot->get_startlinenumber(), # Optional; usually undef
                                                 endlinenumber   => $annot->get_endlinenumber(),   # Optional; usually undef
                                                );
            # Added comment and adjust pos for partial rna
            my $a_startline    = $annot->get_startline()    || next;

            if ( $endpos < 0 || $startpos < 0 ) {
                if ($startpos < 0) {
                    $a_startline .= $a_startline =~ m/ ;; \.+/ ?
                           " / Partial annotation, start found at pos : $startpos" 
                         : " ;; Partial annotation, start found at pos : $startpos";
                    $annot->set_startline($a_startline);
                    $annot->set_startpos(1);
                }
                else {
                    $a_startline .= $a_startline =~ m/ ;; \.+/ ?
                           " / Partial annotation, stop found at pos : $endpos" 
                         : " ;; Partial annotation, stop found at pos : $endpos";
                    $annot->set_startline($a_startline);
                    $annot->set_endpos(1);
                }
            }
            if ( $endpos > $seq_length || $startpos > $seq_length ) {
                if ($startpos > $seq_length) {
                    $a_startline .= $a_startline =~ m/ ;; \.+/ ?
                           " / Partial annotation, start found at pos : $startpos" 
                         : " ;; Partial annotation, start found at pos : $startpos";
                    $annot->set_startline($a_startline);
                    $annot->set_startpos($seq_length);
               }
                else {
                    $a_startline .= $a_startline =~ m/ ;; \.+/ ?
                           " / Partial annotation, stop found at pos : $endpos" 
                         : " ;; Partial annotation, stop found at pos : $endpos";
                    $annot->set_startline($a_startline);
                    $annot->set_endpos($seq_length);
                }
            }
            my $add_external_annot = 1;
            if ($genename eq "IntronII" || $genename eq "IntronI") {
                $add_external_annot = &AdjustIntronicAnnot_ForInitialAnnot($pirmaster,$contigname,$annot);
            }
            &AddAnnotToPirMaster($pirmaster,$contigname,$annot) if $add_external_annot == 1 ;
        } # End foreach annotpair
    } # End foreach annotpaircollection (one per contig)
} # End sub

sub AdjustIntronicAnnot_ForInitialAnnot {
    my $pirmaster         = shift;
    my $contigname        = shift;
    my $annot             = shift; # Intron annot as recreated from external program output
    
    my $contig            = $pirmaster->GetContigByName($contigname) or die "Can't get contig by name in AnnotateEmptyOrfs\n";
    my $a_start           = $annot->startpos() || die "Start position is not defined in AnnotPair :\n ".$annot->ObjectToXML()."\n";
    my $a_end             = $annot->endpos()   || die "End position is not defined in AnnotPair :\n ".$annot->ObjectToXML()."\n";
    my $annot_who_overlap = &WhatOverlapsThis($a_start,$a_end,$contig);
    
    foreach my $info_who_overlap (@$annot_who_overlap){
        FEATURE: foreach my $features_who_overlap (@$info_who_overlap ){
            my $features_min    = $features_who_overlap->[0];
            my $features_max    = $features_who_overlap->[1];
            my $feature         = $features_who_overlap->[2];
            
            next if $feature->type ne 'I';
            return 0 if defined $Intron_are_already_annot{$feature};
            next if $features_min >  $a_start || $a_start > $features_max ||
                    $features_min >  $a_end   || $a_end   > $features_max;

            my $a_startline = $annot->startline();
            my $type        = $1    if $a_startline =~ m#;;.*start\s*:\s*(.+)#;
            die "Internal error : external AP does not contain type on startline?!?\n" unless $type;

            my $intron_type  = $feature->introntype() || "";
               $intron_type .= "," if $intron_type;
               $intron_type .= $type;    
            $feature->set_introntype($intron_type);
                
            my $feature_startline = $feature->startline();
            
            $feature_startline  =~ s/\s*\/\s*group\s*=\s*\S+//i;
            $feature_startline .= " /group=$intron_type";
            $feature->set_startline($feature_startline);
            return 0 if $ALL_INTRONS == 0;
            return 1 if $ALL_INTRONS == 1;
        } # End foreach $features_who_overlap
    } # End foreach $info_who_overlap
    return 1;
} # End sub


#-----------------------------------------#
# Subs for adjusting intronic boundaries  #
#-----------------------------------------#


sub Adjust_all_intronic_junctions {
    my $pirmaster   = shift;
    my $contigs     = $pirmaster->get_contigs();
    my $count       = 1;
    
    my %adjustement = (   # This used to be a more complex table... 
        -6 => [-6],
        -5 => [-5],
        -4 => [-4],
        -3 => [-3],
        -2 => [-2],
        -1 => [-1],
         0 => [0],
         1 => [1],
         2 => [2],
         3 => [3],
         4 => [4],
         5 => [5],
         6 => [6],
    );

    my @introns_info = ();
   
    foreach my $contig ( @$contigs) {
        my $annotations = $contig-> get_annotations();
        my $contig_name = $contig-> get_name();
        
        my $seq         = uc($contig->sequence());
           $seq         =~ s/!//g;
        my $reverse_seq = $seq;
           $reverse_seq =~ tr/ACGT/TGCA/;
           $reverse_seq = reverse $reverse_seq;
           
        foreach my $annot (@$annotations){
            my $a_type = $annot->type();
            next if $a_type ne "I";
            next if defined $Intron_are_already_annot{$annot};
            my $a_strand    = $annot->direction()  || next;
            my $isMinus     = ($a_strand eq "==>" ? 0 : 1 );
            my $use_seq     = ($isMinus ? "$reverse_seq" : "$seq");
            push (@introns_info,[$contig,$annot,$seq,$use_seq]);
        }
    }

    return if !@introns_info;

    # Research intron type II 
    if ($annotate_intron_typeII  == 0) {
        my %new_contig_for_intronII = ();
        my $add_to_mf_for_intronII  = "";
        foreach my $intron (@introns_info) {
            my ($contig,$annot,$seq,$use_seq) = @$intron;
            
            next if defined($annot->introntype());
            
            my $contig_name   = $contig-> get_name();
            my $a_start       = $annot->startpos()   || next;
            my $a_end         = $annot->endpos()     || next;
            my $a_strand      = $annot->direction()  || next;
            my $isMinus       = ($a_strand eq "==>" ? 0 : 1 );
            ($a_start,$a_end) = ($a_end,$a_start) if $isMinus;
            my $a_startline   = $annot->startline()  || next;
            my $name_of_gene  = $1 if ($a_startline =~ m#;\s*[gG]-(\S+)\s+(==>|<==)\s*start#);
            
            my $intron_seq    = substr($seq,$a_start - 1,abs($a_end-$a_start)+1);
            my $signature     = "$contig_name,$name_of_gene,$a_start,$a_end,$a_strand";
            $new_contig_for_intronII{$count} = $signature;
            $add_to_mf_for_intronII .= ">A$count\n$intron_seq\n\n";
            $count++;
        } # End foreach $intron
        &Research_for_intron($pirmaster,$add_to_mf_for_intronII,\%new_contig_for_intronII,"IntronII") if $add_to_mf_for_intronII ne "";
    } # End if
    
    #Adjust intron type II
    foreach my $intron (@introns_info) {
        my ($contig,$annot,$seq,$use_seq) = @$intron;
        
        my $a_introntype = $annot->introntype() || "";
        next if ($a_introntype ne "II");
        &Adjust_TypeII($contig,$annot,$use_seq,\%adjustement);
        $intron->[1] = undef; # This intron is done
    } # End foreach intron
    
    @introns_info = grep( defined($_->[1]) , @introns_info);
    return if !@introns_info;
    
    # Add splicescore for other intron (maybe type I)
    foreach my $intron (@introns_info) {
        my ($contig,$annot,$seq,$use_seq) = @$intron;
        
        my $a_introntype = $annot->introntype() || "";
        my $adjust_info = &Add_splicescore($contig,$annot,$use_seq,\%adjustement);
        return if !$adjust_info;
        push(@$intron, $adjust_info);
    } # End foreach $intron
    
    # Adjust intron if splicescore is good
    foreach my $intron (@introns_info) {
        my ($contig,$annot,$seq,$use_seq,$adjust_info) = @$intron;
        my ($tab_scores,$name_intron,$num_intron,$annot_who_overlap,$annotation,$isMinus) = @$adjust_info;
        
        my $a_splicescore = $annot->splicescore();
        next if $a_splicescore < 19;
        &AdjustBoundaries($tab_scores,$name_intron,$num_intron,$annot_who_overlap,$annotation,$isMinus);
        $intron->[1] = undef; # This intron is done
    }
    
    @introns_info = grep( defined($_->[1]) , @introns_info);
    return if !@introns_info;
    
    # Research intron type I
    if ($annotate_intron_typeI  == 0) {
        my %new_contig_for_intronI = ();
        my $add_to_mf_for_intronI  = "";
        foreach my $intron (@introns_info) {
            my ($contig,$annot,$seq,$use_seq) = @$intron;
            
            next if defined($annot->introntype());
            
            my $contig_name   = $contig-> get_name();
            my $a_start       = $annot->startpos()   || next;
            my $a_end         = $annot->endpos()     || next;
            my $a_strand      = $annot->direction()  || next;
            my $isMinus       = ($a_strand eq "==>" ? 0 : 1 );
            ($a_start,$a_end) = ($a_end,$a_start) if $isMinus;
            my $a_startline   = $annot->startline()  || next;
            my $name_of_gene  = $1 if ($a_startline =~ m#;\s*[gG]-(\S+)\s+(==>|<==)\s*start#);
            
            my $intron_seq   = substr($seq,$a_start - 1,abs($a_end-$a_start)+1);
            my $signature    = "$contig_name,$name_of_gene,$a_start,$a_end,$a_strand";
            $new_contig_for_intronI{$count} = $signature;
            $add_to_mf_for_intronI .= ">A$count\n$intron_seq\n\n";
            $count++;
        } # End foreach intron
        &Research_for_intron($pirmaster,$add_to_mf_for_intronI,\%new_contig_for_intronI,"IntronI") if $add_to_mf_for_intronI ne "";
    } # End if 
    
    # Add comment if adjustement failed.
    foreach my $intron (@introns_info) {
        my ($contig,$annot,$seq,$use_seq,$adjust_info) = @$intron;
        my ($tab_scores,$name_intron,$num_intron,$annot_who_overlap,$annotation,$isMinus) = @$adjust_info;

        my $a_splicescore  = $annot->get_splicescore();
        my $a_introntype   = $annot->get_introntype()   || "";
        my $a_startline    = $annot->get_startline()    || next;
        my @intron_type    = split(/,/, $a_introntype);
        my $nb_type        = @intron_type;

        if ($nb_type == 0) {
            $a_startline .= $a_startline =~ m/ ;; \.+/ ?
                          " / no intron type identified" 
                        : " ;; no intron type identified";
            $annot->set_startline($a_startline);
        }
        elsif ($nb_type == 2 ) {
            $a_startline .= $a_startline =~ m/ ;; \.+/ ?
                          " / two introns identified" 
                        : " ;; two introns identified";
            $annot->set_startline($a_startline);
        }
        elsif ($nb_type ==  1) {
            &AdjustBoundaries($tab_scores,$name_intron,$num_intron,$annot_who_overlap,$annotation,$isMinus);
        }
    } # End foreach $intron
} # End sub

sub Research_for_intron {
    my $pirmaster                = shift;
    my $introns_fasta            = shift;
    my $r_hash_of_new_contigname = shift;
    my $intron_group             = shift;
    
    my $conf_file     = PirObject::MfAnnotExternalProgs->ImportFromTextFile($EXTCONFIGFILE);
    my $genecomsets   = $conf_file->get_geneprogs(); # This is a HASH genename => <MfAnnotGeneCommandSet>
    my $commandobject = $genecomsets->{$intron_group};
    
    my $masterfile_for_introns = $TMPDIR . "/masterfile_for_". $intron_group ;
    
    my $MF = new IO::File ">$masterfile_for_introns" or die "Cannot open : $masterfile_for_introns\n";
    print $MF $introns_fasta;
    $MF->close();
    my $annotpaircollections = &ExecuteExternalProgram($commandobject,$intron_group,undef,$masterfile_for_introns);
    $annotpaircollections    = &Adjust_coord_for_postannot($annotpaircollections,$r_hash_of_new_contigname);
    &AnnotateFromExternalAPC($pirmaster,$intron_group,$annotpaircollections);
} # End sub

sub Adjust_TypeII {
    my $contig      = shift;
    my $annot       = shift;
    my $use_seq     = shift;
    my $adjustement = shift;
    
    my $contig_name = $contig-> get_name();
    my $a_start     = $annot->startpos()   || next;
    my $a_end       = $annot->endpos()     || next;
    my $a_startline = $annot->startline()  || next;
    my $a_endline   = $annot->endline()    || next;
    my $a_strand    = $annot->direction()  || next;
    my $isMinus     = ($a_strand eq "==>" ? 0 : 1 );
    my ($name_intron , $num_intron)  = ($1,$2) if  $a_startline =~ m#;\s+(G-.+)-I(\d+).+#;
    my $name_of_gene = $1 if ($a_startline =~ m#;\s*[gG]-(\S+)\s+(==>|<==)\s*start#);
    my ($start_pos,$end_pos) = ($isMinus ? ((length($use_seq) + 1 - $a_start),(length($use_seq) + 1 - $a_end)) : ($a_start,$a_end));
    
    my $phase = &WhichPhase($annot, $num_intron, $contig);    
    my $annot_who_overlap = &WhatOverlapsThis($a_start,$a_end,$contig);
    
    # View for previous and next exons
    my $previous_exon_name  = $name_intron."-E".$num_intron;
    my $next_exon_name      = $name_intron."-E".($num_intron+1);
    my ($previous_exon_feat,$next_exon_feat) = &Previous_and_next_exons($previous_exon_name,$next_exon_name,$annot_who_overlap);
    last if (!$previous_exon_feat || !$next_exon_feat);
    
    # Length of previous exon
    my $previous_exon_length = &Length_annot($previous_exon_feat);
    
    # Length of next exon
    my $next_exon_length = &Length_annot($next_exon_feat);

    my @tab_scores = ();
    foreach my $adjust_start_pos (sort { $a <=> $b } keys %$adjustement) {
        my $tab = $adjustement->{$adjust_start_pos};
        foreach my $adjust_end_pos (@$tab){
            my $key      = $adjust_start_pos.','.$adjust_end_pos;
            my $scores   = undef;
            
            next if (($previous_exon_length + $adjust_start_pos) <= 5);
            next if (($next_exon_length - $adjust_end_pos) <= 5);
            
            my $score_nt = &ScoreNtLTypeII($use_seq,$start_pos,$adjust_start_pos) 
                         + &ScoreNtRTypeII($use_seq,$end_pos,$adjust_start_pos);
            
            $score_nt -= abs($adjust_start_pos);
            # $scores is a ref to quintuplet ($score_nt,$score_aa,abs($adjust_start),$adjust_start,$adjust_end) or undef if adjustment is invalid
            $scores = &CheckForCorrespondance($phase, $start_pos, $end_pos, $use_seq, $key,$score_nt,$annot);
            push (@tab_scores, $scores ) if defined $scores; 
        }
    }
    
    @tab_scores = sort { ($b->[0] - $b->[2]) <=> ($a->[0] - $a->[2])
                                  || $b->[1] <=> $a->[1]
                                  || $a->[2] <=> $b->[2]
                                  || $a->[3] <=> $b->[3]} @tab_scores;

    if (!$tab_scores[0]->[0] || $tab_scores[0]->[0] < 40) {
        &AddCommentToAnnotField($annot,"startline",";;  Cannot adjust boundaries");
        &AddCommentToAnnotField($annot,"endline",";; Cannot adjust boundaries");
        return;
    }
    &AdjustBoundaries(\@tab_scores,$name_intron,$num_intron,$annot_who_overlap,$annot,$isMinus);
} # End sub

sub Adjust_coord_for_postannot {
    my $annotpaircollections     = shift;
    my $r_hash_of_new_contigname = shift;
    
    foreach my $annotpaircollection (@$annotpaircollections) {
        my $contig = $annotpaircollection->get_contigname();
        $contig =~ s/^>A//;
        # $signature is a quintuplet contig_name, name_of_gene, lower_pos, higher_pos, direction
        my $signature  = $r_hash_of_new_contigname->{$contig};
        my @signature  = split(/,/, $signature);
        my $sig_contig = $signature[0];
        my $lower_pos  = $signature[2];
        my $higher_pos = $signature[3];
        my $strand     = $signature[4];
        $annotpaircollection->set_contigname(">$sig_contig");
        my $annotpairs = $annotpaircollection->get_annotpairlist();
    
        my $new_ap = [];
        foreach my $annot (@$annotpairs){
            my $annot_strand   = $annot->direction();
            next if $annot_strand ne $strand ;
            my $annot_startpos = $annot->startpos();
            my $annot_endpos   = $annot->endpos();
        
            my $isMinus     = ($annot_strand eq "==>" ? 0 : 1 );
            $annot_startpos = $lower_pos + $annot_startpos  - 1;
            $annot_endpos   = $lower_pos + $annot_endpos - 1;
        
            $annot->set_startpos($annot_startpos);
            $annot->set_endpos($annot_endpos);
            push(@$new_ap,$annot);
        }
    $annotpaircollection->set_annotpairlist($new_ap);
    }
    return $annotpaircollections;
}

sub Add_splicescore {
    my $contig      = shift;
    my $annot       = shift;
    my $use_seq     = shift;
    my $adjustement = shift;
    
    my $contig_name = $contig->get_name();
    my $a_start     = $annot->startpos()   || next;
    my $a_end       = $annot->endpos()     || next;
    my $a_startline = $annot->startline()  || next;
    my $a_endline   = $annot->endline()    || next;
    my $a_strand    = $annot->direction()  || next;
    my $isMinus     = ($a_strand eq "==>" ? 0 : 1 );
    my ($name_intron , $num_intron)  = ($1,$2) if  $a_startline =~ m#;\s+(G-.+)-I(\d+).+#;
    my $name_of_gene = $1 if ($a_startline =~ m#;\s*[gG]-(\S+)\s+(==>|<==)\s*start#);
    my ($start_pos,$end_pos) = ($isMinus ? ((length($use_seq) + 1 - $a_start),(length($use_seq) + 1 - $a_end)) : ($a_start,$a_end));
    
    my $phase = &WhichPhase($annot, $num_intron, $contig);    
    my $annot_who_overlap = &WhatOverlapsThis($a_start,$a_end,$contig);
    
    # View for previous and next exons
    my $previous_exon_name  = $name_intron."-E".$num_intron;
    my $next_exon_name      = $name_intron."-E".($num_intron+1);
    my ($previous_exon_feat,$next_exon_feat) = &Previous_and_next_exons($previous_exon_name,$next_exon_name,$annot_who_overlap);
    return if (!$previous_exon_feat || !$next_exon_feat);
    
    # Length of previous exon
    my $previous_exon_length = &Length_annot($previous_exon_feat);
    # Length of next exon
    my $next_exon_length     = &Length_annot($next_exon_feat);

    
    my @tab_scores = ();
    foreach my $adjust_start_pos (sort { $a <=> $b } keys %$adjustement) {
        my $tab = $adjustement->{$adjust_start_pos};
        foreach my $adjust_end_pos (@$tab){
            my $key      = $adjust_start_pos.','.$adjust_end_pos;
            my $scores   = undef;
            
            next if (($previous_exon_length + $adjust_start_pos) <= 5 && $key ne "0,0");
            next if (($next_exon_length - $adjust_end_pos) <= 5 && $key ne "0,0");
            
             my $score_nt = &ScoreNtLTypeI($use_seq,$start_pos,$adjust_start_pos) 
                          + &ScoreNtRTypeI($use_seq,$end_pos,$adjust_start_pos);

            #$score_nt -= abs($adjust_start_pos);
            # $scores is a ref to quintuplet ($score_nt,$score_aa,abs($adjust_start),$adjust_start,$adjust_end) or undef if adjustment is invalid
            $scores = &CheckForCorrespondance($phase, $start_pos, $end_pos, $use_seq, $key,$score_nt,$annot);
            push (@tab_scores, $scores ) if defined $scores; 
        }
    }
    
    @tab_scores = sort { ($b->[0] - $b->[2]) <=> ($a->[0] - $a->[2]) 
                                  || $b->[1] <=> $a->[1]
                                  || $a->[2] <=> $b->[2]
                                  || $a->[3] <=> $b->[3]} @tab_scores;

    my $splice_score = $tab_scores[0]->[0];
    if ($splice_score >= 19 && $annotate_intron_typeI  == 0){
        $annot->set_introntype("sigI");
    }
    $annot->set_splicescore($tab_scores[0]->[0]);
    return [\@tab_scores,$name_intron,$num_intron,$annot_who_overlap,$annot,$isMinus];
} # End sub

sub ScoreNtLTypeII {
    my $use_seq          = shift;
    my $start_pos        = shift;
    my $adjust_start_pos = shift;
    
    my $start_char_plus1 = substr($use_seq,$start_pos + $adjust_start_pos - 1,1);  # Each nt between -6 and 6 of feature_min
    my $start_char_plus2 = substr($use_seq,$start_pos + $adjust_start_pos ,1);
    my $start_char_plus3 = substr($use_seq,$start_pos + $adjust_start_pos + 1,1);
    my $start_char_plus4 = substr($use_seq,$start_pos + $adjust_start_pos + 2,1);
    my $start_char_plus5 = substr($use_seq,$start_pos + $adjust_start_pos + 3,1);
   
   my $score_nt  = 0;
      $score_nt += 10  if  $start_char_plus1   eq 'G';
      $score_nt += 7.5 if  $start_char_plus2   eq 'T';
      $score_nt += 9   if  $start_char_plus3   eq 'G';
      $score_nt += 10  if  ($start_char_plus4  eq 'C' || $start_char_plus4  eq 'T');
      $score_nt += 10  if  $start_char_plus5   eq 'G';

    return $score_nt;
}

sub ScoreNtRTypeII {
    my $use_seq        = shift;
    my $end_pos        = shift;
    my $adjust_end_pos = shift;
        
    my $end_char_minus1  = substr($use_seq,$end_pos + $adjust_end_pos -1,1);
    my $end_char_minus2  = substr($use_seq,$end_pos + $adjust_end_pos -2,1);
    
    my $score_nt  = 0;
       $score_nt += 9   if ($end_char_minus1    eq 'C' || $end_char_minus1  eq 'T');
       $score_nt += 9   if  $end_char_minus2    eq 'A';
   return $score_nt;
}

sub ScoreNtLTypeI {
    my $use_seq          = shift;
    my $start_pos        = shift;
    my $adjust_start_pos = shift;
    
    my $start_char_minus1 = substr($use_seq,$start_pos + $adjust_start_pos -2,1);  # Each nt between -6 and 6 of feature_min
    my $start_char_minus2 = substr($use_seq,$start_pos + $adjust_start_pos -3,1);
    my $start_char_minus3 = substr($use_seq,$start_pos + $adjust_start_pos -4,1);
    
    my $score_nt  = 0;
       $score_nt += 5   if $start_char_minus1 eq 'T';
       $score_nt += 3   if $start_char_minus2 eq 'G';
       $score_nt += 3   if $start_char_minus3 eq 'G';
       
   return $score_nt;
}

sub ScoreNtRTypeI {
    my $use_seq        = shift;
    my $end_pos        = shift;
    my $adjust_end_pos = shift;
    
    my $end_char_minus1   = substr($use_seq,$end_pos + $adjust_end_pos -1,1);
    my $end_char_minus2   = substr($use_seq,$end_pos + $adjust_end_pos -2,1);
    my $end_char_minus3   = substr($use_seq,$end_pos + $adjust_end_pos -3,1);
    my $end_char_minus4   = substr($use_seq,$end_pos + $adjust_end_pos -4,1);
    my $end_char_minus5   = substr($use_seq,$end_pos + $adjust_end_pos -5,1);
    my $end_char_minus6   = substr($use_seq,$end_pos + $adjust_end_pos -6,1);
    my $end_char_minus7   = substr($use_seq,$end_pos + $adjust_end_pos -7,1);
    my $end_char_minus8   = substr($use_seq,$end_pos + $adjust_end_pos -8,1);
    my $end_char_minus9   = substr($use_seq,$end_pos + $adjust_end_pos -9,1);
    
     my $score_nt  = 0;
        $score_nt += 10  if $end_char_minus1   eq 'G';
        $score_nt += 0.5 if ($end_char_minus2  eq 'T' || $end_char_minus2  eq 'A');
        $score_nt += 0.5 if ($end_char_minus3  eq 'T' || $end_char_minus3  eq 'A');
        $score_nt += 0.5 if ($end_char_minus4  eq 'T' || $end_char_minus4  eq 'A');
        $score_nt += 0.5 if ($end_char_minus5  eq 'T' || $end_char_minus5  eq 'A');
        $score_nt += 0.5 if ($end_char_minus6  eq 'T' || $end_char_minus6  eq 'A');
        $score_nt += 0.5 if ($end_char_minus7  eq 'T' || $end_char_minus7  eq 'A');
        $score_nt += 0.5 if ($end_char_minus8  eq 'T' || $end_char_minus8  eq 'A');
        $score_nt += 0.5 if ($end_char_minus9  eq 'T' || $end_char_minus9  eq 'A');

    return $score_nt;
}

sub AdjustBoundaries {
    my $tab_scores        = shift;
    my $name_intron       = shift;
    my $num_intron        = shift;
    my $annot_who_overlap = shift;
    my $feature_intron    = shift;
    my $isMinus           = shift;
    
    my ($adjust_start,$adjust_end) = ($tab_scores->[0]->[3],$tab_scores->[0]->[4]);
    my $previous_exon_name         = $name_intron."-E".$num_intron;
    my $next_exon_name             = $name_intron."-E".($num_intron+1);
    
    # Use to defined previous and next exon
    my ($previous_exon_feat,$next_exon_feat) = &Previous_and_next_exons($previous_exon_name,$next_exon_name,$annot_who_overlap);
    ($adjust_start,$adjust_end) = (-$adjust_start,-$adjust_end) if $isMinus;
    
    # Adjust intron
    my $feature_intron_start = $feature_intron->get_startpos();
    $feature_intron->set_startpos($feature_intron_start + $adjust_start);
    
    my $feature_intron_end   = $feature_intron->get_endpos();
    $feature_intron->set_endpos($feature_intron_end + $adjust_end);
    
    # Adjust previous exon
    if (defined $previous_exon_feat) {
        my $previous_exon_end   = $previous_exon_feat->get_endpos();
        $previous_exon_feat->set_endpos($previous_exon_end + $adjust_start);
    }
    
    # Adjust next exon
    if (defined $next_exon_feat) {
        my $next_exon_start   = $next_exon_feat->get_startpos();
        $next_exon_feat->set_startpos($next_exon_start + $adjust_end);
    }
} # End sub

sub Previous_and_next_exons {
    my $previous_exon_name = shift;
    my $next_exon_name     = shift;
    my $annot_who_overlap  = shift;
    
    my $previous_exon_feat = undef;
    my $next_exon_feat     = undef;
    
    foreach my $annotation_who_overlap (@$annot_who_overlap){
        foreach my $feature_overlap (@$annotation_who_overlap) {
            my $feature            = $feature_overlap->[2];
            next if $feature->get_genename() eq "comment";
            my $feature_startline  = $feature->get_startline();
            my ($annotname)        = ($feature_startline =~ m#^;\s+(\S+)#);
            $previous_exon_feat    = $feature if ($annotname eq $previous_exon_name);
            $next_exon_feat        = $feature if ($annotname eq $next_exon_name);
            last if $previous_exon_feat && $next_exon_feat;
        } # End foreach $feature_who_overlap
    } # End foreach $annotation_who_overlap
    return($previous_exon_feat,$next_exon_feat);
} # End sub

sub CheckForCorrespondance {
    my $phase     = shift;
    my $start_pos = shift;   # Bio coordinates
    my $end_pos   = shift;   # Bio coordinates
    my $seq       = shift;
    my $key       = shift; 
    my $score_nt  = shift;
    my $annot     = shift;
    
    my $startline = $annot->startline();
    
    my ($adjust_start,$adjust_end) = split(/,/,$key);
    my $old_substring1 = "";
    my $old_substring2 = "";
    my $new_substring1 = "";
    my $new_substring2 = "";
    
    my $comp_phase     = $phase == 0 ? 0 : 3-$phase;
    my $new_phase      = ($phase + $adjust_start) % 3;
    my $comp_new_phase = $new_phase == 0 ? 0 : 3-$new_phase;
    
    if ($adjust_start <= 0) {
        my $from_old = $start_pos + $adjust_start - 1 - $new_phase;
        my $len_old  = abs($adjust_start)+$new_phase;
        my $from_new = $start_pos + $adjust_start - $new_phase - 1;
        $old_substring1 = substr($seq,$from_old,$len_old);
        $new_substring1 = substr($seq,$from_new,$new_phase);
    }
    elsif ($adjust_start > 0) {
        my $from_old = $start_pos - $phase - 1;
        my $len_old  = $phase;
        my $from_new = $start_pos - $phase - 1;
        my $len_new  = $adjust_start + $phase;
        $old_substring1 = substr($seq,$from_old,$len_old);
        $new_substring1 = substr($seq,$from_new, $len_new);
    }
    
    if ($adjust_end >= 0) {
        my $from_old = $end_pos;
        my $len_old  = $comp_new_phase + $adjust_end;
        my $from_new = $end_pos + $adjust_end;
        my $len_new  = $comp_new_phase;
        $old_substring2   = substr($seq,$from_old, $len_old);
        $new_substring2   = substr($seq,$from_new, $len_new);
    }
    elsif ($adjust_end < 0) {
        my $from_old = $end_pos ;
        my $len_old  = $comp_phase;
        my $from_new = $end_pos + $adjust_end;
        my $len_new  = - $adjust_end + $comp_phase;
        $old_substring2   = substr($seq,$from_old, $len_old);
        $new_substring2 = substr($seq,$from_new,$len_new);
    }
  
    my $old_substring = "$old_substring1$old_substring2";
    my $new_substring = "$new_substring1$new_substring2";

    if (length($old_substring) != length($new_substring)){
        print "   WARNING : Combination $adjust_start,$adjust_end not used for adjust boundaries because they add or delete amino acid \n";
        return undef;
    }
    
    if (length($new_substring)%3 != 0){
        print "   WARNING : Combination $adjust_start,$adjust_end not used for adjust boundaries because they shift the initial readingframe\n
                  Initial phase is $phase the new phase is $new_phase \n
                  Sequence used at start of intron is $new_substring1 \n
                  Sequence used at end of intron is $new_substring2 \n
                  Whole sequence used for check for stop codon is $new_substring\n";
        return undef;
    }
    
    my @new_aa = ();
    my @old_aa = ();
    for (my $sub_start_pos = 0;  $sub_start_pos <= length($new_substring)-3; $sub_start_pos += 3){
        my $new_codon = substr($new_substring,$sub_start_pos,3);
        push (@new_aa, $CODON_TABLE->{$new_codon} );  # undef is OK here
        my $old_codon = substr($old_substring,$sub_start_pos,3);
        push (@old_aa, $CODON_TABLE->{$old_codon} );  # undef is OK here
    }
    
    my $score_aa = 0;
    for (my $i = 0;  $i < @new_aa; $i++){
        my $old_aa    = $old_aa[$i] || "X";
        my $new_aa    = $new_aa[$i] || "X";
        $score_aa += $matrix->get_entry($old_aa,$new_aa);   
        return undef if $score_aa < 0;
    }
     
    $score_aa = $score_aa / (@new_aa || 1);
    $score_aa = 9999 if $adjust_start == 0 && $adjust_end == 0;  # 9999 is SUPER GOOD
    return [$score_nt,$score_aa,abs($adjust_start),$adjust_start,$adjust_end];
} # End sub



#---------------------------------#
# Subs for comment gene fusion    #
#---------------------------------#

sub CommentFusion {
    my $pirmaster = shift;
    my $contigs   = $pirmaster->get_contigs();

    foreach my $contig ( @$contigs) {
        my $annotations = $contig->get_annotations();
        my $contig_name = $contig->get_name();
        
        foreach my $annot (@$annotations) {
            my $posiffusion = $annot->get_posiffusion();
            next if !$posiffusion;
            my $arrow       = $annot->get_direction();
            my $gene_name   = $annot->get_genename();
            my $start       = $annot->get_startpos();
            my $end         = $annot->get_endpos();
            my $fusion_name = $annot->get_namefusiongene();
            &AddCommentForFusion($contig_name,$start,$arrow,$gene_name,$fusion_name,"start",1) if $posiffusion == 1;
            &AddCommentForFusion($contig_name,$end,$arrow,$gene_name,$fusion_name,"end",1) if $posiffusion == 2;
        }
    }
}

sub AddCommentForFusion {
    # Add comment if it's first gene this comment surround the two genes
    my $contigname  = shift;
    my $pos         = shift;
    my $arrow       = shift;
    my $gene_name   = shift;
    my $fusion_name = shift;
    my $tag         = shift;
    my $line_number = shift;
    
    $pos = $pos + 1 if $arrow eq "==>" and $tag eq "end";
    $pos = $pos - 1 if $arrow eq "<==" and $tag eq "end";
    
    my $name = ($tag eq "start" ? "${gene_name}_$fusion_name" : "${fusion_name}_$gene_name");
    my $line = ";; G-$name $arrow $tag";
   
    my $comment = new PirObject::AnnotPair(
                                            type            => "C",  
                                            genename        => $name,
                                            startpos        => $pos,
                                            direction       => $arrow,
                                            startline       => $line,
                                            startlinenumber => $line_number
                                           );
    &AddAnnotToPirMaster($pirmaster,$contigname,$comment);
}

#---------------------------------#
# Subs for processing empty ORFs  #
#---------------------------------#

sub AnnotateEmptyOrfs {
    # This function takes the empty array of ORF and annotate it as ORFs
    # It means ORF having non corresponding gene in a pepfile
    my $pirmaster = shift; # get the masterfile object
    my $orf_a_annoter = scalar(@$EMPTYORFS);

    @$EMPTYORFS = sort {
        $a->get_contigname()                 cmp $b->get_contigname()                 ||
        abs($b->get_start() - $b->get_end()) <=> abs($a->get_start() - $a->get_end()) ||
        $b->get_strand()                     <=> $a->get_strand()                     ||
        $a->get_start()                      <=> $b->get_start()
     } @$EMPTYORFS;     
     
    EMPTYORF : foreach my $emptyorf (@$EMPTYORFS) {
        # Process each non corresponding orf
        
        # Get informations  about empty ORF
        my $contigname = $emptyorf->contigname;     # Get the contigname corresponding to the empty ORFs
        my $strand_orf = $emptyorf->strand;

        my $arrow = '==>' if $strand_orf == 1;
           $arrow = '<==' if $strand_orf != 1;
   
        my $start_orf = $emptyorf->start;
        my $end_orf   = $emptyorf->end;
        my $min_orf   = ($strand_orf == 1 ? $start_orf : $end_orf);
        my $max_orf   = ($strand_orf == 1 ? $end_orf : $start_orf);

        my $overlappingcutoff = $OVERLAPPINGCUTOFF; # Authorized overlapping. It's a percent so it has to be between 0 and 1
        my $minimumlengthorf  = $MINLENEMPTYORF;    # Minimum Orf size, below this size, the ORF is no more kept
        my $contig            = $pirmaster->GetContigByName($contigname) or die "Can't get contig by name in AnnotateEmptyOrfs\n";
        my $annotations       = $contig->get_annotations; # Get the annotations, for the same contig belonging to empty ORF
         my $seq              = $contig->sequence;        # Get the sequence
            $seq              =~ s/!//g;                  # Remove ! from the sequence
        my $prefix            = "";                       # Is use for orf intronic

        # Size checking
        next EMPTYORF if  (($end_orf - $start_orf + 1 ) < $minimumlengthorf) && $strand_orf == 1;  #  Size Verification 
        next EMPTYORF if  (($start_orf - $end_orf + 1 ) < $minimumlengthorf) && $strand_orf != 1;  #  Size Verification 

        # Other checking, such as overlapping..........
    
        my $isMinus   = ($strand_orf == 1 ? 0 : 1);
        my $posOffset = ($isMinus ? -3 : 3);

        my $annotIsOK_gene_without_intron = 0;
   
        for (;;$start_orf += $posOffset) {
            last if $start_orf >= $end_orf   && !$isMinus;
            last if $end_orf   >= $start_orf && $isMinus;
            last if  (($end_orf - $start_orf + 1 ) < $minimumlengthorf) && !$isMinus;
            last if  (($start_orf - $end_orf + 1 ) < $minimumlengthorf) &&  $isMinus;  #  Size verification 
            my $codon = uc (substr($seq, $start_orf - 1, 3)) if !$isMinus;
               $codon = uc (substr($seq, $start_orf - 3, 3)) if  $isMinus;
               $codon =~ tr/ACGT/TGCA/ if $isMinus;
               $codon = reverse $codon if $isMinus;
            next unless defined($CODON_TABLE->{$codon}) && $CODON_TABLE->{$codon} eq "M";
            $annotIsOK_gene_without_intron = 1;
            last;
        }

        next EMPTYORF if $annotIsOK_gene_without_intron == 0;

        my $annot_who_overlap = &WhatOverlapsThis($start_orf,$end_orf,$contig);
 
        my $annotIsOk         = 0;
        my $number_of_annot   = 0;
        my $overlap_an_intron = 0;
        ANNOT : foreach my $info_who_overlap (@$annot_who_overlap) {
            foreach my $features_who_overlap (@$info_who_overlap ){
                my $features_min            = $features_who_overlap->[0];
                my $features_max            = $features_who_overlap->[1];
                my $feature_annot_type      = $features_who_overlap->[2]->type;
                my $feature_annot_direction = $features_who_overlap->[2]->direction;
                my $feature_startpos        = $features_who_overlap->[2]->startpos;
                my $feature_endpos          = $features_who_overlap->[2]->endpos;
                my $feature_endline         = $features_who_overlap->[2]->endline;
                $number_of_annot++;
                for (;;$start_orf += $posOffset) {
                    last if $start_orf >= $end_orf && !$isMinus;
                    last if $end_orf >= $start_orf && $isMinus;
                    last if (($end_orf - $start_orf + 1 ) < $minimumlengthorf) && !$isMinus;
                    last if (($start_orf - $end_orf + 1 ) < $minimumlengthorf) &&  $isMinus;  #  Size verification 
                    last if ( ( ($features_min <= $start_orf                    #
                             && $features_max >= $end_orf                       # ORF in strand 1 
                             && !$isMinus)                                      #
                                              ||
                               ($features_min <= $end_orf                        #
                             && $features_max >= $start_orf                      # ORF in strand -1
                             && $isMinus)                                        #
                              )
                             && ($feature_annot_type eq "E" # An exon
                                                     || 
                                ($feature_annot_type eq "G" && $features_who_overlap->[3] eq "YES")  # Gene without intron
                                )
                            );
    
 #Case 1              ------------>         ORF strand 1
 #               * ------------------- **   Exon or gene without intron strand 1 or -1 we take the smallest value for start and we take the biggest values for end
 #Case2          <------------              ORF strand -1
 
                    my $codon = uc (substr($seq, $start_orf - 1, 3)) if !$isMinus;
                       $codon = uc (substr($seq, $start_orf - 3, 3)) if  $isMinus;
                       $codon =~ tr/ACGT/TGCA/ if $isMinus;
                       $codon = reverse $codon if $isMinus;
     
                    if (!($features_max < $min_orf || $max_orf < $features_min)){
                        $overlap_an_intron = 1;
                        last;
                    }
   
                    next unless defined($CODON_TABLE->{$codon})  && $CODON_TABLE->{$codon} eq "M";
       
                    if ($features_who_overlap->[2]->genename =~ /^trn/){            # Overlap whith ARNt 
                        if (!$isMinus){
                            my $max_start = ( ( $features_min > $start_orf ) ? $features_min : $start_orf);
                            my $min_end   = ( ( $features_max < $end_orf )   ? $features_max : $end_orf );
                            next if ( 0 < ( $min_end - $max_start + 1));
                        }
                        if ($isMinus) {
                            my $min_start = ( ( $features_max < $start_orf ) ? $features_max : $start_orf );
                            my $max_end   = ( ( $features_min > $end_orf )   ? $features_min : $end_orf);
                            next if ( 0 < ( $min_start - $max_end + 1));
                        }
                    }
    
                    if ( ($feature_annot_type eq "G" && $features_who_overlap->[3] eq "YES")    # Gene without intron
                      || ($feature_annot_type eq "E" && $features_who_overlap->[3] eq "YES")) { # First or last exon
                        
                        if (!$isMinus) {
                            if ( ( $feature_annot_type eq "G" )                                    # Gene whithout intron
                                               ||   
                                 ( $features_who_overlap->[4] eq "FIRST"                           # Case
                               && (  ($start_orf <= $features_min                                  # ---------->          ORF
                                   && $end_orf   >= $features_min                                  #      --------->      E1
                                   && $feature_annot_direction eq "==>"
                                     )
                                                 ||
                                     ($start_orf <= $features_max                                  # Case
                                   && $end_orf   >= $features_max                                  #     --------->          ORF
                                   && $feature_annot_direction eq "<=="                            # <--------               E1
                                     )
                                  )
                                 )
                                               ||   
                                 ( $features_who_overlap->[4] eq "LAST"
                               && (  ($start_orf <= $features_max                                  # Case
                                   && $end_orf   >= $features_max                                  #      -------->       ORF 
                                   && $feature_annot_direction eq "==>"                            #  -------->           Ef
                                     )
                                                 ||
                                     ($start_orf <= $features_min                                  # Case
                                   && $end_orf   >= $features_min                                  # ------->             ORF
                                   && $feature_annot_direction eq "<=="                            #      <---------      Ef
                                      )
                                  )
                                 )
                                ) {
                                my $max_start = ( ( $features_min > $start_orf ) ? $features_min : $start_orf);
                                my $min_end   = ( ( $features_max < $end_orf )   ? $features_max : $end_orf );
                                next if (  $overlappingcutoff < ( $min_end - $max_start + 1));
                            }    
                        }
 
                        if ($isMinus) {
                            if ( ( $feature_annot_type eq "G")                                     # Gene whithout intron
                                               ||   
                                 ( $features_who_overlap->[4] eq "FIRST"                           # Case
                               && (  ($start_orf >= $features_min                                  # <--------          ORF
                                   && $end_orf   <= $features_min                                  #      --------->    E1
                                   && $feature_annot_direction eq "==>"
                                     )
                                                 ||
                                     ($start_orf   >= $features_max                                # Case
                                   && $end_orf      <= $features_max                               #     <---------     ORF
                                   && $feature_annot_direction eq "<=="                            # <--------          E1
                                     )
                                  )
                                 )
                                               ||   
                                 ( $features_who_overlap->[4] eq "LAST"
                               && (  ($start_orf >= $features_max                                  # Case
                                   && $end_orf   <= $features_max                                  #      <--------     ORF 
                                   && $feature_annot_direction eq "==>"                            #  -------->         Ef
                                     )
                                                 ||
                                     ($start_orf   >= $features_min                                # Case
                                   && $end_orf     <= $features_min                                # <-------           ORF
                                   && $feature_annot_direction eq "<=="                            #      <---------    Ef
                                     )
                                   )
                                 )
                                ) {
                                my $min_start = ( ( $features_max < $start_orf ) ? $features_max : $start_orf );
                                my $max_end   = ( ( $features_min > $end_orf )   ? $features_min : $end_orf);
                                next if (   $overlappingcutoff < ( $min_start - $max_end + 1));
                            }
                        }
                    }
 
                    if ($feature_annot_type eq "E") {
                        if (!$isMinus) {
                            if ( ($features_who_overlap->[3] ne "YES")                  # Intern exon
                                                       ||                               # No overlap is accepted
                                 ($features_who_overlap->[4] eq "FIRST"                 # First internal exon overlap
                               && $start_orf <= $feature_endpos
                               && $end_orf   >= $feature_endpos
                                 )
                                                       ||
                                 ($features_who_overlap->[4] eq "LAST"                 # Last internal exon overlap
                               && $start_orf <= $feature_startpos
                               && $end_orf   >= $feature_startpos 
                                 )
                               ) {
                                my $max_start = ( ( $features_min > $start_orf ) ? $features_min : $start_orf);
                                my $min_end   = ( ( $features_max < $end_orf )   ? $features_max : $end_orf );
                                next if ( 0 < ( $min_end - $max_start + 1));
                            }
                        }
       
                        if ($isMinus) {
                            if ( ($features_who_overlap->[3] ne "YES")                 # Intern exon
                                                       ||                              # No overlap is accepted
                                 ($features_who_overlap->[4] eq "FIRST"                # First internal exon overlap
                               && $start_orf >= $feature_endpos
                               && $end_orf   <= $feature_endpos
                                 )
                                                       ||
                                 ($features_who_overlap->[4] eq "LAST"                 # Last internale exon overlap
                               && $start_orf >= $feature_startpos
                               && $end_orf   <= $feature_startpos
                                 )
                               ) {
                                my $min_start = ( ( $features_max < $start_orf ) ? $features_max : $start_orf );
                                my $max_end   = ( ( $features_min > $end_orf )   ? $features_min : $end_orf);
                                next if ( 0 < ( $min_start - $max_end + 1));
                            }
                        }
                    }
                    $annotIsOk++;
                    last;
                }
            }
        }

        if ( (@$annot_who_overlap && $annotIsOk == $number_of_annot) || (!@$annot_who_overlap && $annotIsOK_gene_without_intron == 1) 
           && $overlap_an_intron == 0) {
        # Creating an annotation object for storing in the masterfile
        my $orfsize = ($end_orf - $start_orf + 1)/3  if  !$isMinus;
           $orfsize = ($start_orf - $end_orf + 1)/3  if   $isMinus;
           $orfsize--; # minus 1 for the stop codon
        my $GenenameORF = "orf". $orfsize;

        #  Treatment to add a number after the genename #
        my $startline = "";
        my $endline   = "";
        $startline    = ";     G-$GenenameORF $arrow start";
        $startline    = ";     G-$prefix-"."$GenenameORF $arrow start" if $prefix ne "";
        $startline   .= " ;; MFFEAT=$TAGNAME empty ORF" if $ADDCOMMENTS;     # Add comments if option is activated
        $endline      = ";     G-$GenenameORF $arrow end";
        $endline      = ";     G-$prefix-"."$GenenameORF $arrow end" if $prefix ne "";
        $endline     .= " ;; MFFEAT=$TAGNAME empty ORF" if $ADDCOMMENTS;
   
        my $orfannot = new PirObject::AnnotPair(
                                                 type      => "G",  
                                                 genename  => $GenenameORF,
                                                 startpos  => $start_orf,
                                                 endpos    => $end_orf,
                                                 direction => $arrow,
                                                 startline => $startline,
                                                 endline   => $endline,
                                               );
    
        # Put into the table containing all of the masterfile annotations
        # So before, being put in the masterfile (means in a first time in the annotation table), there are some verification
        &AddAnnotToPirMaster($pirmaster,$contigname,$orfannot);
        } # End of if
    } # End of for each empty orfs
} # End sub


#------------------------------------#
# Subs for processing intronic ORFs  #
#------------------------------------#

sub AnnotateIntronicOrfs {
    my $pirmaster           = shift; # Get the masterfile object
    my $contigs             = $pirmaster->get_contigs();
    my $minimumlengthorf_nt = $MINLENEMPTYORF;
    my $minimumlengthorf_aa = $minimumlengthorf_nt / 3;
    my $intronic_orfs;
    my $potential_intronic_orfs;
    
    foreach my $contig (@$contigs) {
        my $name       = $contig->get_name();
        my $annotation = $contig->get_annotations();
        my $seq        = $contig->get_sequence();
           $seq        =~ s/[^atcgATCGnN]//g;
        my $test_prot  = "";
        foreach my $annot (@$annotation) {
            my $type      = $annot->get_type();
            my $direction = $annot->get_direction();
            my $start     = $annot->get_startpos();
            my $end       = $annot->get_endpos();
            my $startline = $annot->get_startline();
            my $endline   = $annot->get_endline();
            my $prefix    = "";
            my $prot      = "";
            my @orf; 
            
            next if $type ne "I";
            
            $prot          = "";
            ($prefix)      = $endline =~ /;\s+G-(\S+)/;
            $startline     =~ m#G-(\S+)-I(\d+)#;
            my $num_intron = $2;
            for (my $j = 0; $j < 3; $j++) {
                $start                 = $annot->get_startpos() + $j if $direction eq "==>";
                $start                 = $annot->get_startpos() - $j if $direction eq "<==";
                my $min_pos            = ($direction eq "==>" ? $start : $end );
                my $max_pos            = ($direction eq "==>" ? $end : $start );
                my $diff               = $max_pos - $min_pos + 1;
                my $intronic_sequence  = substr($seq, $min_pos -1, $diff);
                my $modulo             = length($intronic_sequence) % 3;
                $intronic_sequence     =~ tr/acgt/ACGT/;
                $intronic_sequence     =~ tr/ACGT/TGCA/ if $direction eq "<==";
                $intronic_sequence     = reverse $intronic_sequence if $direction eq "<==";
                $intronic_sequence     = substr($intronic_sequence,0, length($intronic_sequence)-$modulo);
                $intronic_sequence     =~ tr/a-z/A-Z/;
                my @pos_of_stop        = ();
                ($prot = $intronic_sequence ) =~ s/(...)/$CODON_TABLE->{$1}/ge;
                for (my $i = 0; $i <= length($intronic_sequence) - 3 ; $i += 3) {
                    my $orf;
                    my $strand_current_orf = $direction; 
                    my $nt = substr($intronic_sequence,$i,3);
                    my $aa = $CODON_TABLE->{$nt};
                    if ($aa eq "*") {
                        my $relative_pos_of_stop = $i + 3; # In order to include stop codon
                        push(@pos_of_stop, $relative_pos_of_stop);
                    } # if
                } # for
                unshift(@pos_of_stop, 0);
                for (my $i = 0; $i < @pos_of_stop - 1; $i++){
                    next if !( abs($pos_of_stop[$i+1] - $pos_of_stop[$i]) >= $minimumlengthorf_nt );
                    my $start_orf = $start + $pos_of_stop[$i]       if $direction eq "==>";
                       $start_orf = $start - $pos_of_stop[$i]       if $direction eq "<==";
                    my $end_orf   = $start + $pos_of_stop[$i+1] - 1 if $direction eq "==>";
                       $end_orf   = $start - $pos_of_stop[$i+1] + 1 if $direction eq "<==";

                    my $intronic_orf = new PirObject::EmptyOrf (
                                                                start      => $start_orf,
                                                                end        => $end_orf,
                                                                strand     => $direction,
                                                                contigname => $name,
                                                                intron     => $num_intron,
                                                                phase      => $j,
                                                                prefix     => $prefix
                                                               );
                    push (@$intronic_orfs, $intronic_orf);
                } # for $i
            } # for $j
        } # foreach annot
    } # foreach contig
        
    foreach my $intronic_orf (@$intronic_orfs) {
        my $annotIsOk         = 0;
        my $start_orf         = $intronic_orf->get_start();
        my $end_orf           = $intronic_orf->get_end();
        my $direction         = $intronic_orf->get_strand();
        my $contigname        = $intronic_orf->get_contigname();
        my $prefix            = $intronic_orf->get_prefix(); 
        my $contig            = $pirmaster->GetContigByName($contigname) or die "Can't get contig by name in AnnotateEmptyOrfs\n";
        my $seq               = $contig->sequence;              # Get the sequence
           $seq               =~ s/!//g;                        # Remove ! from the sequence
        my $annot_who_overlap = &WhatOverlapsThis($start_orf,$end_orf,$contig);
        my $isInPhase         = &IsInPhase($intronic_orf,@$annot_who_overlap);
        my $isMinus           = ($direction eq "==>" ? 0 : 1);
        my $posOffset         = ($isMinus ? -3 : 3);

        for (;;$start_orf += $posOffset) {
            last if $start_orf >= $end_orf   && !$isMinus;
            last if $end_orf   >= $start_orf && $isMinus;
            last if  (($end_orf - $start_orf + 1 ) < $minimumlengthorf_nt) && !$isMinus;
            last if  (($start_orf - $end_orf + 1 ) < $minimumlengthorf_nt) &&  $isMinus;  #  Size verification 
    
            my $codon = uc (substr($seq, $start_orf - 1, 3)) if !$isMinus;
               $codon    = uc (substr($seq, $start_orf - 3, 3)) if $isMinus;
               $codon    =~ tr/ACGT/TGCA/ if $isMinus;
               $codon    = reverse $codon if $isMinus;
               $codon    = "ATG" if $isInPhase;
  
            next unless defined($CODON_TABLE->{$codon})  && $CODON_TABLE->{$codon} eq "M";
            $annotIsOk = 1;
            last;
        }
 
        next if !( $annotIsOk == 1);
        # Creating an annotation object for storing in the masterfile
        my $orfsize = ($end_orf - $start_orf + 1)/3  if  !$isMinus;
           $orfsize = ($start_orf - $end_orf + 1)/3  if   $isMinus;
           $orfsize--; # Minus 1 for the stop codon
        my $GenenameORF = "orf". $orfsize;
  
        my $diff_nt = $end_orf - $start_orf + 1 if $direction eq "==>";
           $diff_nt = $start_orf - $end_orf + 1 if $direction eq "<==";
   
        my $seq_orf_nt = substr($seq, $start_orf - 1, $diff_nt) if $direction eq "==>";
           $seq_orf_nt = substr($seq, $end_orf - 1 , $diff_nt)  if $direction eq "<==";
           $seq_orf_nt =~ tr/ACGT/TGCA/                         if $direction eq "<==";
           $seq_orf_nt = reverse $seq_orf_nt                    if $direction eq "<==";
           $seq_orf_nt =~ tr/a-z/A-Z/;
  
        my $seq_orf_aa = "";
        ($seq_orf_aa = $seq_orf_nt ) =~ s/(...)/$CODON_TABLE->{$1}/ge;

        my $potential_intronic_orf = new PirObject::EmptyOrf (
                                                              start      => $start_orf,
                                                              end        => $end_orf,
                                                              strand     => $direction,
                                                              contigname => $contigname,
                                                              intron     => $intronic_orf->get_intron(),
                                                              phase      => $intronic_orf->get_phase(),
                                                              prefix     => $prefix,
                                                              size       => $orfsize,
                                                              seq        => $seq_orf_aa
                                                             );
        push (@$potential_intronic_orfs, $potential_intronic_orf);
    }
    
    my %no_annotation;
    if ($potential_intronic_orfs) {
        for (my $i = 0; $i < @$potential_intronic_orfs; $i++) {
            my $start_orf_1     = @$potential_intronic_orfs[$i]->get_start();
            my $end_orf_1       = @$potential_intronic_orfs[$i]->get_end();
            my $direction_orf_1 = @$potential_intronic_orfs[$i]->get_strand();
            my $contig_orf_1    = @$potential_intronic_orfs[$i]->get_contigname();
            my $min_pos_orf_1   = ($direction_orf_1 eq "==>" ? $start_orf_1 : $end_orf_1);
            my $max_pos_orf_1   = ($direction_orf_1 eq "==>" ? $end_orf_1   : $start_orf_1);
            my @tab_for_choose_intron;
            my $selected_orf    = "";
            push(@tab_for_choose_intron, [$i, @$potential_intronic_orfs[$i]]); 
            for (my $j = 0; $j < @$potential_intronic_orfs; $j++) {
                next if !($j != $i);
                my $contig_orf_2    = @$potential_intronic_orfs[$j]->get_contigname();
                next if ($contig_orf_1 ne $contig_orf_2);
                my $start_orf_2     = @$potential_intronic_orfs[$j]->get_start();
                my $end_orf_2       = @$potential_intronic_orfs[$j]->get_end();
                my $direction_orf_2 = @$potential_intronic_orfs[$j]->get_strand();
                my $min_pos_orf_2   = ($direction_orf_2 eq "==>" ? $start_orf_2 : $end_orf_2 );
                my $max_pos_orf_2   = ($direction_orf_2 eq "==>" ? $end_orf_2   : $start_orf_2);
                next if !(!($max_pos_orf_1 < $min_pos_orf_2 || $max_pos_orf_2 < $min_pos_orf_1));
                push(@tab_for_choose_intron, [$j, @$potential_intronic_orfs[$j]]); 
             }
 
            if (@tab_for_choose_intron > 1) {
                my $num_selected_orf = &choice_orf(\@tab_for_choose_intron);
                $selected_orf = @$potential_intronic_orfs[$i] if $num_selected_orf == $i;
            }
            else {
                $selected_orf = @$potential_intronic_orfs[$i];
            }
    
            next if !($selected_orf ne "");
            #  Treatment to add a number after the genename #
            my $GenenameORF = "orf".$selected_orf->get_size();
            my $direction   = $selected_orf->get_strand();
            my $prefix      = $selected_orf->get_prefix(); 
            my $contigname  = $selected_orf->get_contigname();
            my $startline   = ";     G-$GenenameORF $direction start";
               $startline   = ";     G-$prefix-"."$GenenameORF $direction start" if $prefix ne "";
               $startline  .= " ;; MFFEAT=$TAGNAME empty ORF" if $ADDCOMMENTS;     # Add comments if option is activated
            my $endline     = ";     G-$GenenameORF $direction end";
               $endline     = ";     G-$prefix-"."$GenenameORF $direction end" if $prefix ne "";
               $endline    .= " ;; MFFEAT=$TAGNAME empty ORF" if $ADDCOMMENTS;
            
            #  Treatment to add a number after the genename #
            my $orfannot = new PirObject::AnnotPair(
                                                    type      => "G",  
                                                    genename  => $GenenameORF,
                                                    startpos  => $selected_orf->get_start(),
                                                    endpos    => $selected_orf->get_end(),
                                                    direction => $direction,
                                                    startline => $startline,
                                                    endline   => $endline,
                                                   );
    
            # Put into the table containing all of the masterfile annotations
            # So before, being put in the masterfile (means in a first time in the annotation table), there are some verification
            &AddAnnotToPirMaster($pirmaster,$contigname,$orfannot);
        } # End for
    } # End if
} # End sub

sub choice_orf {
    my $orfs = shift;  # Ref to array of pairs [ idx, Orf_object ]
    
    if (!(-e "$TMPDIR/fdb_intronic_orf.log")) {
        my $LIB = new IO::File "$intronic_lib" || die ("Can not open the library for intronic orfs");
        while (<$LIB>) {
            next if !($_ =~ /^>/);
            die "The file $intronic_lib haven't the good syntax\nThe line who haven't the good syntax is $_"
                if (!($_ =~ /\s*([\S]*)\s*;/));
        }
        $LIB->close();
    
        my $command      = "$FORMATDBPATH -p 'T' -t banque -i $intronic_lib -n $TMPDIR/mf_intronic_orf -l $TMPDIR/fdb_intronic_orf.log >/dev/null 2>/dev/null";
        print "$command\n" if $DEBUG;
        my $resformatdb  = system($command);
    }
    
    foreach my $orf ( @$orfs ) {
        my $name_of_file = "$TMPDIR/orf_".$orf->[0];
        my $orf_seq      = $orf->[1]->get_seq();
        my $orf_num      = $orf->[0];
        my $output       = "$TMPDIR/blastoutput_orf_".$orf->[0];
        my $type         = 'PROT';
        if (!(-e "$name_of_file")){
            my $ORFFILE = new IO::File ">$name_of_file" or die "Can not open the orffile";
            print $ORFFILE ">ORF_$orf_num\n";
            print $ORFFILE $orf_seq;
            $ORFFILE->close();
            
            # RUN FOR BLAST : run blast with the db created and the flip results        
            my $cmdblast = "$BLASTPATH -m 7 -p blastp -M $MATRIX -d $TMPDIR/mf_intronic_orf -i $name_of_file -D $GENCODE -o $output 2> $TMPDIR/blasterr_1.txt";
            print "$cmdblast\n" if $DEBUG;
            my $resblast = system ($cmdblast);
        }
        
        my $searchfh = new IO::File "<$output"
           or die "Error: can't find $type report from blastall ?!?\n";
        my @results = PirObject::BlastOutput->FileHandleToObject($searchfh);
        $searchfh->close();

        my $num    = @results;
        die "We have more than 1 blast result for 1 orf\n" if $num > 1;

        $orf->[1]->set_evalue(9999);                # Really bad evalue by default

        my $iters  = $results[0]->BlastOutput_iterations() || next;
        next if @$iters == 0;
        my $hits   = $iters->[0]->Iteration_hits();
        next if !@$hits;
        my $best_evalue = $hits->[0]->significance();

        $orf->[1]->set_evalue($best_evalue);
    }
    
    my @orfs_sorted = sort{ &CompareHighPrecisionFloats($a->[1]->get_evalue(),$b->[1]->get_evalue())
                                                  ||
                            $b->[1]->get_size()  <=>  $a->[1]->get_size() } @$orfs;
    
    return $orfs_sorted[0]->[0];
} # End sub

sub IsInPhase {
    my $intronic_orf      = shift;
    my $annot_who_overlap = shift;
    
    my $strand_orf     = $intronic_orf->get_strand();
    my $start_orf      = $intronic_orf->get_start();
    my $phase_orf      = $intronic_orf->get_phase();
    my $num_intron     = $intronic_orf->get_intron();
    my $length_add     = 0;
    my $distance_inf_3 = 0;
    
    foreach my $features_who_overlap (@$annot_who_overlap ) {
        my $feature_type      = $features_who_overlap->[2]->get_type();    
        my $feature_start     = $features_who_overlap->[2]->get_startpos();
        my $feature_end       = $features_who_overlap->[2]->get_endpos();
        my $feature_direction = $features_who_overlap->[2]->get_direction();
        my $feature_startline = $features_who_overlap->[2]->get_startline();
        next if !($feature_type eq "E");
        $feature_startline =~ m#G-(\S+)-E(\d+)#;
        my $num_exon       = $2;
        my $min_pos        = ($feature_direction eq "==>" ? $feature_start : $feature_end );
        my $max_pos        = ($feature_direction eq "==>" ? $feature_end : $feature_start );
        if ($num_exon == $num_intron) {
            $distance_inf_3 = 1 if $feature_direction eq "==>" && $start_orf - $feature_end <= 3; 
            $distance_inf_3 = 1 if $feature_direction eq "<==" && $feature_end - $start_orf <= 3;
        }
        if ($num_exon <= $num_intron) {
            my $length   = $max_pos - $min_pos + 1;
            $length_add += $length;
        }
    } # End foreach $features_who_overlap
    $length_add += $phase_orf;
    return 1 if ($length_add % 3 == 0 && $distance_inf_3 == 1);
    return 0;
} # End sub

#-----------------------------------#
# Subs used for check Multicomments #
#-----------------------------------#

sub MulticommentConfidence {
    my $pirmaster = shift;
    my $contigs   = $pirmaster->get_contigs();
    
    foreach my $contig (@$contigs) {
        my $annotations = $contig->get_annotations();
        foreach my $annot (@$annotations) {
            my $startmulticomments = $annot->get_startmulticomment();
            my $endmulticomments   = $annot->get_endmulticomment();
            next if !$startmulticomments->[0] && !$endmulticomments->[0];
            
            if ($startmulticomments->[0]) {
                my $startline = $annot->get_startline();
                   $startline =~ s/\s*\\?\s*$/ \\/ ;
                   $annot->set_startline($startline);
                foreach my $line (@$startmulticomments) {
                    last if $line eq $startmulticomments->[-1];
                    $line      =~ s/\s*\\?\s*$/ \\/;
                }
            }
            
            if ($endmulticomments->[0]) {
                my $endline = $annot->get_endline();
                   $endline =~ s/\s*\\?\s*$/ \\/;
                   $annot->set_endline($endline);
                foreach my $line (@$endmulticomments) {
                    last if $line eq $endmulticomments->[-1];
                    $line    =~ s/\s*\\?\s*$/ \\/;
                }
                
            }
        }
    }
}

#------------------------------------------#
# Subs used at different times in Mfannot  #
#------------------------------------------#

sub AddAnnotToPirMaster {
    # Meaning code for this function
    # return 1 means ok, it has been added
    # return 0 means function quit before the end, => rediscovered 

    my $pirmaster   = shift;
    my $contigname  = shift;
    my $annot       = shift;
    my $contig      = $pirmaster->GetContigByName($contigname) or die "Can't get contig by name\n";
    my $annotations = $contig->get_annotations;

    # Here we compare all the annotations, with the one we try to add 
    foreach my $annotation (@$annotations) {
        my $annotname  = $annotation->genename; 
        my $annottype  = $annotation->type || "C";
        my $annotstart = $annotation->startpos;
        my $annotend   = $annotation->endpos;
        $annotname     = "comment" if (!defined  ($annotname));
        $annotstart    = -1        if (!defined  ($annotstart));
        $annotend      = -1        if (!defined  ($annotend));

        # First case : if both are same comment on the same line 
        if (($annottype eq "C") and ($annot->type eq "C") and
            ($annot->startpos == $annotstart) and
            ($annot->startline eq $annotation->startline)) {
            # Nothing is done in this case,
            return 0;
        }

        # Second case : No comment, both have same start end, and genename;
        if (($annottype ne "C") and ($annotname eq $annot->genename) and
            ($annotstart == $annot->startpos) and
            ($annotend == $annot->endpos)) {
            $ANNOT_STATS->{'Rediscovered'}->{$annot->genename} ||= {   'I' => 0, 'E' => 0, };
            return 0;
        }

        # Third case : Exons
        if ($annot->type eq "E") { 
            # It's an exon. The protein has normally already been added
            if (defined ($annot->genename)) {
                $ANNOT_STATS->{'Added'}->{$annot->genename}->{'E'} ++;
            }
            push (@$annotations, $annot);
            return 1;
        }

        # 4th case : Introns
        if ($annot->type eq "I") { 
            # it's an intron. The protein has normally already been added
            if (defined ($annot->genename)) {
                $ANNOT_STATS->{'Added'}->{$annot->genename}->{'I'} ++;
            }
            push (@$annotations, $annot);
            return 1;
        } 
    }

    if ($FORCEANNOT) { 
        # If Force annot, you can add a new one
        $ANNOT_STATS->{'Added'}->{$annot->genename} ||= {  'I' => 0, 'E' => 0, } if ($annot->genename ne "comment");
        push (@$annotations, $annot);
        return 1;
    }

    if ($annot->type eq "C") {
        push (@$annotations, $annot);
        return 1;
     }

     if (&AnnotAlreadyAtSamePlace($annotations, $annot->startpos, $annot->endpos, $annot->genename)) {
         # It mean,, this annotation has already been seen
         $ANNOT_STATS->{'Rediscovered'}->{$annot->genename} ||= {  'I' => 0, 'E' => 0, } if ($annot->genename ne "comment");
         return 0;
     }

     #  It means, force annot but this annotations doesn't seems to have an other copy
     $ANNOT_STATS->{'Added'}->{$annot->genename} ||= {  'I' => 0, 'E' => 0, } if ($annot->genename ne "comment");
     push (@$annotations, $annot);
     return 1;
}

sub AnnotAlreadyAtSamePlace {
    my $annotations = shift;
    my $start       = shift;
    my $end         = shift;
    my $name        = shift;
    
    return if $name =~ /^!/;
    ($start,$end) = ($end,$start) if $start > $end; 
    $name =~ s/_\d+$//;

    foreach my $annotation (@$annotations) {
        next if $annotation->type eq "C";
        next if $annotation->genename =~ /^!/;
        my $annot_name  = $annotation->genename;
        my $annot_start = $annotation->startpos;
        my $annot_end   = $annotation->endpos;
        $annot_name     =~ s/_\d+$//;  
        ($annot_start,$annot_end) = ($annot_end,$annot_start) if $annot_start > $annot_end; 
        return 1 if ( (!($end < $annot_start || $annot_end < $start)) && $name eq $annot_name);
    } # End foreach $annot
    return 0;
} # End sub

sub WhatOverlapsThis {
    my $wstart     = shift;
    my $wend       = shift;
    my $contig     = shift;

    my $contiglen  = $contig->get_sequencelength();
    my $annotlist  = $contig->get_annotations() || [];
    
    ($wstart, $wend) = ($wend, $wstart) if $wend < $wstart;

    my @GEI_annots = grep( $_->get_type() =~ m#^[GEI]$# , @$annotlist);
    my %RanksGEI   = ( G => 0, E => 1, I => 2 );
    @GEI_annots    = sort { $a->get_genename() cmp $b->get_genename()
                                                or
                     $RanksGEI{$a->get_type()} <=> $RanksGEI{$b->get_type()}
                                                or
                            $a->get_startpos() <=> $b->get_startpos();
                           } @GEI_annots;

    my $groups = [];
    foreach my $annotation (@GEI_annots) {
        my $genename  = $annotation->get_genename(); # Does NOT contain the _1
        my $type      = $annotation->get_type();
        my $startline = $annotation->get_startline();
        my $start     = $annotation->get_startpos();
        my $end       = $annotation->get_endpos();
        my $dir       = $annotation->get_direction() || "==>";

        my ($ostart,$oend) = ($start,$end); # Strandless interval
           ($ostart,$oend) = ($end,$start) if $end < $start;

        if ($type eq "G") {
            next unless # No overlap? next
                &OverlappingRegions($contiglen,$start,$end,$dir,$wstart,$wend,">"); # Real dir of orf not important
            push(@$groups, [ [ $ostart, $oend, $annotation ] ] );
            next;
        }

        # For introns and exons
        foreach my $group (@$groups) {
            my $geneinfo = $group->[0]; # First entry of group is always a gene object
            my $gi_name  = $geneinfo->[2]->get_genename();
            next unless $gi_name eq $genename;
            my $gstart = $geneinfo->[2]->get_startpos();
            my $gend   = $geneinfo->[2]->get_endpos();
            my $gdir   = $geneinfo->[2]->get_direction();
            next unless # if E or I is outside of gene
                &OverlappingRegions($contiglen,$start,$end,$dir,$gstart,$gend,$gdir);
            push(@$group, [ $ostart, $oend, $annotation ] );
            #  last; # commented out in case for some reason an exon overlap multiple genes with the same names!
        } # End foreach $group
    } # End foreach $annotation

    # Now, flag the first and last exon of each group in field ->[3] of each group
    foreach my $group (@$groups) {
        $group->[0]->[3] = "";  # Flag set to false for first entry
        if (@$group == 1) {     # Gene with no introns
            $group->[0]->[3] = "YES";
            next;
        }
        my $maxexnum=0;
        my $maxexinfo="";
        for (my $i=1;$i<@$group;$i++) {
            my $info = $group->[$i];
            $info->[3] = "";  # Flag set to false
            next unless $info->[2]->get_type() eq "E";
            my $startline = $info->[2]->get_startline() || "";
            next unless $startline =~ m#G-(\S+)-E(\d+)#;
            my $exnum = $2;
            $info->[3] = "YES"   if $exnum == 1; # First exon flaged
            $info->[4] = "FIRST" if $exnum == 1; # First exon flaged
            $info->[4] = ""      if $exnum != 1; # First exon flaged
            if ($exnum > $maxexnum) {
                $maxexnum = $exnum;
                $maxexinfo = $info;
            }
        }
        if ($maxexinfo) {             # Should always be true here
            $maxexinfo->[3] = "YES";  # This is the last exon of the group
            $maxexinfo->[4] = "LAST"; # This is the last exon of the group
        }
    }
    $groups;
} # End sub

sub OverlappingRegions {
    # Works even for circular genomes and regions that span the gap
    my ($seqlen,$start1,$end1,$dir1,$start2,$end2,$dir2) = @_;

    my $spansgap1 = (($dir1 =~ m#>#) xor ($start1 <= $end1)); # true means spans the gap
    my $spansgap2 = (($dir2 =~ m#>#) xor ($start2 <= $end2)); # true means spans the gap

    if ($spansgap1) {
        if ($dir1 =~ m#>#) {
            $end1 += $seqlen;
        } 
        else {
            $start1 += $seqlen;
        }
    }

    if ($spansgap2) {
        if ($dir2 =~ m#>#) {
            $end2 += $seqlen;
        }
        else {
            $start2 += $seqlen;
        }
    }

    ($start1,$end1) = ($end1,$start1) if $start1 > $end1;
    ($start2,$end2) = ($end2,$start2) if $start2 > $end2;

    # Test for overlap
    return 1 if ! ($end1 < $start2 || $start1 > $end2);
    return 0 if $spansgap1 == $spansgap2; # same spanning sit -> we're done

    if (! $spansgap1) {
        $start1 += $seqlen;
        $end1   += $seqlen;
    }

    if (! $spansgap2) {
        $start2 += $seqlen;
        $end2   += $seqlen;
    }

    # Test for overlap again, new situation
    return 1 if ! ($end1 < $start2 || $start1 > $end2);
    return 0; # really, no overlap
} # End sub

sub WhichPhase {
    # In order to know the phase of the intron
    my $annot       = shift;
    my $num_intron  = shift;
    my $contig      = shift;
    
    my $annot_who_overlap = &WhatOverlapsThis($annot->startpos(),$annot->endpos(),$contig);
    
    my $nb_nt = 0;     # Length of all exon before the intron who studies
    foreach my $annotation_who_overlap (@$annot_who_overlap){
        foreach my $feature_who_overlap (@$annotation_who_overlap) {
            my $feature_min = @$feature_who_overlap[0];
            my $feature_max = @$feature_who_overlap[1];
            my $feature     = @$feature_who_overlap[2];
            next if !($feature->get_startline() =~ m#;\s+G-.+E(\d+).+#);
            my $number = $1 if $feature->get_startline() =~ m#;\s+G-.+E(\d+).+#;
            $nb_nt += abs($feature_max - $feature_min + 1 ) if $1 <= $num_intron;
        } # End foreach $feature_who_overlap
    } # End foreach $annotation_who_overlap
    my $phase = $nb_nt % 3 ;
} # End sub

sub Length_annot {
    # Just in order to calculate the length of annot
    my $annot = shift;
    
    my $start = $annot->startpos();
    my $end   = $annot->endpos();
    ($start,$end) = ($end,$start) if $annot->direction() eq "<=="; 
    my $length = ($end - $start + 1);
    return $length;
} # End sub


sub AddCommentToAnnotField {
    # Sub used to add comments at the end of annotation
    my $annot   = shift;
    my $method  = shift;
    my $comment = shift;
    
    my $line_to_modify  = $annot->$method();
    $line_to_modify .= " $comment" if ($line_to_modify !~ m#\Q$comment\E#);
    $annot->$method($line_to_modify);
} # End sub 

sub TranslateInProt {
    my $nt_seq = shift;
    
    my $prot_seq = "";
    foreach (my $i = 0; $i <= length($nt_seq) - 3; $i += 3) {
        my $tri_nt = uc (substr($nt_seq, $i , 3));
           $prot_seq .= $CODON_TABLE->{$tri_nt} || "X";
    }
    return $prot_seq;
}

sub ApPosStrandFW {
    my $ap  = shift;
    my $len_seq = shift;

    my $apMinus  = ($ap->get_direction() eq "==>" ? 0 : 1);
    my $ap_start = $ap->get_startpos();
    my $ap_end   = $ap->get_endpos() ;
       $ap_start = $len_seq + 1 - $ap_start if $apMinus;
       $ap_end   = $len_seq + 1 - $ap_end   if $apMinus;
    return ($ap_start,$ap_end);
}



#---------------------------------#
# Subs used at the end of Mfannot # 
#---------------------------------#

sub RenumberFeatures {
    # Post-processing: renumber gene names with unique
    # extensions such as _1, _2 etc. The original mechanism
    # that was trying to do this using %ANNOTSEEN is
    # broken, this routine does a better job.
    my $pirmaster = shift;

    my %genename2suffix = (); # cox3 => { _1 => [ [ obj obj ] [ obj ] ], "" => [ [ obj obj ] [ obj ] ] }

    my $contigs = $pirmaster->get_contigs(); # Get the masterfiles contigs
    foreach my $contig (@$contigs) {         # Parse all the contig
        my $contiglen = $contig->get_sequencelength();

        my $annotations = $contig->get_annotations();
        my @GEI_annots = grep( $_->get_type() =~ m#^[GEI]$# , @$annotations);
        my %RanksGEI = ( G => 0, E => 1, I => 2 );
        @GEI_annots = sort { $RanksGEI{$a->get_type()} <=> $RanksGEI{$b->get_type()}
                                                        or
                                    &IsIntronicOrf($a) <=> &IsIntronicOrf($b)
                                                        or
                                    $a->get_startpos() <=> $b->get_startpos();
                           } @GEI_annots;

        my %local_genename2suffix = (); # the %genename2suffix local to the current contig.
        foreach my $annotation (@GEI_annots) {
            my $genename  = $annotation->get_genename(); # Does NOT contain the _1
            my $type      = $annotation->get_type();
            my $startline = $annotation->get_startline() || "";
            my $start     = $annotation->get_startpos();
            my $end       = $annotation->get_endpos();
            my $dir       = $annotation->get_direction() || "==>";

            if ($startline =~ m#G-([^\-\s]+)#) { # We need to override for G-cox1_3-I4-orf34 for instance
                $genename  = $1;                 # We want cox1 not orf34
            }
            $genename =~ s/_\d+$//; # Make sure

            my $suffix = "";
               $suffix = $1 if $startline =~ m#(_\d+)#;

            my $local_suffix2groups = $local_genename2suffix{$genename} ||= {};
            my $groups              = $local_suffix2groups->{$suffix}   ||= [];
            my $addedToExistingGroup = 0;
            foreach my $group (@$groups) {
                my $firstfeat = $group->[0];
                my $ffstart   = $firstfeat->get_startpos();
                my $ffend     = $firstfeat->get_endpos();
                my $ffdir     = $firstfeat->get_direction() || "==>";

                if (&OverlappingRegions($contiglen,$start,$end,$dir,$ffstart,$ffend,$ffdir)) {
                    push(@$group,$annotation);
                    $addedToExistingGroup=1;
                    last;
                }
            }
            push(@$groups, [ $annotation ]) if (!$addedToExistingGroup); 
        } # End foreach annotation

        # Fusion %local_genename2suffix into the global %genename2suffix
        # We need to do this to keeps each contig's group separate
        foreach my $genename (keys %local_genename2suffix) {
            my $local_suffix2groups = $local_genename2suffix{$genename};
            my $suffix2groups       = $genename2suffix{$genename} ||= {};
            foreach my $suffix (keys %$local_suffix2groups) {
                my $local_groups = $local_suffix2groups->{$suffix};
                my $groups       = $suffix2groups->{$suffix} ||= [];
                push(@$groups, @$local_groups); # append to list
            }
        }

    } # End foreach contig

    # At this point, we've regrouped all G, E and I features in
    # overlapping groups based on their EXISTING suffixes. Now
    # let's fix these suffixes.

    foreach my $genename (keys %genename2suffix) {
        my $suffix2groups = $genename2suffix{$genename};
        my @suffixes = sort keys %$suffix2groups; # "" , _1, _2 etc etc

        next if ( @suffixes == 1 &&            # only one type of suffix found
                  $suffixes[0] eq "" &&        # case where only "genename" exists with no suffix
                  @{$suffix2groups->{""}} == 1 # a single instance? All ok.
                );

        # print "RENUMBER: $genename has duplicates: [",join("][",@suffixes),"]\n";
        # Ok, so we have a "" or _1 or _2 or _nn and/or a mix, we need to renumber
        my @keepnumbering=(); # We set aside those that need no renumbering; not used actually
        my @dorenumber=();    # These groups will be renumbered
        foreach my $suffix (@suffixes) {
            my $groups = $suffix2groups->{$suffix};
            if ($suffix eq "") {
                push(@dorenumber,@$groups); # All of them are renumbered
                next;
            }
            my $unchangedgroup = shift(@$groups); # Only first group KEEPS its number
            push(@keepnumbering,$unchangedgroup);
            push(@dorenumber,@$groups); # These get new numbers
        }

        # Renumber all annots of each group (each group gets a single new number)
        for (my $i = 1; @dorenumber > 0 ; $i++) {
            my $newsuf = "_$i";
            next if $suffix2groups->{$newsuf}; # Already used? try next suffix
            my $group = shift(@dorenumber);
            foreach my $annot (@$group) {
                my $origname  = $annot->get_genename();
                my $startline = $annot->get_startline();
                my $endline   = $annot->get_endline();
                my $type      = $annot->get_type();
                my $start     = $annot->get_startpos();
                my $end       = $annot->get_endpos();
                print "Warning: gene '$genename' ($start..$end) was renamed with suffix $newsuf to make it distinct.\n"
                    if $type eq "G" && $origname eq $genename && $genename ne "comment"; # no warn if "cox1_1-I1-orf344"
                # print " -> To $newsuf : $startline ";
                $startline = &ReplaceNumber($startline,$newsuf);
                # print " -> $startline\n";
                $endline   = &ReplaceNumber($endline,$newsuf);
                $annot->set_startline($startline);
                $annot->set_endline($endline);
            } # End foreach $annot
        } # End foreach $i
    } # End foreach $genename
} # End sub

# Substitutes, in a G- annotation line, the numbered suffix _1 _2 etc (which
# might not even be there) bu a new suffix ($newsuf).
sub ReplaceNumber {
    my $line   = shift;
    my $newsuf = shift;
    $line =~ s/(G-[^_\s]+)_\d+/$1/;  # Remove existing _1
    if ($line =~ m#G-\S+-[EI]\d+#) { # Exon or intron ?
        $line =~ s/(-[EI]\d+)/$newsuf$1/;
    } 
    else {
        $line =~ s/(G-\S+)/$1$newsuf/;
    }
    $line;
} # End sub

sub IsIntronicOrf {
    # Returns 1 if annotation line is like G-gene-Inn-orfblahblah
    my $annot = shift;
    return 0 unless $annot->get_type() eq "G";
    my $startline = $annot->get_startline() || "";
    print "WARNING NO START LINE IN OBJ:\n",$annot->ObjectToXML() if !defined($startline); 
    return 1 if $startline =~ m#G-\S+-I\d+-\S+#;
    return 0;
} # End sub

sub LogInfo {
    # This function is supposed to add information
    # in the head of the masterfile such as
    # - the genes added (with exons)
    # - the rediscovered genes    

    my $pirmaster = shift;
    my $header    = $pirmaster->header() || [];

    my @report    = ();
    my $added     = $ANNOT_STATS->{'Added'};
    my $redisc    = $ANNOT_STATS->{'Rediscovered'};

    my @added     = sort keys %$added;
    my $comp_add  = 0;
    foreach my $genename (@added){ 
    $comp_add++ if ( $genename =~ /^!/);  
    }
    my @redisc    = sort keys %$redisc;
    my $comp_red  = 0;
    foreach my $genename (@redisc)
    { 
    $comp_red++ if ( $genename =~ /^!/);  
    }

    my $gene_add = scalar(@added) - $comp_add;
    my $red_add = scalar(@redisc) - $comp_red;

    push(@report, ";;    - Gene Totals: " . $gene_add  . " added; " . $red_add . " rediscovered.",);

    # Gene added #
    push(@report, ";;    - List of genes added:",) if @added;

    my $COLS      = 3;
    my $cnt       = 0;
    my $rep       = "";

    print "Added : ", $gene_add, "\n" if $DEBUG;
    print $LOG_F "Added : ", $gene_add, "\n" if $ISLOGFILE;

    foreach my $genename (@added) {
        if ($genename =~ /^[^!]/) {
            my($e,$i) = (($added->{$genename}->{'E'} || 0),($added->{$genename}->{'I'} || 0)); 
            $rep      = ";;     " if !$cnt;
            $rep     .= sprintf(" %-20s", ("$genename" . ($e > 1 ? " ($e exons)" : "")));
            $cnt++;
            if ($cnt >= $COLS) {
                push(@report, $rep);
                $cnt  = 0;
            }
        }
    }
    push(@report, $rep) if $cnt;

    # Genes rediscovered #

    push(@report, ";;    - List of genes rediscovered:",) if @redisc;

    $cnt = 0;
    $rep = "";
    print "Rediscovered : ", $red_add, "\n" if $DEBUG;
    print $LOG_F "Rediscovered : ", $red_add, "\n" if $ISLOGFILE;
    foreach my $genename (@redisc) {
        if ($genename =~ /^[^!]/) {
            my ($e,$i) = ($redisc->{$genename}->{'E'},$redisc->{$genename}->{'I'});
            $rep       = ";;     " if !$cnt;
            $rep      .= sprintf(" %-20s", ("$genename" . ($e > 1 ? " ($e exons)" : "")));
            $cnt++;
            if ($cnt >= $COLS) {
                push(@report, $rep);
                $cnt = 0;
            }
        }
    }
    push(@report, $rep) if $cnt;
    push(@$header, ";; Masterfile modified automatically by $BASENAME version $VERSION");
    push(@$header, ";; on " . scalar(localtime(time))  . " by user $USER on host " . hostname());
    push (@$header, ";;    - New annotations labeled with: MFFEAT=$TAGNAME") 
    if $ADDCOMMENTS;  # We only put this sentence if option addcomments is activated
    push (@$header, @report, ";;",);
    push(@$header, $add_text_in_header) if $add_text_in_header ne "";
    $pirmaster->set_header($header);
}

# End Of File. Or is it? What's beyond? Maybe the lost characters of all the sentences that were trunca
