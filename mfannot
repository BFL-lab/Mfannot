#!/usr/bin/perl -w -- -*-Perl-*-

##############################################################################
#
#                                 mfannot.pl
#
# DESCRIPTION:
# Attempts to do a quick first pass at annotating a masterfile
# with meaningfull start/stop lines by calling blast on collections
# of known genes. Manual intervention is still required to check/adjust
# the new annotations.
#
# Known issues: - Annotations for START/STOP introns are interleaved (they
#                 are at the correct position, though).
#
##############################################################################

##############################################################################
#                                                                            #
#                       CONFIDENTIAL & PROPRIETARY                           #
#       Nothing herein is to be disclosed in any way without the prior       #
#           express written permission of Pierre Rioux                       #
#                                                                            #
#          Copyright 2004 Pierre Rioux, All rights reserved.                 #
#                                                                            #
##############################################################################
#
#    $Id: mfannot,v 1.55 2005/08/11 15:58:16 thomash Exp $
#
#    $Log: mfannot,v $
#    Revision 1.55  2005/08/11 15:58:16  thomash
#    Overlapping cutoff interval [0-1] => [0-100]
#
#    Revision 1.54  2005/08/10 21:03:05  dto
#    Added error checking for production of files
#
#    Revision 1.53  2005/08/10 18:39:05  dto
#    Fixed comments - removed card, put in map
#
#    Revision 1.52  2005/08/10 18:03:43  thomash
#    an other way of saying the produced map is..
#    Remove comments on generating map
#
#    Revision 1.51  2005/08/10 16:21:17  thomash
#    Delete the map option.
#    Map is generating with withmap option
#
#    Revision 1.50  2005/08/10 15:14:29  thomash
#    Map creating bug fixed
#
#    Revision 1.49  2005/08/09 21:47:34  thomash
#    A map generating option is avaliable
#
#    Revision 1.48  2005/08/09 20:37:56  dto
#    Fixed map creation
#
#    Revision 1.47  2005/08/09 19:49:56  thomash
#    check the genetic code
#
#    Revision 1.44  2005/08/09 18:15:51  thomash
#    a short mistake in masterfile spelling fixed
#
#    Revision 1.43  2005/08/09 18:13:52  thomash
#    name of the masterfile added in run
#
#    Revision 1.42  2005/08/05 21:41:09  thomash
#    add introns prediction
#
#    Revision 1.41  2005/07/28 21:12:45  thomash
#    Give name to the libraries in displaying
#    Bug fixed in reg exp, in blast parse function
#
#    Revision 1.40  2005/07/26 19:32:34  thomash
#    # If syntax changed
#    # Unused parts removed
#    # Formatdb put as a global variable in command line
#    # Print Steps on screen during application runnning
#
#    Revision 1.39  2005/07/26 12:49:39  dto
#    Added more tags for Thomas to fix
#    Fix BLASTOUTPUT line
#
#    Revision 1.38  2005/07/25 23:16:15  dto
#    Added more tags for Thomas
#
#    Revision 1.37  2005/07/25 21:18:47  dto
#    Removed non-required loop tags
#
#    Revision 1.36  2005/07/25 20:59:54  dto
#    Added tags for Thomas to fix
#    Fixed style
#    Fixed system commands - used Perl commands if possible
#
#    Revision 1.35  2005/07/25 20:40:43  dto
#    Fixed style and removed code that was not needed
#    Added comments for Thomas
#
#    Revision 1.34  2005/07/22 21:20:10  dto
#    Fixed up path locations of external cli programmes
#
#    Revision 1.33  2005/07/22 20:29:16  dto
#    Removed "..." at end of output file name (allows selecting of file by double clicking mouse)
#
#    Revision 1.32  2005/07/22 20:27:43  dto
#    Updated flip - now runs in the temporary directory
#
#    Revision 1.31  2005/07/22 18:21:39  dto
#    Removed commented code that was not required
#
#    Revision 1.30  2005/07/22 15:22:55  thomash
#    problem fixed with Line appearing  (*** ANnotation...***) without debug mode
#
#    Revision 1.29  2005/07/21 21:07:58  thomash
#    bug fixed about loading many libraries
#     - memory problems fixed
#     - some options changed
#
#    Revision 1.28  2005/07/18 20:57:43  thomash
#    The new mfannot version that allows to run
#    on many pepfiles, and many libraries.
#    Make sur you have the collection (directories)
#    dataorfcollection and datagenecollection,
#
#    Revision 1.27  2005/07/14 14:15:13  thomash
#    Variables in the programme update to fit with the new version
#    - variable matrix, added for genewise
#    - parameters for finding closest organism, removed
#    - other parameters such as exon and intron size updated
#
#    An function to create a genetic table from the genetic id code
#    created, to work with genewise
#
#    Revision 1.25  2005/06/29 19:24:37  thomash
#    little bug fixed
#
#    Revision 1.24  2005/06/29 18:55:39  thomash
#    bugs with trna scan solved
#    (Contig name)
#
#    Revision 1.21  2005/06/15 15:59:54  thomash
#    ORF size corrected
#
#    Revision 1.20  2005/06/13 21:04:54  thomash
#    - orf size changed : nucleotides => amino acids
#    - grouping of exons
#    - add a number for each gene (if the number of copies is more than
#    - 1)),
#      to the normal genes and trna genes
#    - change exons : comments => real annotations
#    - Exon problems corrected
#
#    Revision 1.19  2005/05/20 21:56:28  thomash
#    Contains, orf modifications.
#    Now, overlapping is calculated on the both strands
#
#    Revision 1.17  2005/05/11 21:22:43  thomash
#    The multiples annotations for a same frame function has been improved
#    Before, all the significant annotation were taken for the same ORF.
#    It could have a sense if a protein contains two functionnal domains
#    derived from 2 different protein.
#    The most of the time, an ORF having more than one annotation,
#    comes when two similar proteins correspond to the annotation
#    In this case we just want one annotation.
#    This has been done (but not tested one real fusion protein)
#    And work on proteins present in masterfiles used
#
#    Revision 1.14  2005/05/09 15:00:30  thomash
#    Problems fixed (Exons problems)
#
#    Revision 1.13  2005/05/05 19:41:33  thomash
#    mfannot modified in order to have more than one annotation
#    per ORF;
#    if option -m is in line command it will active the multi
#    annotation per ORF option
#
#    Revision 1.12  2005/05/05 16:00:06  thomash
#    Disallow, 2 annotations for the same gene, by default
#    Allows 2 annotations if option -f.
#    Give, too non coresponding ORF (it means, with no
#    corresponding gene after running blast) with a
#    specific cutoff size
#
#    Revision 1.10  2005/04/28 19:10:55  thomash
#    Comment added,
#    Options problemes fixed by allowing
#    setting parameters
#    This mfannot version runs with the new
#    MAsterfile.pir object that allows the user
#    to load annotation from a Masterfile
#    having the same name
#
#    Revision 1.8  2005/04/13 20:06:07  thomash
#    New Version of Mfannot
#    Input : A masterfile (-m) and a peplibrary (-p)
#    First step : Give the pepfile from the peplibrary corresponding to
#    the closest Organism.
#    Second step : Doing annotation of the Masterfile with the pepfile
#    Annotation is made with translation (in the 6 frames) of the
#    Masterfile
#    and blasting the results with the pepfile.
#
#    Revision 1.6  2005/03/16 14:52:49  dto
#    Added correct location of perl
#
#    Revision 1.5  2005/03/15 20:36:22  thomash
#    Add tRNAscanSE for prediction
#
#    Revision 1.4  2005/03/04 20:47:29  dto
#    New version provided by Pierre
#    Modified by Hoellinger T. 2005/03/14
#
#

##########################
# Initialization section #
##########################

require 5.00;
use strict;
use vars qw( $VERSION $RCS_VERSION );
use IO::File;
use Cwd;
use File::Basename;
use File::Path;
use PirObject;                                        #  Pir module treatment 
use Bio::SearchIO;                                    #  Bioperl (used for parsing blast outout)
use Bio::SeqUtils;                                    #  Some biological tools
use Bio::Tools::Genewise;                             #  A tool to parse genewise (no more used)
use Bio::Tools::CodonTable;                           #  To create a codon table, to be used with genewise 

#---General Objects
PirObject->LoadDataModel("Masterfile");               #  Masterfile object
PirObject->LoadDataModel("MfAnnotConfig");            #  Configuration object
PirObject->LoadDataModel("tRNAscanSEparser");         #  Parser for tRNAscanSE output

#---Objects for annotation 
PirObject->LoadDataModel("FlipBlastProt");            #  Objects for storing ORFs predicted by Flip and kept with blast
PirObject->LoadDataModel("Orf");                      #  ORF (belong to FlipBlastProt)
PirObject->LoadDataModel("Hsp");                      #  High Scoring Pair (belong to Orf)
PirObject->LoadDataModel("HypProt");                  #  Hypothetical protein : We believe its a protein after flip, blast an
                                                      #  Organization of the results     
PirObject->LoadDataModel("Exon");                     #  Exons : belongs to Hypothetical proteins
PirObject->LoadDataModel("Intron");                   #  Intron : belongs to Hypothetical proteins
PirObject->LoadDataModel("Option");                   #  A module for options gestion
PirObject->LoadDataModel("EmptyOrf");                 #  Object containing Orfs having no corresponding genes

# Default umask
umask 027;

# Program's name and version number.
$RCS_VERSION='$Id: mfannot,v 1.55 2005/08/11 15:58:16 thomash Exp $';
($VERSION) = ($RCS_VERSION =~ m#,v ([\w\.]+)#);
my ($BASENAME) = ($0 =~ /([^\/]+)$/);

# Get login name.
my $USER=getpwuid($<) or getlogin or die "Can't find USER from environment!\n";

##################################
# Global variables and constants #
##################################

# Command-line args (first, original program)

my $TAGNAME          = undef;                   #  Tag : is presnt in masterfile within the annotations made with Mfannot
my $FORCEANNOT       = 0;
my $ANNOT_STATS      = {
                         'Added'        => {},  #  It means, never see it before
                         'Rediscovered' => {},  #  Means exist at the same place (not added into the file)
                       };
my $EMPTYORFS;                                  #  An array containing, EmptyOrf object. It means ORFs having
                                                #  no corresponding genes
my $ANNOTSEEN        = {};                      #  An array storing annotations that have been seen before
my %PENAMEDISPLAY;                              #  An hash array, containing the name to display, associate with peplibraries and pepfiles


# Command line Program's paths    
my $BLASTPATH        = "/share/supported/apps/ncbi/bin/blastall";
my $FORMATDBPATH     = "/share/supported/apps/ncbi/bin/formatdb";
my $FLIPPATH         = "/share/supported/apps/ogmp/bin/flip";
my $GENEWISEPATH     = "/share/unsupported/apps/wise_2.2.0/src/bin/genewise";
my $TRNASCANPATH     = "/share/supported/apps/tRNAscan-SE/bin/tRNAscan-SE";
my $MF2XMLPATH       = "/share/supported/apps/mf2xml/bin/mf2xml";
my $CGVIEWPATH       = "/share/supported/apps/cgview/bin/cgview";

# General options
my $DEBUG;                                      #  Debug mode. If true, display message on the screen
my $GENCODE          = undef;                   #  Genetique code
my $TMPDIR           = "/tmp/mfannot.$$";       #  Temporary directory
my $LOGFILE;                                    #  log file : store all the information about run
my $SIMILARITYSEARCH;                           #  Usefull for running similaritie gene process for annot.
my $ISLOGFILE        = 0;                       #  Just to know if the $LOGFILE is not empty (0 or 1)
my $MASTERFILE       = undef;                   #  Path for Masterfile
my $PEPFILE;                                    #  Path for the peptide file used
my $TAKEINPUTFILE;                              
my $FLIPBLASTPROTS;                             #  Array containing the Proteins predicted by Blast and Flip
my $HYPPROTS;                                   #  Array containing the Proteins predicted by Blast and Flip and reprocessed after
my $OUTPUTFILE;                                 #  Path for the new
my $USETRNASCANSE;                              #  T or F : use of tRNAscanSE in the annotation 
my $MULTIORFS;                                  #  0 or 1 allows many gene annotations for 1 ORF 
my $NEWRCFILE;                                  #  0 or 1 : print if a new rcfile is generated
my $NORCFILE;                                   #  0 or 1, if a rcfile has been used for loading data
my $RCFILE;                                     #  The rcfile used for loading options
my $ORFPROCESS;                                 #  Allows ORF appearing in the masterfile as annotations
my $LOADSTRICT;                                 #  Load strict Masterfile
my $ADDCOMMENTS;                                #  Add comments into masterfile (0 or 1) as mfeat=.....
my $CHECKORFS;                                  #  Say if yes or not have to check for orf, if no all orfs appears in mf                                   
my $PEPLIBRARIES;                               #  The libraries, in input, by default datagenescollection and dataorfcollection
my $INPUTPEPFILES;                              #  the input files
my @PEPFILES;                                   #  the pepfiles, used in the programm. They come from $PEPLIBRARIES and $INPUTPEPFILES
my $WITHMAP;                                    #  the allowed extension for the map. Png or svg

# Specific for the annotation (parameters for flip, blastall and organization)
my $BLASTOUTPUT       = "";                     #  The path for blast file results
my $BLASTEVALUECUTOFF;                          #  Cutoff value for the blast
my $MINLENGTHORF;                               #  This is the minimum length for creating an ORF with flip
my $MAXLENGTHFORGROUPINGORF;                    #  Minimum size of a gap between 2 ORf. If 2 same ORF
my $MINLENEMPTYORF;                             #  Minimum length for ORF empty orfs (non corresponding orfs)
my $OVERLAPPINGCUTOFF;                          #  Overlapping cutoff for ORFs 
my $TRNACUTOFF;                                 #  The cutoff for the tRNAs annotation
my $MININTRONSIZE;                              #  opposite of MAXLENGTHFORGROUPINGORF. Minimum size for intron
my $MINEXONSIZE;                                #  Minimum exon size for intron. In genewise.
my $MATRIX;                                     #  The matrix used in genewise alignement

my $NBCONTIGS=0;                                #  The number of contigs

#############################
# Environment Verifications #
#############################
# Added by David To 11th February 2005
$ENV{"BLASTMAT"} = "/share/supported/apps/ncbi/data";

die "Please make sure the BLASTMAT environment variable is set\n" .
    "to point to a directory where the blast matrices are stored.\n"
    unless defined($ENV{"BLASTMAT"}) and (-d $ENV{"BLASTMAT"}) and (-f ($ENV{"BLASTMAT"} . "/PAM30"));

# Check if the programmes exist!
TestFile($BLASTPATH);
TestFile($FORMATDBPATH);
TestFile($FLIPPATH);
TestFile($GENEWISEPATH);
TestFile($TRNASCANPATH);

##################
# HELP AND USAGE #
##################


sub Help {
    print "Help for mfannot.pl\n";
    print "-------------------\n";
    #&Usage;
}

# END


################
# Trap Signals #
################

sub SigCleanup { # private
     die "\nExiting: received signal \"" . $_[0] . "\".\n";
     # Note that some cleanup will be performed in the END block at this point.
}
$SIG{'INT'}  = \&SigCleanup;
$SIG{'TERM'} = \&SigCleanup;
$SIG{'HUP'}  = \&SigCleanup;
$SIG{'QUIT'} = \&SigCleanup;
$SIG{'PIPE'} = \&SigCleanup;
$SIG{'ALRM'} = \&SigCleanup;

###############################
#   M A I N   P R O G R A M   #
###############################

&GetOptions ;     # get the different options and put them into global variables

open (LOGFILE, ">$LOGFILE") if $ISLOGFILE;
#----------HEADER PRINTED OUT----------------------------------------------------------
my $header = "\n".
             "######################################################################\n".
             "MFANNOT, ORGANELLAR GENOME ANNOTATION PROGRAMME                       \n".
             "VERSION $VERSION                                                      \n".
             "Programmed by Thomas Hoellinger and Pierre Rioux\n".
             "######################################################################\n\n";

print $header;
print LOGFILE $header if $ISLOGFILE;

##---------------OPTIONS OF THE PROGRAM------------------------------------------------
my $options ="----------------------------------\n".
             "        General Options           \n".
             "----------------------------------\n";
    
if ($NORCFILE) {
    $options .= "No rcfile used for options\n";
}
else {
    $options .= "$RCFILE used for loading options\n";
}
$options .= "Masterfile used : $MASTERFILE\n";
$options .= "new Masterfile created : $OUTPUTFILE\n";
$options .= "the map $OUTPUTFILE.$WITHMAP will be generated\n" if ($WITHMAP ne "");
$options .= "Genetic code : $GENCODE\n";
$options .= "Tag for annotation : $TAGNAME\n" if $ADDCOMMENTS;
$options .= "New rcfile generated in .mfannotrc\n" if $NEWRCFILE;
$options .= "Add comments in Masterfile\n" if $ADDCOMMENTS;

if ($SIMILARITYSEARCH) {
    foreach my $pep (@$PEPLIBRARIES) {
        $options .= "Look in the peptide library $pep\n";
    }
    foreach my $pep (@$INPUTPEPFILES) {
        $options .= "Peptide file $pep\n";
    }
}
else {
    $options .=  "Any search in gene similarity for annotation\n";
}

if ($USETRNASCANSE == 0) {
    $options .= "No usage of tRNAscanSE\n";
}
else {
    $options .= "Usage of tRNAscanSE\n";
}

print LOGFILE $options if $ISLOGFILE;           #Print options in the logfile
print $options if $DEBUG;                       #Print the options on the screen 


##---------------CREATE THE TMPDIR---------------------------------------  
mkdir($TMPDIR,0700) or die "Error: can't create work directory '$TMPDIR': $!\n";


#-----------------PEPFILES CREATION--------------------------------------
          #  Fill the variable @PEPFILES
          #  A list of pepfiles, and run mfannot for each of them

#  1) first, create the list of the pepfiles with the libraries
my $count = 1;  

foreach my $library (@$PEPLIBRARIES) {
    next if (not -d $library);
      
    my $namefile = "$TMPDIR/library_" . $count;
    $count++;
    my $tmppepfile = &CreatePepfileWithLibrary ($library, $namefile);       # call the function 
    push (@PEPFILES ,$namefile);
    $PENAMEDISPLAY{"$namefile"} = $library;                                 # associate, the name of the library for each peplibraries
    
}    
#  2) second, push the input pepfiles in the pepfile array
    foreach my $file (@$INPUTPEPFILES) {
        push (@PEPFILES, $file);
        $PENAMEDISPLAY{"$file"} = $file;                                    # associate the same name, 
    }

#-----------ANNOTATION -------------------------------------------

# - print option of the annotation
print "----------------------------------\n",
      "         Gene Annotation          \n",
      "----------------------------------\n";
print LOGFILE "----------------------------------\n",
              "         Gene Annotation          \n",
              "----------------------------------\n" if $ISLOGFILE;

if ($SIMILARITYSEARCH) {
    $options  = "Options : \n";                  # Options & parameters used for the blast
    $options .= "Minimum size ORF, for flip running $MINLENGTHORF\n";
    $options .= "Blast e-value cutoff : $BLASTEVALUECUTOFF\n";
    $options .= "Minimum exon size : $MINEXONSIZE\n";
    $options .= "Maximum intron size : $MAXLENGTHFORGROUPINGORF\n";
    $options .= "Minimum intron size : $MININTRONSIZE\n";
    $options .= "Force annotation\n" if ($FORCEANNOT);
    $options .= "Matrix : $MATRIX\n";
    $options .= "Minimum length for non corresponding ORFs : $MINLENEMPTYORF\n";
    $options .= "Overlapping cutoff for non corresponding ORFs: " . $OVERLAPPINGCUTOFF . "%\n";
    $options .= "trna cutoff : $TRNACUTOFF\n" if ($USETRNASCANSE);
  
    print $options if $DEBUG;
  
    print LOGFILE $options if $ISLOGFILE;
}

# - create a masterfile object
#      - load the annotations
#      - load the sequence of each contig 

print "Parsing masterfile $MASTERFILE...\n";
my $pirmaster     = PirObject::Masterfile->ObjectFromMasterfile($MASTERFILE, $LOADSTRICT);
my $contigs       = $pirmaster->get_contigs();
my $numbercontigs = 0;                         # Number of contigs in the masterfile
my $numberannot   = 0;                         # Number of annotations detected in the program

$numbercontigs += scalar (@$contigs);
foreach my $contig ( @$contigs) {
    my $annotations = $contig-> get_annotations();
    $numberannot += scalar (@$annotations);
}

print "Number of contigs in Masterfile : $numbercontigs\n",
      "Number of annotations (or comments) detected : $numberannot\n" if $DEBUG;

print LOGFILE "Number of contigs in Masterfile : $numbercontigs\n",
              "Number of annotations (or comments) detected : $numberannot\n" if $ISLOGFILE;
      
&InitializeANNOTSEEN ($pirmaster);   # Initialise the work variables, to know how many copies per genes there are

#-------------------START THE PROCESS----------------------#
  
if ($SIMILARITYSEARCH) {
    my $step;
    $count = 1;
  
    foreach my $file (@PEPFILES) { # Each pepfile
                                      # The input pepfiles
                                      # + the pepfiles created from the libraries
  
        # Create a reference for the different general arrays
        $FLIPBLASTPROTS = [];                        #  Array containing the Proteins predicted by Blast and Flip
        $HYPPROTS = [];                              #  Array for the hypothetical proteins  
        $EMPTYORFS = [];                             #  Array containing the emptys ORF
        $step = 1; 
  
  
        ## Print the name of each pepfile###
        ##  if it's a library, name begin with libarary....
        $PEPFILE = $file;
        my $displayfile = $PENAMEDISPLAY{"$file"} || "$file";    # Get the associate name, so if it's a library, get the name of the library         
        my @tabname = split ("/", $displayfile);
        my $tringprint = "\n****** Annotation from " . $tabname [$#tabname] . " ******";
        print $tringprint, "\n";

        ## check the existenz ##
        if ((not -r  $PEPFILE) and $SIMILARITYSEARCH) {
            print "Unable to read $PEPFILE\n";
            next;
        }                          
        
        # --------   HEART --------#
  
        # Run the programm step by, to know the right step  
            
        # Flip running, generate ORFS
        print "$step) Run Flip...\n";
        $step += 1; 
        &RunFlip ($count);

        # Blast the flip result with the blast
        print "$step) Run Blast...\n";
        $step += 1;  
        &BlastFlipVSGene ($count);

        # Parse the blast result, create a flipblastprot object
        print "$step) Parse Information From Blast Results...\n";
        $step += 1;
        &ParseInformationFromBlastResult ($pirmaster, $TAGNAME);
     
        # Create Hypothetical proteins  
        print "$step) Identify similar ORFs...\n";
        $step += 1; 
        &FillHYPPROTSArrayWithFLIPBLASTPROTSArray;

        # Organise the hypothetical proteins (find the real start)
        print "$step) Process ORFs => genes...\n"; 
        $step += 1; 
        &OrganiseHYPPROTSArray ($pirmaster);     #  Find the start codon.
  
        # Make the alignement and give the exons
        print "$step) Internal structure prediction...\n"; 
        $step += 1; 
        &FindExonsInHypProtArray ($pirmaster, $count);

        # Annotate -> change hypothetical proteins into an object annotation
        print "$step) Annotation in the masterfile...\n";
        $step += 1; 
        &AnnotateMfFromHYPPROTSArray ($pirmaster);
  
        # Process empty orfs, -> annotate empty ORFs in the masterfile (whose who correspond to something good)
        if ($ORFPROCESS) {
            print "$step) Process Empty ORFs...\n"; 
            $step += 1; 
            &AnnotateEmptyOrfs ($pirmaster);
        }
  
        $count++;  # next pepfile

    }  #  End of each pepfile

}
  
if ($USETRNASCANSE) {                                                # find the trna genes
    print "\nAnnotate with tRNAscanSE...\n";               # by running trnascanSE
    &AddGeneFeatureUsingtRNAscanSE ($pirmaster, "trnascanSE");       # limited with a score for each case
}    

#-------------PROGRAMME ENDING---------------

    
print "----------------------------------\n",
      "       End of the Programme       \n",
      "----------------------------------\n";  
  
#  unreferencing 
undef $FLIPBLASTPROTS;
undef $HYPPROTS;
undef $EMPTYORFS;

# Add annotations in the masterfile            
my $cntigs      = $pirmaster->contigs();
my $annotations = $cntigs->[0]->annotations();

# Add informations in the masterfile     
&LogInfo ($pirmaster);
print "Dumping new masterfile in $OUTPUTFILE\n";
$pirmaster->ObjectToMasterfile("$OUTPUTFILE");

if (($WITHMAP ne "") and ($numbercontigs==1)) {
    &CreateMap;
    print "Genetic map: $OUTPUTFILE.$WITHMAP\n";
}
elsif (($WITHMAP ne "") and ($numbercontigs!=1)) {
   print "$numbercontigs contigs. Impossible to generate the map./n";
}

if ($ISLOGFILE == 1) {
    print "close Logfile : $LOGFILE\n" if $DEBUG;
    close LOGFILE or print "Logfile not closed\n";
}
exit 0;

#############################
#   S U B R O U T I N E S   #
#############################

sub GetOptions {          # this function is here to manipulate options
    my $option = new PirObject::Option ();      #  buil a new option model
    $option->FillOption ();                     #  This one buil with the default option and look for a rc file
    
    ### Now The object contains all the options
    
    
    #--General options
    $DEBUG             = $option->debug;         #  Debug mode. If true, display message on the screen
    $GENCODE           = $option->genetic;       #  Genetique code
    my $gentable = Bio::Tools::CodonTable->new();
    if   (not $gentable->id($GENCODE)) {
       die "Unexisting genetic id\n";
    }
    $SIMILARITYSEARCH  = $option->similarity;    #  Usefull for running similaritie gene process for annot.
    if($option->islogfile and defined($option->logfile)) {
      if(-w (dirname($option->logfile))) {
        $ISLOGFILE       = $option->islogfile;     #  Just to know if the $LOGFILE is not empty (0 or 1)
        $LOGFILE         = $option->logfile;       #  log file : store all the information about run
      }
      else {
        print "\nThe path to your logfile \"" . ($option->logfile). "\" is not writable by you.\n";
	print "No file logging will be performed\n";
        $ISLOGFILE       = 0;
        $LOGFILE         = undef;
      }
    }
    $PEPLIBRARIES      = $option->pepdirectory;  #  List of Path for peplibrary directory
    $MASTERFILE        = $option->masterfile;    #  Path for Masterfile
    $INPUTPEPFILES     = $option->inputfile;     #  Path for the peptide file used
    $OUTPUTFILE        = $option->outputfile;    #  Path for the new
    my $count = "";
    my $name = $OUTPUTFILE;
    # Checking to see if the path to the output file is writable
    if(!-w (dirname($name))) {
       die "\nThe path to where your outputfile will be produced is not writable by you ($name).\nPlease resolve this problem before running again\n";
    }

    # Determing new name of output file if file already exists
    chomp ($name);
    $name =~ s/\d*$//; 
    while (-r ("$name"."$count")) {
       if ($count eq "") {$count = 1;}
       else              {$count++;} 
    }      
    $OUTPUTFILE = "$name"."$count";
    
    $USETRNASCANSE     = $option->tRNAscanSE;    #  T or F : use of tRNAscanSE in the annotation 
    $TAKEINPUTFILE     = $option->takeinputfile; #  A boolean saying if programme is taking an input file
    $TAGNAME           = $option->tagname;       #  Adds a tag  
    $FORCEANNOT        = $option->force;         #  Force the annotation when 2 annotations have the same name
    $MULTIORFS         = $option->multiorfs;     #  Permit 2 annotations for an ORF
    $NEWRCFILE         = $option->newrcfile;     #  Just used to be printed. Indiquates that a new rcfile will be created
    $NORCFILE          = $option->norcfile;      #  0 or 1, if a rcfile has been used for loading data
    $RCFILE            = $option->rcfile;        #  The rcfile used for loading options
    if(!-w (dirname($RCFILE))) {
      die "\nThe path to where your rcfile will be produced is not writable by you ($RCFILE).\nPlease resolve this problem before running again\n";
    }

    $ORFPROCESS        = $option->orf;           #  For Orf process, allowing presence or not in the masterfile
    $LOADSTRICT        = $option->loadstrict;    #  Load strict masterfile
    $ADDCOMMENTS       = $option->addcomments;   #  Add comments in the masterfile
    my $allorfs        = $option->allorfs;       #  All orfs will apear and won't be checked if option is checked
    $CHECKORFS         = 0 if ($allorfs == 1);   #  A little calculation 
    $CHECKORFS         = 1 if ($allorfs == 0);   #  to find the opposite
    $WITHMAP           = $option->withmap;       #  The extension map
        
    #--Specific for the annotation (parameters for flip, blastall and organization)
    $BLASTEVALUECUTOFF       = $option->blast2;            #  Cutoff value for the blast
    $MINLENGTHORF            = $option->flip2;             #  This is the minimum length for creating an ORF with flip
    $MAXLENGTHFORGROUPINGORF = $option->maxintronsize;     #  Minimum size of a gap between 2 ORf. If 2 same ORF
    $MINLENEMPTYORF          = $option->minlenemptyorf;    #  Minimum length for ORF empty orfs (non corresponding orfs)
    $OVERLAPPINGCUTOFF       = $option->overlappingcutoff; #  Overlapping cutoff for ORFs 
    $TRNACUTOFF              = $option->trnacutoff;        #  tRNAs cutoff 
    $MININTRONSIZE           = $option->minintronsize;     #  opposite of $MAXLENGTHFORGROUPINGORF. Minimum size for intron
    $MINEXONSIZE             = $option->minexonsize;       #  Minimum exon size for intron. In genewise.
    $MATRIX                  = $option->matrix;            #  The matrix used in genewise alignement
    
}

sub CreatePepfileWithLibrary {
    my $library = shift;         # the name of the library
    my $pepfile = shift;         # the name of the file wanted.
                                 # This one contains after the all peptides from the library
    
    opendir (DIR, $library) or die 'can not open directory\n';        # Open the directory
    my @files = grep {/\.pep$/ and -f "$library/$_"} readdir (DIR);   # Keep the existing *.pep files
    close (DIR);                                                      # Close the directory
    
    # delete an hyp. previous same. file
    if (-f $pepfile) {
        #system ("rm -f $pepfile");
        unlink($pepfile);
    }
    
    #concatenate all the file from the library
    foreach my $file (@files) {
        system ("cat $library/$file >> $pepfile"); # Use the cat command to concatenate file in one 
    }
    return $pepfile;
    exit 0;
}

sub CreateCodonTableWithGeneticId {  # this function create a file
                                     # Having a codon table.
                                     # ATT F....
                                     # ATG M...
                                     # Comment will begin with "!"
   
    # declaration 
    ###############
    my $geneid         = shift;   # the genetic id for codon usage
    my $codontablefile = shift;   # the name of the file where the codon table will be put
    my $comment        = shift;   # Comment in the header of file
    my $codontable     = Bio::Tools::CodonTable->new( -id => $geneid );
    ###############

    # open the future file containing the codon table
    open (CODONTABLE, ">$codontablefile") or die "Impossible to open Codon Table file : $codontablefile\n"; 
    print CODONTABLE "! Codon table for genetic code $geneid\n";     # print a short header for description 

    # Process declaration
    #####################
    my @letter = qw (A T C G);
    my $i      = 0;
    my $j      = 0;
    my $z      = 0;
    ######################
   
    while ($i < scalar(@letter)) {
        $j = 0;
        while ($j < scalar(@letter)) {
            $z = 0;
            while ($z < scalar(@letter)) {
                my $codon = $letter[$i].$letter[$j].$letter[$z];
                my $aa    = $codontable->translate($codon);
                print CODONTABLE "$codon $aa\n";
                $z++;
            }
            $j++;
        }
        $i++;
    }

    close (CODONTABLE) or die "Impossible to close Codon Table file : $codontablefile\n";

}  

sub FindExonsInHypProtArray {  # the main is to find exons
                               # by making a local alignement

    ########################
    my $pirmaster = shift;        # the masterfile object
    my $flag      = shift || "";  # a flag, assigned to each pepfile
    my $count     = 1;              
    ########################
    
    foreach my $hypprot (@$HYPPROTS) {        
        # HYPOTHETICAL PROTEIN FEATURE
        my $name   = $hypprot->name;
        #print "protein $name $count\n";
        my $start  = $hypprot->start;                                          
        my $end    = $hypprot->end;
        my $contig =  $pirmaster->GetContigByName ($hypprot->contigname);    
        my $seq    = $contig->sequence;
        $seq       =~ s/\!//g;
        my $strand = $hypprot->strand;


        # PROTEIN AND GENE SEQUENCE
        my $genseq  = substr ($seq ,$start-1, $end - $start + 1) if $strand == 1;
        $genseq     = substr ($seq, $end-1, $start - $end + 1) if $strand == -1;
        $genseq     = ">$count\n" . $genseq;
        my $protein = $hypprot->protein;


        # CHECKING
        if (($genseq eq "") or (!defined ($genseq))) {
            $count++;
            next HYPPROT;
        }   

        if (($protein eq "") or (!defined ($protein))) {
            $count++;
            next HYPPROT;
        } 

        # WRITE PROTEIN AND GENE IN FASTA FILES
        my $fileprot = "$TMPDIR/protforgenewise$count"."_"."$flag";
        my $filegene = "$TMPDIR/geneforgenewise$count"."_"."$flag";
        my $genewiseout = "$TMPDIR/genewise$count"."_"."$flag";


        # check if it exists
        if (-f $fileprot) { # this file already exists
            #system "rm $fileprot" or die "Impossible to delete $fileprot\n";
            unlink($fileprot) or die "Impossible to delete $fileprot\n";
        }

        if (-f $filegene) { # this file already exists
            #system "rm $filegene" or die "Impossible to delete $filegene\n";
            unlink($filegene) or die "Impossible to delete $filegene\n";
        }

        if (-f $genewiseout) { # this file already exists
            #system "rm $genewiseout" or die "Impossible to delete $genewiseout\n";
            unlink($genewiseout) or die "Impossible to delete $genewiseout\n";
        }

        #  open all the prot files and so on
        open (FILEPROT, ">$fileprot") or die "Impossible to open $fileprot\n";
        open (FILEGENE, ">$filegene") or die "Impossible to open $filegene\n";

         # write into the files
        print FILEPROT $protein, "\n" or die "Impossible to paste protein into $fileprot\n";
        print FILEGENE $genseq,  "\n" or die "Impossible to paste gene sequence into $filegene\n";

        # close the files
        close (FILEPROT) or die "Impossible to close $fileprot\n";
        close (FILEGENE) or die "Impossible to close $filegene\n";


        # RUN GENE WISE ON EACH GENE 
        #---create a codon table---#
        my $condontablle = $TMPDIR . "/codons". $GENCODE . "_"."$flag".".table";
        &CreateCodonTableWithGeneticId ($GENCODE, $condontablle);

        #----create options for genewise
        my $genewiseoptions = " -pretty -para -genes  -splice flat -intron tied -matrix $MATRIX -codon $condontablle ";
        $genewiseoptions   .= " -trev" if $strand == -1;
        
        # GENEWISE COMMAND
        my $cmd = "$GENEWISEPATH $fileprot $filegene $genewiseoptions > $genewiseout 2> $TMPDIR/genewisewarning";  
        #  Run the alignement program
        system $cmd;

        # PARSE RESULTS FROM GENEWISE AND GET THE EXONS
        my @exons = &ParseInformationFromGeneWise ($genewiseout, $strand);

        if (scalar @exons <= 1){
            $count++;
            next;
        } 

        # ANNOTATE EXONS
        my $hypprotexonarray = $hypprot->exons;
        my $hypprotintronarray = $hypprot->introns;

        
        

        foreach my $e (    @exons) {
            # On this step exon are sorted,
            # The start correspond to the lowest value between start and stop
            # The intron calculation is easier   
            
                 

            my $exonstart;
            my $exonend;
    
            if ($strand == 1) { 
                $exonstart  = $start + $e->{"start"} -1;
                $exonend    = $start + $e->{"end"} + 2;
            }
            else {
                $exonstart  = $start - $e->{"start"}+1;
                $exonend    = $start - $e->{"end"} + 1;
            }
    
            my $hypprotexon = new PirObject::Exon (
                                                     start  => $exonstart,
                                                     end    => $exonend,
                                                     strand => $strand,
                                                  );
            push (@$hypprotexonarray, $hypprotexon); 
        }
     
        
        # buiding introns-----------------------------------------------------
   #     print "start $start end $end\n";
        

        my $lastposition = $start+1;
        if ($strand == -1) {
            $lastposition = $start;
        }
        else {
            $lastposition = $start+1
        }

        my $firsttime = 1;  
        foreach my $exon (@$hypprotexonarray) {
            # just jump the first exon
            if ($firsttime == 1) {
                $lastposition = $exon->end;
                $firsttime = 0;
                next;
            }
            if ($strand == 1) {
                if (abs($lastposition - $exon->start) > 0) {
                    my $hypprotintron = new PirObject::Intron (
                                               start  => $lastposition+1,
                                               end    => $exon->start - 1,
                                               strand => $strand,
                                              );
                    push (@$hypprotintronarray, $hypprotintron);
                   # print "On a un intron \n";				  
 
                }
                $lastposition = $exon->end;

            }
           else {
               if (abs($lastposition - $exon->start) > 0) {
                   my $hypprotintron = new PirObject::Intron (
                                               start  => $lastposition-1,
                                               end    => $exon->start + 1,
                                               strand => $strand,
                                              );
                    push (@$hypprotintronarray, $hypprotintron);  

                }
                $lastposition = $exon->end;
 
            }
    
            #print "Exon ", $exon->start, " ", $exon->end, "\n";
        }




       $count ++;
    }  #  End of each prot        
}

sub ParseInformationFromGeneWise {   # parse the genewise output
                                     # and get the exons
                                     # reorganise too the exons

    my $genewiseoutput = shift || return;
    my $strand         = shift || return;
    my $minintronsize  = $MININTRONSIZE;
    my $minexonsize    = $MINEXONSIZE;

    my @returnexons;
    my @organisedexons;
     
    #---Parsing genewise output
    open (GENEWISEOUTPUT, $genewiseoutput) or die "Can not open $genewiseoutput\n";
     
    #--Look for lines having Exons 1 823 (exemple)
    while (my $line = <GENEWISEOUTPUT>) {
        if ($line =~ /\s*Exon\s+(\d+)\s+(\d+)/) {
            my $findexon = {};
            if ($strand ==  1) {
                $findexon->{"start"} = $1;
                $findexon->{"end"}   = $2;
            }
            else {
                $findexon->{"end"}   = $1;
                $findexon->{"start"} = $2;
            }
            push (@returnexons, $findexon);
        }
    }

    #-----SORT THE EXONS---------------
    @returnexons = sort {
        $a->{"start"} <=> $b->{"start"};
    } @returnexons;
 

    #-----ORGANISE EXONS---------------
    my $currentexon;  # a reference to a hash 
    foreach my $exon (@returnexons) {
        # ---- Looking for the minimum exon size
        if (!defined ($currentexon)) { 
            $currentexon->{"start"} = $exon->{"start"};
            $currentexon->{"end"} = $exon->{"end"};
            next;
        }     
        if ($exon->{"end"} - $exon->{"start"} <=  $minexonsize) {
            next;
        }
        if ($exon->{"start"} - $currentexon->{"end"} <=  $minintronsize) {
            $currentexon->{"end"} = $exon->{"end"};
            next;
        }

        push (@organisedexons, $currentexon);
        undef $currentexon;
        $currentexon->{"start"} = $exon->{"start"};
        $currentexon->{"end"} = $exon->{"end"};
    }
    push (@organisedexons, $currentexon);
     
    #--return exons (an array that reference many hash array)
    return @organisedexons;
} 

sub AnnotateEmptyOrfs {    # This function takes the empty array of ORF and annotate it as ORFs
                           # It means ORF having non corresponding gene in a pepfile
  
    my $pirmaster = shift; # get the masterfile object

    EMPTYORF : foreach my $emptyorf (@$EMPTYORFS) {             # process each non corresponding orf
     
        ####  Get informations  about empty ORF
        my $contigname        = $emptyorf->contigname;          # Get the contigname corresponding to the empty ORFs
        my $strand            = $emptyorf->strand;

        my $arrow;
        if ($strand == 1) {
            $arrow = '==>';
        }
        else {
            $arrow = '<==';
        }
        
        my $start;
        my $end;
 
        my $overlappingcutoff = $OVERLAPPINGCUTOFF/100;         # authorized overlapping. It's a percent so it has to be between 0 and 1
        my $minimumlengthorf  = $MINLENEMPTYORF;                # minimum Orf size, below this size, the ORF is no more kept
        my $contig            = $pirmaster->GetContigByName($contigname) or die "Can't get contig by name in AnnotateEmptyOrfs\n";
         
 
        my $annotations       = $contig->get_annotations;       # Get the annotations, for the same contig belonging to empty ORF
 
        # Get the new start codon
        my $seq               = $contig->sequence;              # Get the sequence
        $seq                  =~ s/!//g;                        # Remove ! from the sequence
        my $newstart          = &FindNewStart ($seq, $emptyorf->start, $emptyorf->end, $strand);
        $emptyorf->set_start ($newstart);  

        # Get the start, as the most little position
        # For a further treatment
        if ($emptyorf->start < $emptyorf->end) {
            $start = $emptyorf->start;
            $end   = $emptyorf->end;
        }
        else {
            $start = $emptyorf->end;
            $end   = $emptyorf->start;
        }

        # SIZE CHECKING
        next EMPTYORF if (int(abs($end - $start)/3) < $minimumlengthorf);  #  Size Verification 

        # OTHER CHECKING, SUCH AS OVERLAPPING..........
        if ( $CHECKORFS) {         # if option CHECKORF is activate
            ANNOT : foreach my $annotation (@$annotations) {
     
                ## Verifiaction : 
                ## Doesn't take the annotation if it's something else than a comment
                next ANNOT if ((not defined($annotation->type)) or ($annotation->type ne 'G'));       

                ## Get information from current annotation
                my $annotstart;
                my $annotend; 
                if ( $annotation->startpos <  $annotation->endpos) {
                    $annotstart = $annotation->startpos;
                    $annotend   = $annotation->endpos;
                }
                else {
                    $annotstart = $annotation->endpos;
                    $annotend   = $annotation->startpos;
                }
   
                # OVERLAPPING CHECK
                # overlapping is allowed below a given cutoff 
                # this cutoff is inside the variable $OVERLAPPINGCUTOFF
     
                #### Case were it seems to work
                next ANNOT if ((($start >= $annotend) or ($end <= $annotstart)));

                #### Case were it doesn't work

                ######## FOUR CASES

                ####  1) ORF is inside the gene and longer than the gene
                ####         |___________________|      ORF
                ####            |______________|        GENE

                if ($start <= $annotstart and $end >= $annotend) {
                    next EMPTYORF;    
                }

                ####  2) ORF is inside the gene and smaller than the gene => that is ok
                ####            |_____________|        ORF
                ####         |___________________|     GENE

                if ($start >= $annotstart and $end >= $annotend) {
                    my $overlapping = 0;                           #  Overlapping calculation
                    $overlapping   += abs($annotstart-$end);
                    $overlapping    = $overlapping / abs ($end - $start);
   
                    if ($overlapping > $overlappingcutoff) {
                        next EMPTYORF;
                    }   
                }  

                ####  4) ORF is overlapping the gene
                ####        |__________|              ORF
                ####              |________________|  GENE

                if ($start <= $annotstart and $end <= $annotend) {
                    my $overlapping=0;                        #  Overlapping calculation
                    $overlapping += abs($start-$annotend);
                    $overlapping  = $overlapping / abs ($end - $start);
    
                    if ($overlapping > $overlappingcutoff) {
                        next EMPTYORF;
                    }
                }
           }  # End of traversing each annotation
      } # end of if ORFCHECK


      ### Creating an annotation object for storing in the masterfile
      my $orfsize     = int((abs($start-$end))/3);
      my $GenenameORF = "orf". $orfsize;

      #-------------------------------------------------------------------------------------
      #  Treatment to add a number after the genename ______________________________________
      #-------------------------------------------------------------------------------------
      my $numberofannotforthisorf = $ANNOTSEEN->{$GenenameORF} || 0;
      $numberofannotforthisorf ++;
      my $startline = "";
      my $endline = "";
      if ($numberofannotforthisorf >= 2) {
          $startline   = ";     G-$GenenameORF"."_$numberofannotforthisorf"." $arrow start ";
          $startline  .= ";; MFFEAT=$TAGNAME, empty ORF" if $ADDCOMMENTS;     # add comments if option is activated
          $endline     = ";     G-$GenenameORF"."_$numberofannotforthisorf"." $arrow end ";
          $endline    .= ";; MFFEAT=$TAGNAME empty ORF" if $ADDCOMMENTS;       # add comments if option is activated
      }
      else {
           $startline  = ";     G-$GenenameORF $arrow start ";
           $startline .= ";; MFFEAT=$TAGNAME empty ORF" if $ADDCOMMENTS;     # add comments if option is activated
           $endline    = ";     G-$GenenameORF $arrow end ";
           $endline   .= ";; MFFEAT=$TAGNAME empty ORF" if $ADDCOMMENTS;
      }
      #________________________________________________________________________________
   
      my $orfannot = new PirObject::AnnotPair(
                                               type      => "G",  
                                               genename  => $GenenameORF,
                                               startpos  => $emptyorf->start,
                                               endpos    => $emptyorf->end,
                                               direction => $arrow,
                                               startline => $startline,
                                               endline   => $endline,
                                             );
    
      # Put into the table containing all of the masterfile annotations
      # So before, being put in the masterfile (means in a first time in the annotation table), there are some verification
      # print "Il a ajoute cette orf vide : $GenenameORF\n";
      &AddAnnotToPirMaster($pirmaster,$contigname,$orfannot);
     
      } # END OF FOR EACH EMPTY ORFS

} # End function AnnotateEmptyOrfs

sub InitializeANNOTSEEN {   # this function initilaise the hash array
                            # After the masterfile has been opened
                            # This one contain how many annotation per genname
    my $pirmaster = shift;
    my $contigs   = $pirmaster->get_contigs;
    foreach my $contig (@$contigs) {
        my $annotations = $contig->get_annotations;
        foreach my $annotation (@$annotations) {
            if ($annotation->type eq "G") {
                 $ANNOTSEEN->{$annotation->genename} += 1; 
            } 
        } # next annotation
    } # next contig 
}

sub AnnotateMfFromHYPPROTSArray { # This function annotates the masterfile from the blast results

    my $pirmaster = shift;

    foreach my $hyprot (@$HYPPROTS) {
        my $name = $hyprot->name;
        # go the next protein if name is not defined
        next if (not (defined ($name)) or ($name eq ""));
        my $contigname        = $hyprot->contigname;
        my $start             = $hyprot->start;
        my $end               = $hyprot->end;
  
        my $arrow;
        if ($hyprot->strand == -1) {
            $arrow = '<==';
        }
        else {
            $arrow = '==>';
        }

        my $tag               = $hyprot->remark;

        my $numberofthisannot = $ANNOTSEEN->{$name} || 0;  # get the number for each annot  
        $numberofthisannot   += 1;                         # increase by one, because it's current
        my $linename          = $name;                     # the name gene in start and endline
        # If there is more than one, add this at the end
        $linename            .= "_$numberofthisannot" if ($numberofthisannot >= 2);

        my $startline         = ";     G-$linename $arrow start "; 
        $startline           .= ";; MFFEAT=$TAGNAME ;; $tag" if $ADDCOMMENTS; # add comments if option is checked
        my $endline           = ";     G-$linename $arrow end ";
        $endline             .= ";; MFFEAT=$TAGNAME ;;$tag" if $ADDCOMMENTS;  # add comments if option is checked

        my $protannot = new PirObject::AnnotPair (
                                                   type      => "G", 
                                                   genename  => "$name",
                                                   startpos  => $start,
                                                   endpos    => $end,
                                                   direction => $arrow,
                                                   startline => $startline,
                                                   endline   => $endline,
                                                 );
        my $res               = &AddAnnotToPirMaster($pirmaster,$contigname,$protannot);
        my $exons             =  $hyprot->exons;

        # go out of the function if the protein has not been added
        if (!defined ($res) or $res == 0) {
            $ANNOT_STATS->{'Rediscovered'}->{$protannot->genename}->{'E'} += scalar (@$exons) if (scalar (@$exons) > 0);
            next;
        } 
 
        if ($name =~ /^orf/) {   # if it's an ORF, then it goes to through, because an ORF must not have  
            next;
        }
        if (scalar (@$exons) <= 1) {  # if there is only one exon, and if option is not checked, go to the next prot
            next;
        }     

        # Annotating exons
        my $number = 1;
        foreach my $exon (@$exons) {
            my $exonstart  = $exon->start;
            my $exonend    = $exon->end;
            my $exonstrand = $exon->strand;

            my $startline  = ";     G-$linename-E$number $arrow start ";
            $startline    .= ";; MFFEAT=$TAGNAME" if $ADDCOMMENTS;       # option checked, add comments
            my $endline    = ";     G-$linename-E$number $arrow end ";
            $endline      .= ";; MFFEAT=$TAGNAME" if $ADDCOMMENTS;       # option checked, add comments

            my $exonannot = new PirObject::AnnotPair (
                                                       type      => "E",
                                                       genename  => "$name",
                                                       startpos  => $exonstart,
                                                       endpos    => $exonend,
                                                       direction => $arrow,
                                                       startline => $startline,
                                                       endline   => $endline,
                                                     );

            $number++;
            my $res       = &AddAnnotToPirMaster($pirmaster,$contigname,$exonannot);
        }
        

        my $introns = $hyprot->introns;
        # Annotating introns
        $number = 1;
        foreach my $intron (@$introns) {
            my $intronstart  = $intron->start;
            my $intronend    = $intron->end;
            my $intronstrand = $intron->strand;

            my $startline  = ";     G-$linename-I$number $arrow start ";
            $startline    .= ";; MFFEAT=$TAGNAME" if $ADDCOMMENTS;       # option checked, add comments
            my $endline    = ";     G-$linename-I$number $arrow end ";
            $endline      .= ";; MFFEAT=$TAGNAME" if $ADDCOMMENTS;       # option checked, add comments

            my $intronannot = new PirObject::AnnotPair (
                                                       type      => "I",
                                                       genename  => "$name",
                                                       startpos  => $intronstart,
                                                       endpos    => $intronend,
                                                       direction => $arrow,
                                                       startline => $startline,
                                                       endline   => $endline,
                                                     );

            $number++;
            my $res       = &AddAnnotToPirMaster($pirmaster,$contigname,$intronannot);
        }
    }
}

sub FindNewStart {  # This function is assuming to return the new start codon,  

    # arg1, sequence
    # arg2, start,
    # arg3, end
    # arg4, strand

    my $possiblestarts = ['ATG', 'AUG'];
    my $seq            = shift;          # the sequence where to look
    my $oldstartpos    = shift;          # Get the old start position
    my $newstartpos    = $oldstartpos;             
    my $currentpos     = $oldstartpos;
    my $end            = shift;          # the end of the gene
    my $strand         = shift;          # the strand of the gene
    my $found          = 0;
  
    #### Two cases
    if ($strand == 1) { # Right strand
        while (not ($found) and ($currentpos < $end)) {
            my $codon = uc (substr($seq, $currentpos-1, 3));
            $codon =~ tr/ATUGCatugc/ATTGCATTGC/;
            if (ValueIsIn($possiblestarts, $codon) == 1) {
                $found       = 1;
                $newstartpos = $currentpos;
                next;
            }
            else {
                $currentpos += 1;
                next;
            }
        }
    }
    else { #Complementary strand
        while (not ($found) and ($currentpos-3 > $end)) {
            my $codon = uc (substr($seq, $currentpos-3-1, 3));
            $codon    =~ tr/ATUGCatugc/TAACGTAACG/;
            $codon    = reverse ($codon);#Reverse and complementary
            if (ValueIsIn($possiblestarts, $codon) == 1) {
                $found       = 1;
                $newstartpos = $currentpos-1;
                next;
            }
            else {
                $currentpos -= 1;
                next;
            }
        }
    }
    return $newstartpos;
}

sub OrganiseHYPPROTSArray { # This function is supposing to find the real start and recreating exon if necessary

    my $pirmaster      = shift;
    my $possiblestarts = ['ATG', 'AUG'];

    foreach my $hyprot (@$HYPPROTS) {
        my $name = $hyprot->name;
    }

    #################   The first thing is to look for the new start #########################
    foreach my $hypprot (@$HYPPROTS) {
        my $oldstartpos = $hypprot->start; # Get the old start position
        my $newstartpos = $hypprot->start;
        my $currentpos  = $hypprot->start; 
        my $found       = 0;
        my $contig      = $pirmaster->GetContigByName ($hypprot->contigname); # Get the contig
        my $seq         = $contig->sequence; # Get sequence
        $seq            =~ s/!//g;
        my $end         = $hypprot->end;

        #### Two cases
        if ($hypprot->strand == 1) { # Right strand
            while (not ($found) and ($currentpos < $hypprot->end)) {
                my $codon = uc (substr($seq, $currentpos-1, 3));
                $codon =~ tr/ATUGCatugc/ATTGCATTGC/;

                if (ValueIsIn($possiblestarts, $codon) == 1) {
                    $found       = 1;
                    $newstartpos = $currentpos;
                    next;
                }
                else {
                    $currentpos += 1;
                    next;
                }
            }
        }
        else { #Complementary strand
            while (not ($found) and ($currentpos-3 > $hypprot->end)) {
                my $codon = uc (substr($seq, $currentpos-3-1, 3));
                $codon =~ tr/ATUGCatugc/TAACGTAACG/;
                $codon = reverse ($codon); # Reverse and complementary

                if (ValueIsIn($possiblestarts, $codon) == 1) {
                    $found       = 1;
                    $newstartpos = $currentpos-1;
                    next;
                }
                else {
                    $currentpos -= 1;
                    next;
                }
            }
        }

        $hypprot->set_start ($newstartpos);  # set the new start to the protein
    }
} # End function

sub ValueIsIn {  # check if a value is in an array

    my $array = shift;
    my $value = shift;
    
    foreach my $result (@$array) {
        if ($value eq $result) {
            return 1;
        }
    }
    
    return -1;
}

sub RunFlip { # This function run flip with the masterfile
              # Flip is a program generating ORF

    my $flag = shift || "";    # something to recognize, what is the pepfile treated
    my $cwd  = cwd();          # Let's get the current working directory name
 
    # We need to change to the temporary directory to run flip - just so the flip files are written here.
    chdir ("$TMPDIR");

    # Just check if Flip outfiles exist here already, if so get rid of them

    if (-e "prot.lst") {
      unlink("prot.lst");
    }
    if (-e "prot.src") {
      unlink("prot.src");
    }
    if (-e "compl") {
      unlink("compl");
    }
    if (-e "uncompl") {
      unlink("uncompl");
    }

    # Checking the see if the masterfile path is aboslute or relative
    my $tmpMasterfile;
    if ($MASTERFILE =~ m!^/!) {
        # absolute
        $tmpMasterfile = $MASTERFILE;
    }
    else {
        # relative
        $tmpMasterfile = "$cwd/$MASTERFILE";
    }
    my $cmdflip = "$FLIPPATH -s ATG -m -l $MINLENGTHORF -g $GENCODE $tmpMasterfile > $TMPDIR/flip_$flag.output";

    # -s start codon
    # -m With this switch, flip will translate the first codon of a protein by 'M' if the codon is a start codon
    # -l minimum length ORF
    # -g genetic codes
   
    my $resultat = system ("$cmdflip");
    
    print "$cmdflip\n" if $DEBUG;

    # Changing back to the original directory
    chdir($cwd);
} 

sub BlastFlipVSGene {    # it runs blast with the flip results against file containing genes 

    my $flag         = shift || "";    # something to recognize, what is the pepfile treated
    $BLASTOUTPUT     = $TMPDIR . "/blatstoutput_$flag";
    my $file         = $PEPFILE;                                # undef should never happen in fact.
    my $escaped_file = $file;
    $escaped_file    =~ s#'#'\\'#g;         
    my $command      = "$FORMATDBPATH -p 'T' -t banque -i $escaped_file -n $TMPDIR/mf_$flag -l $TMPDIR/fdb_1.log";
    print "$command\n" if $DEBUG;
    my $resformatdb  = system($command);

    #RUN FOR BLAST : run blast with the db created and the flip results        
    my $cmdblast     = "$BLASTPATH -p blastp -d $TMPDIR/mf_$flag -i $TMPDIR/prot.lst -D $GENCODE -o $BLASTOUTPUT 2> $TMPDIR/blasterr_1.txt";
    print "$cmdblast\n" if $DEBUG;
    my $resblast = system ($cmdblast);
}

sub ParseInformationFromBlastResult {

    my $pirmaster   = shift;
    my $tag         = shift || "aVwXyZ";
    
    # This loop goes through the different fasta input files that
    # are currently defined in MfAnnotConfig.pir
   
    my $type        = 'PROT';
    my $file        = $PEPFILE;
    my $blastoutput = $BLASTOUTPUT;
     
    if (! -r $blastoutput) { # it's supposed to be here at this point.
        die "Error: can't find $type report from blastall ?!?\n";
    }
    my $searchio = new Bio::SearchIO (
                                       -format => 'blast',
                                       -file   => $blastoutput,
                                     );
    while (my $result = $searchio->next_result() ) {
        &FillFLIPBLASTPROTArrayFromBlastResult($pirmaster,$type,$result,$tag);
    }
}

sub FillFLIPBLASTPROTArrayFromBlastResult {
    my $pirmaster = shift; #    Pirmaster Object
    my $type      = shift; #     'DNA' or 'PROT'
    my $result    = shift; #     an object implementing Bio::SearchIO::Result::ResultI
    my $tag       = shift || "bVwXyZ";
    
    if (!$result) {return;}

    my $contigname = $result->query_name()        || "Unknown ID";
    $contigname =~ s/\;//g;                         # Delete false caracter            
    my $rdesc      = $result->query_description() || "Unknown Query Description";
    my $dbname     = $result->database_name()     || "Unknown DB name";
    my @hits       = $result->hits();               # Bio::Search::Hit::HitI        
    my $numhits    = scalar(@hits);                 # normally, only one! 
    return if $numhits < 1;

    # We have an hypothetical protein and we want to know if it'real
    my ($strand, $start, $end) = ($rdesc =~ /(orig|compl).\s+(\d+)\s+to\s+(\d+)\s+;\s+[\w\.\!]+/);
    my $arrow;
     
    if ($strand eq 'orig') {
        $arrow =  '==>';
    }
    else {
        $arrow =  '<==';
    }
    
    $strand                    = ($strand eq 'orig' ? 1 : -1);
    
    my $hit                    = $hits[0];    

    ###--------------------QUIT THE FUNCTION IF EVALUE IS TOO  WEAK-----------------------------#
    if ($hit->significance > $BLASTEVALUECUTOFF) { # If the e-value is not enough for these ORF you can
                                                   # It creates an Empty ORF 
        my $newemptyorf = new PirObject::EmptyOrf (
                                                    start  => $start,
                                                    end    => $end,
                                                    strand => $strand,
                                                    score  => $hit->significance,
                                                    contigname => $contigname,
                                                  );
        push (@$EMPTYORFS, $newemptyorf);          #  Put into the array, to be processed after   
        return;                                    #  Exit the function, because there is no significant ORF 
    }
    ###-----------------------------------------------------------------------------------------#
    
    ####  Now we have the start, we have the end, the strand
    ####  And we would like to know if more than one hit is allowed
    
    my @overlapping;
    
    HIT : foreach my $hit (@hits) {
              my $desc         = $hit->description();  # Get the description of the query sequence    
              my ($hypprotein) = ($desc =~ /\s*([\S]*)\s*;/); 
              next HIT if (not (defined ($hypprotein)) or $hypprotein eq "");
              my $score        = $hit->score();        # Get the blast score
              my $evalue       = $hit->significance(); # Get the e-value
              my @hsps         = $hit->hsps;           # High Scoring pairs : Bio::Search::HSP::BlastHSP
        
              return if ($evalue > $BLASTEVALUECUTOFF);
    
              my $prot = &TakeProteinFromPepfile ($desc, $PEPFILE);   # Take the protein corresponding to the hit
        
              if (scalar(@hsps) == 0) {
                  return; # An ORF that has a good evalue but no HSP => impossible but ...
              }
    
              #------- Calculate a sort of frame to see what's the region covered by this ORF
              #  Story : You can have, for some case, more than one protein per gen.
              #  It's a sort of fusion protein.
              #  Each of both have a functional part
    
              #-----------------------------------------------------------------------------#
              # To make distinction between a protein fusion and a protein annotated as twice
              # We have to check the High Scoring Pair frame. If there is no overllapping between 
              # HSP frames, it means you have many proteins on the same frame
              # If there is, it's probably because many similar proteins corresponds to the same gene
    
              my $frame           = {};
              my $framestart      = $hsps[0]->start;
              my $frameend        = $hsps[0]->end;
    
              #  We don't need to check for strand because HSP are sorted as if there were on the right strand
              foreach my $hsp (@hsps) {    
                  $framestart     = $hsp->start if ($hsp->start < $framestart);
                  $frameend       = $hsp->end   if ($hsp->end   > $frameend);
              }

              $frame -> {"start"} = $framestart;
              $frame -> {"end"}   = $frameend;
    
              my $isoverlapping = 0; #       Indiquate if wheter or not, accept the hit as annotation of the ORF 
               
              CURRENTFRAME : foreach my $currentframe (@overlapping) {
              ##################   FOR EACH STRAND THERE IS 4 CASES WHEN FRAME are OVerlapping
        
              # 1)     |----------------|             first frame
              #               |-----------------|     second frame
        
              # 2)            |----------------|      first frame
              #        |-----------------|            second frame
        
              # 2)          |---------|               first frame
              #        |-----------------|            second frame
        
              # 4)    |-----------------|             first frame
              #         |---------|                   second frame
                                
              #       Case were we are on the right strand
        $isoverlapping = 1 if (($currentframe->{"start"} <=  $frame -> {"start"}) and ($currentframe->{"end"} >=  $frame -> {"start"}));
        $isoverlapping = 1 if (($frame -> {"start"} <=  $currentframe->{"start"}) and ($frame -> {"end"} >=  $currentframe->{"start"}));
        $isoverlapping = 1 if (($frame -> {"start"} <=  $currentframe->{"start"}) and ($currentframe -> {"end"} <=  $frame->{"end"})); 
        $isoverlapping = 1 if (($currentframe -> {"start"} <=  $frame->{"start"}) and ($frame -> {"end"} <=  $currentframe->{"end"}));  
        
                                 last CURRENTFRAME if $isoverlapping == 1; # Go out of the loop if there is a overlapping frame  
                             }
    
              next HIT if ($isoverlapping == 1); #  If there is an overlapping, the HIT isn't good for annotation
              push (@overlapping, $frame) if ($isoverlapping == 0);

              #----    Creating a new ORF object    ---
              my $neworf = new PirObject::Orf (
                                                start   => $start,
                                                end     => $end,
                                                strand  => $strand,
                                                score   => $evalue,
                                                protein => $prot, # assign the protein to the ORF 
                                                hsps    => []
                                              );
              my $refhsparray = $neworf->hsps;           #    An array reference,                          
              foreach my $hsp (@hsps) {
                  my $newhsp = new PirObject::Hsp (
                                                    start  => $hsp->start,
                                                    end    => $hsp->end,
                                                    strand => $hsp->strand);
                  push (@$refhsparray, $newhsp);
              }
                                
              my $newflipblastprot = GetFlipBlastProtByNAmeAndContigName ($hypprotein, $contigname);
              # Two case
              if (defined ($newflipblastprot)) {    #    Wether the prot is already defined
                  my $reforfarray = $newflipblastprot->orfs;
                  push (@$reforfarray, $neworf);    #    Annd we just add a new orf
              }
              else {
                  my $newflipblastprot = new PirObject::FlipBlastProt (
                                                                        name       => $hypprotein, # First we create the flipblast prot
                                                                        contigname => $contigname,
                                                                        orfs       => []
                                                                      );
                  my $reforfarray = $newflipblastprot->orfs;
                  push (@$reforfarray, $neworf);    #    Annd we just add a new orf
                  push (@$FLIPBLASTPROTS, $newflipblastprot);
              }    
              return if (! $MULTIORFS);                 #       Exit the function after the first hit if multi ORFS not allowed
          }
}

sub TakeProteinFromPepfile {  # this function takes a protein from the blast result with a descritpion line
                              # A kind of pareser of fasta file

    my $description = shift;
    my $pepfile     = shift;
    my $protein     = "";
   
    die "Impossible to read $pepfile" if (not (-f $PEPFILE));
   
    open (PEPFILE, "$PEPFILE") or die "Could not open $PEPFILE";
   
    # Parse the file, containing pep sequences
    my $parsebegin = 0;  
 
    while (my $line = <PEPFILE>) { #Treat each line
        chomp $line;
        next if ($line =~ /^\s*[;]/);  # don't parse line if it beginns with ; 
        if ($line =~ /$description/ and $line =~ /^\s*\>/ and $parsebegin == 0) {
            $protein .=  $line;
            $protein .= "\n";
            $parsebegin =1;  
            next;
        }

        if ($parsebegin ==1  and $line =~ /^\s*\>/) { # finish if meet an other protein
            last;
        }
        if ($parsebegin ==1) {    # Get the line.
            $protein .=  $line;
            $protein .= "\n";
        }    
    }
    return $protein;
}

sub FillHYPPROTSArrayWithFLIPBLASTPROTSArray {    #    This function fill the HYPPROTS array (array of hypothetical proteins with
                        #    FLIPBLASTPROTS array (array of ORF and hsp)

    #    This is mainly the algorithm given by Franz
    foreach my $flipblastprot (@$FLIPBLASTPROTS) {        #    For each fliup blast protein
        my $name       = $flipblastprot->name;
        my $contigname = $flipblastprot->contigname;

        my $orfs       = $flipblastprot->orfs;
        my $numberorfs = scalar (@$orfs);
        
        
        if ($numberorfs < 1) { 
            next; # impossible but ..........
        }
        
        else {  # if there is more than one orf
            my $neworfs = [];
    
            #---------------SORT THE ORF-------------------------#
            @$orfs = sort {        #    The ORFs are classified and sorted by starnd and start, stop positions
                         my $stranda = $a->strand;
                         my $strandb = $b->strand;
                         if ($stranda != $strandb) {
                             $a->strand <=> $b->strand;
                         }
                         elsif ($stranda == 1) {
                             $a->start  <=> $b->start;
                         }
                         else {
                             $a->end    <=> $b->end;
                         }    
                         
            } @$orfs;    
         
            my $newhypprot = undef;
            
             foreach my $orf(@$orfs) {
                #    Now the thing is to create a new hyp prot if the conditions are not required
                #    First : if the $currentprot is not defined
                #------------    case     1 : first ORF
                if (not defined($newhypprot)) {
                #    Here we create a new protein
                $newhypprot = new PirObject::HypProt (
                                                       name       => $name,
                                                       contigname => $contigname,
                                                       start      => $orf->start,
                                                       end        => $orf->end,
                                                       strand     => $orf->strand,
                                                       numorfs    => 1,
                                                       remark     => "",
                                                       protein    => $orf->protein,
                                                       score      => $orf->score, 
                                                       exons      => [],
                                                       introns    => [],
                                                     );
                                     
                    next; 
                }
                
                #------------    case     2 : not the same strand
                if ($newhypprot->strand !=  $orf->strand) {
                    push (@$HYPPROTS,  $newhypprot);
                    #+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                    $newhypprot = new PirObject::HypProt (
                                                           name       => $name,
                                                           contigname => $contigname,
                                                           start      => $orf->start,
                                                           end        => $orf->end,
                                                           strand     => $orf->strand,
                                                           numorfs    => 1,
                                                           remark     => "",
                                                           protein    => $orf->protein,
                                                           score      => $orf->score,  
                                                           exons      => [],
                                                           introns    => [],
                                                         );                 
                                     
                    next;
                }
                
                #------------    case     3-4 : Check space between 2 ORFs, including overlapping
                if ($orf->strand == 1) { # Two case : right strand or opposite strand
                    if (($newhypprot->end > $orf->start) or (abs ($orf->start - $newhypprot->end) < $MAXLENGTHFORGROUPINGORF)) {

                        my $newstart;
                        my $newend; 

                        if ($orf->start < $newhypprot->start) {
                            $newstart = $orf->start;
                        }
                        else {
                            $newstart = $newhypprot->start;
                        }

                        if ($orf->end   > $newhypprot->end) {
                            $newend   = $orf->end;
                        }
                        else {
                            $newend   = $newhypprot->end;
                        }
 
                        $newhypprot->set_start ($newstart);
                        $newhypprot->set_end ($newend);
                        
                        # Check which protein is the best
                        if ($orf->score < $newhypprot->score) {
                            $newhypprot->set_protein ($orf->protein);
                            $newhypprot->set_score ($orf->score);
                        }

                        # increase from 1, the number of orf, if we concatenate
                        my $numorfs = $newhypprot->numorfs;
                        $numorfs++;
                        $newhypprot->set_numorfs($numorfs);
                        next;
                    }
                    else {
                                            #    ++    
                        push (@$HYPPROTS,  $newhypprot);            #    ++
                        #+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                        $newhypprot = new PirObject::HypProt (
                                                               name       => $name,
                                                               contigname => $contigname,
                                                               start      => $orf->start,
                                                               end        => $orf->end,
                                                               strand     => $orf->strand,
                                                               numorfs    => 1,
                                                               remark     => "",
                                                               protein    => $orf->protein,
                                                               score      => $orf->score, 
                                                               exons      => [],
                                                               introns    => [],
                                                             );         
                                        
                        next;    
                    }
                }    
                else {            #    Opposite strand
                    if (($newhypprot->start > $orf->end) or (abs ($orf->end - $newhypprot->start) < $MAXLENGTHFORGROUPINGORF)) {
                        
                        my $newstart;
                        my $newend;

                        if ($orf->start > $newhypprot->start) {
                            $newstart = $orf->start;
                        }
                        else {
                            $newstart = $newhypprot->start;
                        }
                 
                        if ($orf->end   < $newhypprot->end) {
                            $newend   = $orf->end;
                        }
                        else {
                            $newend   = $newhypprot->end;
                        }
                    
                        $newhypprot->set_start ($newstart);
                        $newhypprot->set_end ($newend);
                        
                        # Check which protein is the best
                        if ($orf->score < $newhypprot->score) {
                            $newhypprot->set_protein ($orf->protein);
                            $newhypprot->set_score ($orf->score);
                        }
                            
                        # Add 1 to the number of orf if there is concatenation
                        my $numorfs = $newhypprot->numorfs;
                        $numorfs++;
                        $newhypprot->set_numorfs($numorfs);
                        next;
                    }
                    else {
                                                #    ++    
                        push (@$HYPPROTS,  $newhypprot);            #    ++
                        #+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                        $newhypprot = new PirObject::HypProt (
                                                               name       => $name,
                                                               contigname => $contigname,
                                                               start      => $orf->start,
                                                               end        => $orf->end,
                                                               strand     => $orf->strand,
                                                               numorfs    => 1,
                                                               remark     => "", 
                                                               protein    => $orf->protein,
                                                               score      => $orf->score, 
                                                               exons      => [],
                                                               introns    => [],
                                                             );
                        next;    
                    }
                }
            }  # end for each ORF
            push (@$HYPPROTS,  $newhypprot);
        } # end if there is more than one ORF
    } # End for each Flip Blast Prot
}    

sub GetFlipBlastProtByNAmeAndContigName {    
    #     this function gives a FlipBlastProt with his name and contig name
    my $name = shift;    #    This the name of the GetFlipBlastProt
    my $contigname = shift;    #    This is the contigname of the FlipBlastProt
    
    foreach my $result (@$FLIPBLASTPROTS) {
        if ($result->name eq $name and $result->contigname eq $contigname) {
            return $result;
        }
    }
    return undef; # in the case where any object has been found
    
}

sub AddGeneFeatureUsingtRNAscanSE {

    #Description of the sub
    #1st : put the dna sequence into a temporary fastafile
    #2nd : run tRNAscanSE with the temporary fasta file  
    #3rd : parse the tRNAscanSE output
    #4th : annotate with the output
    
    #1st : put the dna sequence into a temporary fastafile
    
    my $pirmaster   = shift;                     # get the masterfile object
    #my $contigs     = [];                        # create a reference to a config file
    my $tag         = shift;        
    
    my $contigs        = $pirmaster->get_contigs(); # get the masterfiles contigs
    
    #my $contig      = undef;                     # An array containing all the contig name
    my $countcontig = 1;
    
    foreach my $contig (@$contigs) {                # parse all the contig
        my $name    = $contig->get_name();       # get the name for the contig
        my $seq     = $contig->get_sequence();   # get the sequence for each contig
        $seq        =~ s/[^atcgATCG]//g;
        
        #2nd : run tRNAscanSE with the temporary fasta file
        
        my $fastatmp = "$TMPDIR/fasta.tmp";      # temporary fasta file
        my $outputtrnascansetmp = "$TMPDIR/tRNAnouvscanSEoutputamacr.tmp";  # tRNAscanSE output temporary file

        open (FASTATMP, ">$fastatmp") or die "can't open fasta tmp file\n"; # put into a temporary fasta file    
        print FASTATMP ">contig$countcontig\n$seq";   #put the sequence into the temporary file with fasta format
        close FASTATMP; #close the temporary file    
    
        if (! -r "$fastatmp") {
            die "can't open fasta tmp file\n";
        }

        my $tRNAscanSEcmd = "$TRNASCANPATH -O -o $outputtrnascansetmp $fastatmp  > $TMPDIR/tRNAscanSE.output 2>&1";
        print "$tRNAscanSEcmd\n" if $DEBUG;
        my $restRNAscanSE = system ($tRNAscanSEcmd);         # -O for searching tRNA in organellar
                                                             # -C for unsing coves
                                                             # -o to write the result in a output file    

        #3rd Parsing tRNAscan output
        my $parser  = new PirObject::tRNAscanSEparser;       # Open the parser for tRNAscanSE
        $parser->loadObjectfromFile("$outputtrnascansetmp"); # Parse the file with the file and fill the object
        
        my @annotat = $parser->get_annotations;
        my $table   = $parser->get_annotations;              #this is a reference to an array
        
        foreach my $result (@$table) { # Correspond to the tRNAscanSE annotation 
            my $start;
            my $end;

            my $arrow;
            if ($result->get_begin > $result->get_end) {
                $arrow = "<==";   
            }
            else {
                $arrow = "==>";
            } 

            if ($arrow eq "==>") {            
                # Get the start and the end
                if ($result->get_begin > $result->get_end) {
                    $start = $result->get_end;
                    $end   = $result->get_begin;
                }
                else {
                    $start = $result->get_begin;
                    $end   = $result->get_end;
                }
            }
            else {
                if ($result->get_begin > $result->get_end) { 
                    $start = $result->get_begin;
                    $end   = $result->get_end;
                }
                else {
                    $start = $result->get_end;
                    $end   = $result->get_begin;
                }
            }        

            my $type   = $result->get_type;
            my $acodon = $result->get_anti_codon;
            my $score  = $result->get_score;
            if ($score < $TRNACUTOFF) { # if the score value is under the tRNA cutoff
                # go to the next tRNA
                next;
            }

            my %CodonTable = Bio::SeqUtils->valid_aa(2); # get the amino acide code
            my $aaSymbol   = uc(substr($type, 0, 1)).lc(substr($type, 1, 2)); # case treatment
            $aaSymbol      = $CodonTable{$type};         # change the amino acid in one to 3 letter
                   
            if (!defined($CodonTable{$type})) {
                $aaSymbol  = $type;
            }
            else {
                $aaSymbol  = $CodonTable{$type};         # change the amino acid in one to 3 letter
            }
                   
            # 4th ----- Create annotation -----#
            chomp ($aaSymbol) if (defined ($aaSymbol));
            my $genename = "trn$aaSymbol";
            my $annot    = new PirObject::AnnotPair (
                                                      type      => "G", 
                                                      genename  => "$genename", # Before : genename  => "tRNA-$type($acodon)",
                                                      startpos  => $start,
                                                      endpos    => $end,
                                                      direction => $arrow,
                                                    );

            my $number    = $ANNOTSEEN->{$annot->genename} || 0;
            my $arnname   = $genename;
            
            $number      += 1;
            if ($number > 1) { 
                $arnname .= "_$number";
            }

            $acodon       =~ tr/UTCGAutcga/uucgauucga/;
            $arnname     .= "($acodon)";
            my $startline = ";     G-$arnname $arrow start ";
            $startline   .= ";; MFFEAT=$tag score=$score" if $ADDCOMMENTS;
            my $endline   = ";     G-$arnname $arrow end ";
            $endline     .= ";;MFFEAT=$tag" if $ADDCOMMENTS;
            $annot->set_startline ($startline);
            $annot->set_endline ($endline);
            &AddAnnotToPirMaster($pirmaster,$name,$annot);
        } # end of each trna

        $countcontig ++;    
    } # each contig    
}

sub AddAnnotToPirMaster {

    #### MEANING CODE FOR THIS FUNCTION
    #### return 1 means ok, it has been added
    #### return 0 means function quit before the end, => rediscovered 
   
    my $pirmaster   = shift;
    my $contigname  = shift;
    my $annot       = shift;
    my $contig      = $pirmaster->GetContigByName($contigname) or die "Can't get contig by name\n";
    my $annotations = $contig->get_annotations;
    
     
    # Here we compare all the annotations, with the one we try to add 
    foreach my $annotation (@$annotations) {
        my $annotname = $annotation->genename;
        my $annottype = $annotation->type || "C";
        my $annotstart = $annotation->startpos;
        my $annotend = $annotation->endpos;
        $annotname = "comment" if (!defined  ($annotname));
        $annotstart = -1 if (!defined  ($annotstart));
        $annotend = -1 if (!defined  ($annotend));
    
    
        ##--First case : if both are same comment on the same line 
        if (($annottype eq "C") and ($annot->type eq "C") and
            ($annot->startpos == $annotstart) and
            ($annot->startline eq $annotation->startline)) {

            #Nothing is done in this case,
            return 0;
        }
    
        ##--Second case : No comment, both have same start end, and genename;
        if (($annottype ne "C") and ($annotname eq $annot->genename) and
            ($annotstart == $annot->startpos) and
            ($annotend == $annot->endpos)) {
            $ANNOT_STATS->{'Rediscovered'}->{$annot->genename} ||= {   'I' => 0, 'E' => 0, };
            return 0;
        }
    
        ##--Third case : Exons
        if ($annot->type eq "E") { # it's an exon. The protein has normally already been added
            if (defined ($annot->genename)) {
                $ANNOT_STATS->{'Added'}->{$annot->genename}->{'E'} ++;
            }
            push (@$annotations, $annot);
            return 1;
        }

        ##--4th case : Introns
        if ($annot->type eq "I") { # it's an intron. The protein has normally already been added
            if (defined ($annot->genename)) {
                $ANNOT_STATS->{'Added'}->{$annot->genename}->{'I'} ++;
            }
            push (@$annotations, $annot);
            return 1;
        }    
    }
    
    if ($FORCEANNOT) { # If Force annot, you can add a new one 
        $ANNOT_STATS->{'Added'}->{$annot->genename} ||= {  'I' => 0, 'E' => 0, } if ($annot->genename ne "comment");
        push (@$annotations, $annot);
        $ANNOTSEEN->{$annot->genename} += 1;
        return 1;
    }
    else { # If force annot does not exist
        if ($annot->type eq "C") {
            push (@$annotations, $annot);
            return 1;
        }
        if (defined ($ANNOTSEEN->{$annot->genename})) {     #  It mean,, this annotation has already been seen
            $ANNOT_STATS->{'Rediscovered'}->{$annot->genename} ||= {  'I' => 0, 'E' => 0, } if ($annot->genename ne "comment");
            return 0;
        }
        else { #  It means, force annot but this annotations doesn't seems to have an other copy    
            $ANNOT_STATS->{'Added'}->{$annot->genename} ||= {  'I' => 0, 'E' => 0, } if ($annot->genename ne "comment");
            $ANNOTSEEN->{$annot->genename} += 1;    
            push (@$annotations, $annot);
            return 1;
        }
    }    #    end of if forceannot .......
}

sub LogInfo { # this function is supposed to add information
              # in the head of the masterfile
              # such as
              #  - the genes added (with exons)
              #  - the rediscovered genes    

    my $pirmaster = shift;
    my $header    = $pirmaster->header() || [];

    my @report    = ();
    my $added     = $ANNOT_STATS->{'Added'};
    my $redisc    = $ANNOT_STATS->{'Rediscovered'};

    my @added     = sort keys %$added;
    my @redisc    = sort keys %$redisc;

    push(@report, ";;    - Gene Totals: " . scalar(@added) . " added; " . scalar(@redisc) . " rediscovered.",);

    # ---------------- genes added -------------------------
    
    push(@report, ";;    - List of genes added:",) if @added;

    my $COLS      = 3;
    my $cnt       = 0;
    my $rep       = "";

    print "Added : ", scalar(@added), "\n" if $DEBUG;
    print LOGFILE "Added : ", scalar(@added), "\n" if $ISLOGFILE;

    foreach my $genename (@added) {
        my($e,$i) = ($added->{$genename}->{'E'},$added->{$genename}->{'I'});
        $rep      = ";;     " if !$cnt;
        $rep     .= sprintf(" %-20s", ("$genename" . ($e > 1 ? " ($e exons)" : "")));
        $cnt++;
        if ($cnt >= $COLS) {
            push(@report, $rep);
            $cnt  = 0;
        }
    }
    push(@report, $rep) if $cnt;
    
    # ---------------- genes rediscovered -------------------------

    push(@report, ";;    - List of genes rediscovered:",) if @redisc;

    $cnt = 0;
    $rep = "";
    print "Rediscovered : ", scalar(@redisc), "\n" if $DEBUG;
    print LOGFILE "Rediscovered : ", scalar(@redisc), "\n" if $ISLOGFILE;
    foreach my $genename (@redisc) {
        my ($e,$i) = ($redisc->{$genename}->{'E'},$redisc->{$genename}->{'I'});
        $rep       = ";;     " if !$cnt;
        $rep      .= sprintf(" %-20s", ("$genename" . ($e > 1 ? " ($e exons)" : "")));
        $cnt++;
        if ($cnt >= $COLS) {
            push(@report, $rep);
            $cnt = 0;
        }
    }
    push(@report, $rep) if $cnt;
     
    push(@$header, ";; Masterfile modified automatically by $BASENAME version $VERSION");
    push (@$header, ";;    - New annotations labeled with: MFFEAT=$TAGNAME") 
        if $ADDCOMMENTS;  # we only put this sentence if option addcomments is activated
    push (@$header, @report, ";;",);

    $pirmaster->set_header($header);
}

sub CreateMap {   # A sub for creating map


    my $nameofmap = $OUTPUTFILE.".".$WITHMAP;
    
    # generate the xml file 
    my $xmlcmd         = "$MF2XMLPATH $OUTPUTFILE $TMPDIR/map.xml > $TMPDIR/mf2xmloutput 2> $TMPDIR/mf2xmlwarnings";
    print "$xmlcmd\n" if $DEBUG;
    print LOGFILE "$xmlcmd\n" if $ISLOGFILE;
    system $xmlcmd;
    
    # generate the map
    my $putinoptions;
    $putinoptions = " -f $WITHMAP ";
    $putinoptions .= " -E F " if ($WITHMAP eq "svg");
    my $mapcmd         = "$CGVIEWPATH -i $TMPDIR/map.xml $putinoptions -o $nameofmap  > $TMPDIR/cgviewoutput 2> $TMPDIR/cgviewwarnings";
    print "$mapcmd\n" if $DEBUG;
    print LOGFILE "$mapcmd\n" if $ISLOGFILE;
    system $mapcmd;    

    unlink ("$TMPDIR/map.xml");
    unlink ("$TMPDIR/mf2xmloutput");
    unlink ("$TMPDIR/mf2xmlwarnings");
    unlink ("$TMPDIR/cgviewoutput");
    unlink ("$TMPDIR/cgviewwarnings");

}

sub TestFile
{
  my $file = shift;
  if (!(-x $file)) {
      die "The file $file could not be found or was not executable. Please notify your administrator\n";
  }
}


END { # With exit, programme will go here
      # Cleanup temp directory when program exits.

    return unless defined($TMPDIR) and $TMPDIR =~ m#^/tmp/#;
    
    print "temporary work directory $TMPDIR cleaned up ...\n" if $DEBUG; 
    #system("/bin/rm","-rf",$TMPDIR) if -d $TMPDIR;
    rmtree($TMPDIR);
}

# End Of File. Or is it? What's beyond? Maybe the lost characters of all the sentences that were trunca
