#!/usr/bin/perl -w -- -*-Perl-*-

##############################################################################
#
#                                 mfannot.pl
#
# DESCRIPTION:
# Attempts to do a quick first pass at annotating a masterfile
# with meaningfull start/stop lines by calling blast on collections
# of known genes. Manual intervention is still required to check/adjust
# the new annotations.
#
# Known issues: - Annotations for START/STOP introns are interleaved (they
#                 are at the correct position, though).
#
##############################################################################

#############################################################################
#                                 MFANNOT                                   #
#                                                                           #
#                          Copyright (C) 2008                               #
#                         Departement de Biochimie,                         #
#                          Universite de Montreal,                          #
#                     C.P. 6128, succursale Centre-ville,                   #
#                      Montreal, Quebec, Canada, H3C 2J7                    #
#                                                                           #
#                Programming:  Natacha Beck, Pierre Rioux.                  #
#                Old version programming: David To, Thomas Hoellinger.      #
#                Project management: Franz Lang (OGMP)                      #
#                E-Mail information: Franz.Lang@Umontreal.ca                #
#                                                                           #
#     This software is distributed under the GNU GENERAL PUBLIC LICENSE, as #
# published by the Free Software Foundation. A copy of version 2 of this    #
# license should be included in a file called COPYING. If not, write to the #
# Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.   #
#############################################################################
#
#    $Id: mfannot,v 2.45 2010/04/02 01:04:21 nbeck Exp $
#
#    $Log: mfannot,v $
#    Revision 2.45  2010/04/02 01:04:21  nbeck
#    Changed sub RunHMM.
#
#    Revision 2.44  2010/04/02 00:40:34  nbeck
#    Used HMM for defined start. Keep lc in ori seq. Changed info in stdout.
#
#    Revision 2.43  2010/02/25 21:10:21  nbeck
#    Added support for motifs research.
#
#    Revision 2.42  2010/02/22 20:21:07  nbeck
#    Fixed bug with Introns annotations.
#
#    Revision 2.41  2010/02/05 14:57:26  nbeck
#    Fixed some little things : mf end with number, more strict for short exons,
#    changed mf header, changed conservation of comments, integrated new sub for
#    intergenic ORFs.
#
#    Revision 2.40  2009/12/16 17:34:54  nbeck
#    Added sqn output for MFannot online and changed comment for rnpB.
#
#    Revision 2.39  2009/12/12 00:50:01  nbeck
#    Changed sub for annotation of ORF.
#
#    Revision 2.38  2009/12/10 16:43:41  nbeck
#    Added option for Webserver.
#
#    Revision 2.37  2009/11/30 18:35:29  nbeck
#    Fixed bug in AdjustStart.
#
#    Revision 2.36  2009/11/19 20:50:55  nbeck
#    Fied Splice bug and comment bug.
#
#    Revision 2.35  2009/11/02 16:12:45  nbeck
#    Changed Blast option, added -a removed -F.
#
#    Revision 2.34  2009/10/27 15:06:03  nbeck
#    Fixed undef value.
#
#    Revision 2.33  2009/07/31 19:53:50  nbeck
#    Added annotation of first aa for intronic ORF.
#
#    Revision 2.32  2009/05/22 17:31:27  nbeck
#    Fixed annotation when two genes were identified at the same place by Exonerate.
#
#    Revision 2.31  2009/05/08 15:30:59  nbeck
#    Amendment of the annotation of RNA. Now, each contig is treated separately.
#    Added annotation of rns by RNAweasel.
#
#    Revision 2.30  2009/05/04 14:30:18  nbeck
#    Fixed bug due to contig name.
#
#    Revision 2.29  2009/04/28 20:56:46  nbeck
#    Added new methods and options in order to define introns and introns type.
#
#    Revision 2.28  2009/04/08 15:49:46  nbeck
#    Modified annotation of mini-exons.
#
#    Revision 2.27  2009/03/24 21:13:28  nbeck
#    Changed the method used to regroup C4 report of exonerate.
#    Removed "false introns" created by Exonerate and add message for insertion.
#
#    Revision 2.26  2009/03/05 15:51:59  nbeck
#    Added score when RNA is in a gene or a gene into RNA.
#
#    Revision 2.25  2009/02/27 19:21:17  nbeck
#    Removed useless options.
#    Keep only the annotations identified by ";; keep" in the masterfile of origin.
#
#    Revision 2.24  2009/02/24 18:13:48  nbeck
#    Now all introns are defined by RNASpinner, by default.
#
#    Revision 2.23  2009/02/17 20:33:30  nbeck
#    Checked format of the Masterfile.
#    Checked the existence of the directory for HMMweasel models.
#    Improved the definition of homologous.
#    Removed multicomments and simplified comments.
#
#    Revision 2.22  2009/02/06 21:46:44  nbeck
#    Added option -F F to blast.
#
#    Revision 2.21  2009/02/06 21:17:02  nbeck
#    Replaced ClustalW by Muscle.
#    Changed method to define gene start.
#    Changed method to annote gene fusion.
#    Remove useless option and changed option for blast.
#
#    Revision 2.20  2008/12/23 21:48:02  nbeck
#    *** empty log message ***
#
#    Revision 2.19  2008/10/10 21:10:17  nbeck
#    Fixed bug for usage of clustalW
#
#    Revision 2.18  2008/10/03 22:12:28  riouxp
#    Added de-escaping of certain XML entities (apos and quot) when
#    looking up protein sequences from library.
#
#    Revision 2.17  2008/09/19 21:31:14  nbeck
#    Fixed annotation of genes with introns
#
#    Revision 2.16  2008/09/13 19:06:19  riouxp
#    Added date, time, user and hostname in masterfile header.
#
#    Revision 2.15  2008/09/12 19:51:47  nbeck
#    Added support for fusioned genes.
#
#    Revision 2.14  2008/09/12 18:33:10  riouxp
#    Changed field "score" to "evalue" in many PirObjects. Made
#    sure CompareHighPrecisionFloats() is used for evalue comparisons.
#
#    Revision 2.13  2008/09/10 22:13:16  riouxp
#    Re-engineered the Blast Output parsing code; we now generate
#    the blast reports in XML and use PirObject::BlastOutput as
#    our model class instead of Bio::SearchIO. This improves efficiency
#    by 4x ! Also, the internal routine to extract protein sequences
#    from the library has been redesigned such that the sequences
#    are cached in memory in the first place.
#
#    Revision 2.12  2008/09/09 20:30:36  nbeck
#    Added a comment when a gene presents a frameshift and skipped research of
#    mini-exons for this case.
#
#    Revision 2.11  2008/09/09 16:49:59  nbeck
#    Added option in order to annote partial or incomplete genome.
#
#    Revision 2.10  2008/09/08 22:26:36  riouxp
#    Properly ignores empty exonerate outputs.
#
#    Revision 2.9  2008/09/08 22:17:39  riouxp
#    Real defensive code added.
#
#    Revision 2.8  2008/09/08 22:06:29  riouxp
#    Defnesive programming when exonerate doesn't produce a report.
#
#    Revision 2.7  2008/09/03 15:51:20  riouxp
#    Adjusted routine that compares high precision floats.
#
#    Revision 2.6  2008/08/29 19:11:50  nbeck
#    Added step to adjust gene starts position.
#    Changed default parameters for Blast.
#    Added step to check the validity of Multicomments.
#
#    Revision 2.5  2008/08/18 20:57:54  riouxp
#    Fixed bug with renumbering of gene sequences.
#
#    Revision 2.4  2008/08/18 18:34:59  nbeck
#    Fixed annotation of intronic ORFs.
#
#    Revision 2.3  2008/08/14 20:27:29  nbeck
#    Fixed adjustement of gene starts.
#
#    Revision 2.2  2008/08/13 21:36:32  nbeck
#    Fixed problem with intron type annotation.
#
#    Revision 2.1  2008/08/13 21:12:40  nbeck
#    Added identification of mini Exons.
#    Adjusted start position for gene identified by Exonerate.
#    Changed default parameters for Exonerate.
#
#    Revision 2.0  2008/06/27 18:35:14  nbeck
#    Adjusted the nucleotidic scores for defining the intron/exon boundaries.
#    Cleaned the code :
#        - Revised the indentation.
#        - Added comments in order to get the code more readable.
#        - Removed subroutines and options no longer used.
#        - Reordered all subroutines.
#        - Revision number bumped to 2.0 !
#
#    Revision 1.96  2008/06/03 20:16:37  nbeck
#    Add step to adjust exon/intron junction according to splice site models.
#
#    Revision 1.95  2008/05/01 15:54:22  riouxp
#    Modularized subroutine for launching external programs.
#
#    Revision 1.94  2008/04/25 17:01:40  riouxp
#    Added better handling of keyword 'none' for -ext_select.
#
#    Revision 1.93  2008/04/23 20:07:33  riouxp
#    Improved API between external commands and mfannot.
#
#    Revision 1.92  2008/03/20 21:04:56  nbeck
#    Cleaned old code.
#
#    Revision 1.91  2008/03/20 20:20:20  riouxp
#    Fixed tiny bug in support of multiple GeneNames args.
#
#    Revision 1.90  2008/03/20 20:10:32  riouxp
#    Added support for multiple genenames supplied on the GeneName
#    directive of the external programs configuration file. The
#    directive can now also be rewritten as "GeneNames" (with an S).
#
#    Revision 1.89  2008/03/19 21:49:58  riouxp
#    Added ability to run external programs in multiple distinct blocks
#    of commands, where the first one that returns a useful result is
#    taken. This required extending the format of the external programs
#    config file, and adjusting its parser and execution methods.
#
#    Revision 1.88  2008/03/18 21:40:47  nbeck
#    Add annotation of Intron using external programs.
#    Fixed bug for annotation of ORF.
#
#    Revision 1.87  2008/03/06 20:59:09  nbeck
#    Adding an option to choose which external programs to run.
#
#    Revision 1.86  2008/03/04 19:47:26  nbeck
#    Fixed bug : set a default value for evalue in subroutine ChoiceORF.
#
#    Revision 1.85  2008/03/03 16:56:26  nbeck
#    Fixed protein name for exonerate.
#
#    Revision 1.84  2008/02/27 21:26:19  nbeck
#    Improved mechanism for executing external programs (API).
#
#    Revision 1.83  2008/02/26 20:12:00  riouxp
#    Made endpos optional for AnnotPairs returned by external programs.
#
#    Revision 1.82  2008/02/22 21:26:47  riouxp
#    Added ability to trust the fields of the AnnotPairs obtained
#    from an AnnotPairCollection generated by external programs.
#    Default is still to recreate fields as needed.
#
#    Revision 1.81  2007/08/10 19:37:20  nbeck
#    Added support for calling external analasys programs
#
#    Revision 1.80  2007/07/26 19:28:53  nbeck
#    fixed bug for Exonerate

##########################
# Initialization section #
##########################

require 5.00;
use strict;
use vars qw( $VERSION $RCS_VERSION );
use IO::File;
use IO::Dir;
use Cwd;
use File::Basename;
use File::Path;
use PirObject;                                        # Pir module treatment 
use Bio::AlignIO;                                     # Bioperl (used for parsing alignement)
use Bio::SeqUtils;                                    # Some biological tools
use Bio::Tools::CodonTable;                           # To create a codon table, to be used with genewise
use Bio::Matrix::IO;                                  # Used for read matrix like PAM
use List::Util qw(min max);
use Sys::Hostname;

BEGIN {
# Load PirObject
PirObject->LoadDataModel("Masterfile");               # Masterfile object
PirObject->LoadDataModel("MfAnnotExternalProgs");     # Support for execution of external programs
PirObject->LoadDataModel("AnnotPairCollection");      # Also for external programs.
PirObject->LoadDataModel("ExonerateOutput");          # Parser for Exonerate output
PirObject->LoadDataModel("FlipBlastProt");            # Objects for storing ORFs predicted by Flip and kept with blast
PirObject->LoadDataModel("HypProt");                  # Hypothetical protein : We believe its a protein after flip.
PirObject->LoadDataModel("HypFusion");                # Contain information about gene fusion
PirObject->LoadDataModel("Option");                   # A module for options gestion
PirObject->LoadDataModel("EmptyOrf");                 # Object containing Orfs having no corresponding genes
PirObject->LoadDataModel("BlastOutput");              # Model of blast results in XML (blastall -m 7)
PirObject->LoadDataModel("AlignedSeq");
PirObject->LoadDataModel("MultAlign");

} # End Begin

# Default umask
umask 027;

# Program's name and version number.
$RCS_VERSION='$Id: mfannot,v 2.45 2010/04/02 01:04:21 nbeck Exp $';
($VERSION) = ($RCS_VERSION =~ m#,v ([\w\.]+)#);
my ($BASENAME) = ($0 =~ /([^\/]+)$/);

# Get login name
my $USER = getpwuid($<) or getlogin or die "Can't find USER from environment!\n";

##################################
# Global variables and constants #
##################################

# Command-line args (first, original program)
my $ANNOT_STATS      = {'Added' => {} };        # Use for create the header.
my $FLIPBLASTPROTS   = [];                      # Array containing the Proteins predicted by Blast and Flip
my $HYPPROTS         = [];                      # Array containing the Proteins predicted by Blast and Flip and reprocessed after
my $EMPTYORFS        = [];                      # Array containing ORFs having no corresponding genes
my $START_COUNT      = {};                      # Hash with count of tri_nt start.
my $FAMILY_LIST      = {};                      # Hash with family list.
my $TMPDIR           = "";                      # Temporary directory
my %PENAMEDISPLAY;                              # An hash array, containing the name to display, associate with peplibraries and pepfiles

# General options
my $DEBUG;                                      # Debug mode. If true, display message on the screen
my $GENCODE          = undef;                   # Genetique code
my $LOG_FILE;                                   # Log file : store all the information about run
my $ISLOGFILE        = 0;                       # Just to know if the $LOG_FILE is not empty (0 or 1)
my $MASTERFILE       = undef;                   # Path for Masterfile
my $PEPFILE;                                    # Path for the peptide file used
my $CACHE_PEPLIBRARY = {};                      # Cache of all proteins in library
my @PROT_FOR_EXONERATE;                         # Array with homolog protein for Exonerate
my $OUTPUTFILE;                                 # Path for the new
my $ORFPROCESS;                                 # Allows ORF appearing in the masterfile as annotations
my $PEPLIBRARIES;                               # The libraries, in input, by default datagenescollection and dataorfcollection
my $INPUTPEPFILES;                              # The input files
my $EXTCONFIGFILE;                              # The path for configuration file, it's use for annotation of rnpB, rnl and rns;
my $MOTFILE;                                    # The path of pattren file.
my $LVL_MOT;                                    # Indicate level of motif identification.
my $EXTSELECTPROG;                              # List of name for external programs.
my $LVL_INTRON;                                 # Indicate level of intron identification (0,1 or 2).
my $BLASTOUTPUT       = "";                     # The path for blast file results
my $BLASTEVALUECUTOFF;                          # Cutoff value for the blast
my $MINLENGTHORF;                               # This is the minimum length for creating an ORF with flip
my $MAXLENGTHFORGROUPINGORF;                    # Minimum size of a gap between 2 ORf. If 2 same ORF
my $MAXLENINTRONS;                              # Max intron size for exonerate.
my $MINLENEMPTYORF;                             # Minimum length for ORF empty orfs (non corresponding orfs)
my $OVERLAPPINGCUTOFF;                          # Overlapping cutoff for ORFs
my $OVERLORFOVORF;                              # Overlapping cutoff for ORFs 
my $OVERLAPORFOVGENE;                           # Overlapping cutoff for ORFs 
my $MININTRONSIZE;                              # Opposite of MAXLENGTHFORGROUPINGORF. Minimum size for intron
my $MINEXONSIZE;                                # Minimum exon size for intron.
my $MATRIX;                                     # PAM or BLOSUM matrix
my $PARTIAL;                                    # This will cause mfannot to only run a subset of all its built-in analysis
my $INSERTION;                                  # Minimum length for report insertion.
my $MAIL;                                       # Mail in order to send results

# Two booleans used in order to know if annotation of introns has been made
my ($annotate_intron_typeI,$annotate_intron_typeII)  = (0,0);

# Command line Program's paths
my $PATH = $ENV{"PATH"} || "";
my @PATH = split(/:/, $PATH);

my $HOME                    = $ENV{"HOME"};
my $BLASTPATH               = &GetPath("blastall");#"$h/blast-2.2.18/bin/blastall";#"$h/blast-2.2.18/bin/blastall";
my $FORMATDBPATH            = &GetPath("formatdb");
my $FLIPPATH                = &GetPath("flip");
my $EXONERATEPATH           = &GetPath("exonerate");
my $MUSCLEPATH              = &GetPath("muscle");
my $UMAC_EXE     = "/share/supported/bin/umac";
my $HMMBUILD_EXE = "/share/supported/bin/hmmbuild3";
my $HMMALIGN_EXE = "/share/supported/bin/hmmalign3";

# First get option in order to check some variables.
&GetOptions ;     # Get the different options and put them into global variables

my $Exonerate_parameter = "--model protein2genome --showcigar T --useaatla F --showquerygff T --showtargetgff T --minintron 142 --maxintron $MAXLENINTRONS --intronpenalty -35 --nosplicesignal T"; 

# Models and lib path
my @MOD_PATH      = (
    # You can add other search directories here
    ($HOME || ".") . "/mfannot_models",
);

push(@MOD_PATH,split(/:/,$ENV{"MFANNOT_MOD_PATH"}))
    if $ENV{"MFANNOT_MOD_PATH"};
    
my $MODEL_PATH = "";
foreach my $path (@MOD_PATH) {
    next if !(-d $path);
    $MODEL_PATH = $path;
}

$MODEL_PATH =~ s/\/$//;
die "No path for ErpinModels and HMMweaselModels were found\n"
    if !$MODEL_PATH;
    
# Check file existance
die "File $EXTCONFIGFILE give with option 'ext_select' doesn't exist.\n"
if (! -e "$EXTCONFIGFILE");

die "File $MOTFILE give with option 'motfile' doesn't exist.\n"
    if ( ! -e "$MOTFILE");
        
my $LISTPAT = &read_pat_file($MOTFILE) if ($LVL_MOT != 0);

#---------------------------#
my @LIB_PATH      = (
# You can add other search directories here
($HOME || "."));

push(@LIB_PATH,split(/:/,$ENV{"MFANNOT_LIB_PATH"}))
    if $ENV{"MFANNOT_LIB_PATH"};

#Check for directory
#Check for intronic lib
my $intronic_lib    = "";
foreach my $dir (@LIB_PATH) {
    next if !( -e "$dir/intronic/intronic_orfs.pep" );
    $intronic_lib    = "$dir/intronic/intronic_orfs.pep";
    last;
}
die "No file was found for intronic orfs library\n"
     if !$intronic_lib;

#Check for family lib
my $family_lib = "";
foreach my $dir (@LIB_PATH) {
    next if !( -e "$dir/family.lib" );
    $family_lib    = "$dir/family.lib";
    last;
}
die "No file was found for family library\n"
     if !$family_lib;

die "Please make sure the BLASTMAT environment variable is set\n".
    "to point to a directory where the blast matrices are stored.\n"
    unless defined($ENV{"BLASTMAT"}) and (-d $ENV{"BLASTMAT"}) and (-f ($ENV{"BLASTMAT"} . "/PAM70"));

my $matrix_path = $ENV{"BLASTMAT"}."/PAM70";

# Check if ~/.HMMweasel.cache exist and create them if they doesn't
my $HMM_cache = "$HOME/.HMMweasel.cache";
unless(-d $HMM_cache){ mkdir $HMM_cache or die "Cannot create '$HMM_cache'";}

my $parser           = new Bio::Matrix::IO(-format => 'scoring',
                                           -file   => $matrix_path);
my $matrix           = $parser->next_matrix;

    
# Parameters that don't have (yet) options on the command-line
my $SHORT_HSPS_MIN_EVALUE = "1e-11";

################
# Trap Signals #
################
$SIG{'INT'}  = \&SigCleanup;
$SIG{'TERM'} = \&SigCleanup;
$SIG{'HUP'}  = \&SigCleanup;
$SIG{'QUIT'} = \&SigCleanup;
$SIG{'PIPE'} = \&SigCleanup;
$SIG{'ALRM'} = \&SigCleanup;

###############################
#   M A I N   P R O G R A M   #
###############################

my $LOG_F = new IO::File ">$LOG_FILE" if $ISLOGFILE;
#----------HEADER PRINTED OUT----------------------------------------------------------
my $header = "\n".
             "######################################################################\n".
             "MFANNOT, ORGANELLAR GENOME ANNOTATION PROGRAM                         \n".
             "VERSION $VERSION                                                      \n".
             "Programmed by N. Beck and P. Rioux                                    \n".
             "######################################################################\n\n";

print $header;
print $LOG_F "$header" if $ISLOGFILE;
my $add_text_in_header = "";

# OPTIONS OF THE PROGRAM #
my $options ="----------------------------------\n".
             "        General Options           \n".
             "----------------------------------\n";
$options .= "Masterfile used : $MASTERFILE\n";
$options .= "new Masterfile created : $OUTPUTFILE\n";
$options .= "Genetic code : $GENCODE\n";
$options .= "Logfile : $LOG_FILE\n" if $ISLOGFILE;
$options .= "Usage of RNAweasel\n";
$options .= "The Path of configfile is : $EXTCONFIGFILE\n";
$options .= "The Path of pattern file is : $MOTFILE\n";
$options .= "Look in the peptide library $PEPLIBRARIES\n";

print $LOG_F "$options" if $ISLOGFILE;           # Print options in the logfile
print $options if $DEBUG;                        # Print the options on the screen 

# CREATE THE TMPDIR #
$TMPDIR = "/tmp/mfannot.$$" if !$TMPDIR;
if (! -d $TMPDIR) {
    mkdir($TMPDIR,0700) or die "Error: can't create work directory '$TMPDIR': $!\n";
}

# Initialization of $CODON_TABLE (Hashtable with genetic code)
my $BIOCODONTABLE   = Bio::Tools::CodonTable->new( -id => $GENCODE);
die "Unexisting genetic id\n" if   (not $BIOCODONTABLE->id($GENCODE));
my $CODON_TABLE     = &CacheCodonTableWithGeneticId ($BIOCODONTABLE); # Hashtable with genetic code

# LIB CREATION #
die "'$PEPLIBRARIES' isn't a directory\n" 
    if (not -d $PEPLIBRARIES);
my $LIB_FILE                   = "$TMPDIR/library.pep";
   $CACHE_PEPLIBRARY           = &CreatePepfileWithLibrary;
   $PENAMEDISPLAY{"$LIB_FILE"} = $PEPLIBRARIES;     # Associate, the name of the library for each peplibraries
die "Unable to read '$LIB_FILE'\n" 
    if (not -r $LIB_FILE);

# ANNOTATION # 
# Print option of the annotation
print "----------------------------------\n",
      "         Gene Annotation          \n",
      "----------------------------------\n";
print $LOG_F  "----------------------------------\n",
              "         Gene Annotation          \n",
              "----------------------------------\n" if $ISLOGFILE;
              
print "File used in order to find motif is '$MOTFILE'\n" if $LVL_MOT != 0;

$options  = "Options : \n";                  # Options & parameters used for the blast
$options .= "Minimum size ORF, for flip running $MINLENGTHORF\n";
$options .= "Blast e-value cutoff : $BLASTEVALUECUTOFF\n";
$options .= "Minimum exon size : $MINEXONSIZE\n";
$options .= "Maximum intron size : $MAXLENGTHFORGROUPINGORF\n";
$options .= "Minimum intron size : $MININTRONSIZE\n";
$options .= "Matrix : $MATRIX\n";
$options .= "Minimum length for non corresponding ORFs : $MINLENEMPTYORF\n";
$options .= "Overlapping cutoff for non corresponding ORFs: $OVERLAPPINGCUTOFF\n";

print $options if $DEBUG;
print $LOG_F $options if $ISLOGFILE;

# - Create a masterfile object
# - Load the annotations
# - Load the sequence of each contig 

print "Parsing masterfile $MASTERFILE...\n\n";
my $pirmaster     = PirObject::Masterfile->ObjectFromMasterfile($MASTERFILE);
my $contigs       = $pirmaster->get_contigs();
my $numbercontigs = scalar (@$contigs);        # Number of contigs in the masterfile
die "No contig header can be found in the masterfile '$MASTERFILE'\n" if $numbercontigs == 0;
my $numberannot   = 0;                         # Number of annotations detected in the program

my $CONTIG = {};
&CleanPirmaster() if ($LVL_MOT != 1);
my $NB_PROC   = &DefineNumberOfProcessor();

print "Number of contigs in Masterfile : $numbercontigs\n",
      "Number of annotations (or comments) detected : $numberannot\n" if $DEBUG;

print $LOG_F "Number of contigs in Masterfile : $numbercontigs\n",
            "Number of annotations (or comments) detected : $numberannot\n" if $ISLOGFILE;

# START THE PROCESS #
my $step        = 1;

# Print the name of each pepfile if it's a library, name begin with libarary....
#my $displayfile = $PENAMEDISPLAY{"$LIB_FILE"} || "$LIB_FILE";    # Get the associate name, so if it's a library, get the name of the library         
#my @tabname     = split ("/", $displayfile);
# print "\n****** Annotation from " . $tabname [$#tabname] . " ******\n" if scalar(@tabname) != 1;

# Core #
if ($LVL_MOT != 1) {
# Run the programm step by, to know the right step  
# Flip running, generate ORFS
print "$step) Flip...\n";
$step += 1; 
&RunFlip;

# Blast the flip result with the blast
print "$step) Blast...\n";
$step += 1;  
&BlastFlipVSGene;

# Parse the blast result, create a flipblastprot object
print "$step) Parse Blast Results...\n";
$step += 1;
&ParseInformationFromBlastResult;

# Selection of protein
print "$step) Select best protein for Exonerate...\n";
$step += 1; 
&Select_protein;

# Create hypothetical proteins  
print "$step) Annotate genes w/o introns...\n";
$step += 1; 
&FillHYPPROTSArrayWithFLIPBLASTPROTSArray;

# Annotation of all introns
if ($LVL_INTRON == 2 ) {
    print "$step) Introns identification...\n";
    &Annotate_Using_external_programs("IntronII,IntronI");
    $step += 1; 
}

# Make the alignement and give the exons
print "$step) Annotate genes with introns...\n"; 
$step += 1; 
&FindExonsInHypProtArray;

# Organise the hypothetical proteins (find the real start)
print "$step) Identify gene fusions...\n"; 
$step += 1; 
&TreatGeneFusion;

# Search mini exons
if (!$PARTIAL) {
    print "$step) Annotate mini exons...\n";
    $step += 1; 
    &AnnotateMiniExons;
}

&AnnotateMfFromHYPPROTSArray;

# Annotate rRNA -> Use RNAweasel for 5SrRNA and rnpB, Use HMMweasel for rns and rnl
print "$step) Annotation of RNA genes...\n"; 
$step += 1;
&Annotate_Using_external_programs;

# Adjust intronic boundaries with rules for type I and type II 
print "$step) Adjust intronic boundaries...\n"; 
$step += 1; 
&Adjust_all_intronic_junctions;

print "$step) Identify start codons; comment fusions...\n"; 
$step += 1; 
&CommentFusion;

# Process empty orfs, -> annotate empty ORFs in the masterfile (whose who correspond to something good)
if ($ORFPROCESS) {
    print "$step) ORF annotation...\n"; 
    $step += 1; 
    &AnnotateEmptyOrfs;
}

# Process intronical ORF -> annotate intronicale ORF not detected by Blast
print "$step) Intronic ORF annotation...\n"; 
$step += 1; 
&AnnotateIntronicOrfs;

&MulticommentConfidence;
&LcIntrons;
}

if ($LVL_MOT != 0) {
    print "$step) Process motifs...\n";
    $step += 1;
    &SearchMotAndMakeAP;
}

&ReplaceCgName if $LVL_MOT != 1;
# PROGRAMME ENDING #

print "\n----------------------------------\n",
      "       End of the Programme       \n",
      "----------------------------------\n";  

# Unreferencing 
undef $FLIPBLASTPROTS;
undef $HYPPROTS;
undef $EMPTYORFS;

# Renumber genes with _1, _2 etc correctly this time.
&RenumberFeatures;

# Add informations in the masterfile     
&LogInfo;

# Dump it
print "Dumping new masterfile in $OUTPUTFILE\n";
$pirmaster->ObjectToMasterfile("$OUTPUTFILE");

&CreateTBLoutput($OUTPUTFILE) if $MAIL;

if (0) {
print "Dumping PirMaster object to $OUTPUTFILE.xml\n";
$pirmaster->ObjectToFile("$OUTPUTFILE.xml");
}

if ($ISLOGFILE == 1) {
    print "close Logfile : $LOG_FILE\n" if $DEBUG;
    $LOG_F->close() or print "Logfile not closed\n";
}

my $filename = basename($OUTPUTFILE);
system("cp $OUTPUTFILE $TMPDIR/$filename");
&sendMail($filename) if $MAIL;
exit 0;

END { 
    # With exit, programme will go here
    # Cleanup temp directory when program exits.
    return unless defined($TMPDIR) and $TMPDIR =~ m#^/tmp/#;
    print "Temporary work directory $TMPDIR NOT cleaned up ...\n" if $DEBUG; 
    rmtree($TMPDIR) unless $DEBUG;
}

#############################
#   S U B R O U T I N E S   #
#############################

#-------------------------------------------------------------#
# Subs calling at beginning before to run the core of Mfannot #
#-------------------------------------------------------------#
sub GetPath {
    my $name_prog = shift;
    
    foreach my $dir (@PATH) {
        if (-f "$dir/$name_prog") {
            if (-r _ && -x _) {
                return "$dir/$name_prog";
            }
            else {
                die "   -> ERROR: $name_prog is not readable and executable! Please run:\n",
                    "             chmod 755 \"$dir/ $name_prog\"\n";
            }
        last;
        }
    }
    die "-> ERROR: Could not find '$name_prog' in your search path. Please install\n",
        "   $name_prog from the source (see INSTALL.txt).\n";
}

sub SigCleanup {
     die "\nExiting: received signal \"" . $_[0] . "\".\n";
     # Note that some cleanup will be performed in the END block at this point.
}

sub CreatePepfileWithLibrary {
    my ($library,$pepfile) = ($PEPLIBRARIES,$LIB_FILE);

    opendir (DIR, $library) or die "Can not open directory '$library': $!\n"; # Open the directory
    my @files = grep((/\.pep$/ and -f "$library/$_"), readdir(DIR));   # Keep the existing *.pep files
    close (DIR);                                                      # Close the directory

    my $outfh = new IO::File ">$pepfile"
        or die "Can't write to library file '$pepfile': $!\n";

    my $desc_to_prot = {}; # Save all proteins 
    # Concatenate all the file from the library
    my $desc = "";
    foreach my $file (@files) {
        my $loc_file = "$library/$file";
        
        my $PEP_F = new IO::File "<$loc_file" or die "Can not open the pepfile '$loc_file': $!\n";
        while (my $line = <$PEP_F>) {
            next if $line =~ /^;|^\s*$/;
            if ($line =~ /^>/) {
                die "The library file \"$loc_file\" has incorrect FASTA syntax.\nThe line faulty line is: $_"
                    if (!($line =~ /\s*([\S]*)\s*;/));
                $desc = $line;
                $desc =~ s/^>?\s*//;
                $desc =~ s/\s*$//;
                print $outfh ">$desc\n";
                die "Error in library $library: duplicated FASTA header '$desc'.\n"
                    if exists $desc_to_prot->{$desc};
                next;
            }
            print $outfh $line; # seq line
            $line =~ s/^\s*//; # cleanup seq line
            $line =~ s/\s*$//;
            $desc_to_prot->{$desc} .= $line;
        }
        $PEP_F->close();
    }
    $outfh->close();
    return $desc_to_prot; # cache of all proteins in library
} # End sub

sub GetOptions {
    # This function is here to manipulate options
    my $option = new PirObject::Option ();      #  Buil a new option model
    $option->FillOption ();                     #  This one build with the default option and look for a rc file
    # Now The object contains all the options

    # General options
    $DEBUG                   = $option->debug;             # Debug mode. If true, display message on the screen
    $GENCODE                 = $option->genetic;           # Genetique code
    $MASTERFILE              = $option->masterfile;        # Path for Masterfile
    $OUTPUTFILE              = $option->outputfile;        # Path for the new
    $ORFPROCESS              = $option->orf;               # For Orf process, allowing presence or not in the masterfile
    $PEPLIBRARIES            = $option->pepdirectory;      # List of path for peplibrary directory
    $EXTCONFIGFILE           = $option->ext_config;        # Path for configfile
    $MOTFILE                 = $option->motfile;           # Path for pattern file.
    $LVL_MOT                 = $option->lvlmot;            # Indicate level of motif identification.
    die "Option --lvlmot must be 0,1 or 2\n" if $LVL_MOT < 0 || $LVL_MOT > 2;
    $EXTSELECTPROG           = $option->ext_select;        # List of names for external prog
    $LVL_INTRON              = $option->lvlintron;         # Indicate level of intron identification (0,1 or 2).
    die "Option --lvlintron must be 0,1 or 2\n" if $LVL_INTRON < 0 || $LVL_INTRON > 2;
    $BLASTEVALUECUTOFF       = $option->blast2;            # Cutoff value for the blast
    $MINLENGTHORF            = $option->flip2;             # This is the minimum length for creating an ORF with flip
    $MAXLENGTHFORGROUPINGORF = $option->maxintronsize;     # Minimum size of a gap between 2 ORf. If 2 same ORF
    $MAXLENINTRONS           = $option->maxintronsize;     # Max intron size for exonerate.
    $MINLENEMPTYORF          = $option->minlenemptyorf;    # Minimum length for ORF empty orfs (non corresponding orfs)
    $OVERLAPPINGCUTOFF       = $option->overlappingcutoff; # Overlapping cutoff for ORFs
    $OVERLORFOVORF           = $option->orfOVorf;          # Overlapping cutoff for ORFs 
    $OVERLAPORFOVGENE        = $option->orfOVgene;         # Overlapping cutoff for ORFs 
    $MININTRONSIZE           = $option->minintronsize;     # Opposite of $MAXLENGTHFORGROUPINGORF. Minimum size for intron
    $MINEXONSIZE             = $option->minexonsize;       # Minimum exon size for intron. In genewise.
    $MATRIX                  = $option->matrix;            # The matrix used in genewise alignement
    $PARTIAL                 = $option->partial;           # This will cause mfannot to only run a subset of all its built-in analysis
    $INSERTION               = $option->insertion;         # Minimum length for report insertion
    $MAIL                    = $option->mail;              # Mail in order to send results
    $TMPDIR                  = $option->tmpdir;            # Temporary work directory

    if($option->islogfile and defined($option->logfile)) {
        if(-w (dirname($option->logfile))) {
            $ISLOGFILE       = $option->islogfile;     #  Just to know if the $LOG_FILE is not empty (0 or 1)
            $LOG_FILE        = $option->logfile;       #  log file : store all the information about run
        }
        else {
            print "\nThe path to your logfile \"" . ($option->logfile). "\" is not writable by you.\n";
            print "No file logging will be performed\n";
            $ISLOGFILE = 0;
            $LOG_FILE  = undef;
        }
    }

    my $count = "";
    my $name  = $OUTPUTFILE;

    # Checking to see if the path to the output file is writable
    die "\nThe path to where your outputfile will be produced is not writable by you ($name).\nPlease resolve this problem before running again\n"
        if (!-w (dirname($name)));

    # Determing new name of output file if file already exists
    chomp ($name);
    $name =~ s/\d*$//; 
    while (-r ("$name"."$count")) {
        if ($count eq "") {$count = 1;}
        else              {$count++;} 
    }
    $OUTPUTFILE = "$name"."$count";
} # End sub

sub CacheCodonTableWithGeneticId {
    # This function create a file
    # Having a codon table.
    # ATT F....
    # ATG M...
    # Comment will begin with "!"
    my $codontable = shift;   # The bio::tools::codontable
    
    my $ct_cache = {};
    my @letter = qw (A T C G N);
    my $i      = 0;
    my $j      = 0;
    my $z      = 0;

    while ($i < scalar(@letter)) {
        $j = 0;
        while ($j < scalar(@letter)) {
            $z = 0;
            while ($z < scalar(@letter)) {
                my $codon = $letter[$i].$letter[$j].$letter[$z];
                my $aa    = $codontable->translate($codon);
                $ct_cache->{$codon} = $aa;
                $z++;
            }
            $j++;
        }
        $i++;
    }
    return $ct_cache; 
} # End sub

sub CleanPirmaster {
     my $AP_to_rm = [];
     
     # Check each annot push all annot to remove on $AP_to_rm, changed the other one
     my $isUnique = {};
     my $count    = 0;
     foreach my $contig (@$contigs) {
         my $annotations = $contig->get_annotations();
         my $contigname  = $contig->get_name();
         my $comments    = $contig->get_namecomments() || "";
         my $header      = $contigname.$comments;
         $isUnique->{$header}++;
         die "Two contig have same header '$header'\n" if $isUnique->{$header} > 1;
         $count++;
         $CONTIG->{"contig$count"} = "$header";
         $contig->set_namecomments("");
         $contig->set_name("contig$count");
         my $seq = $contig->get_sequence();
            $seq =~ s/\!//g;
            $seq = $seq;
         $contig->set_sequence($seq);
         foreach my $AP (@$annotations) {
             my $type      = $AP->get_type();
             my $startline = $AP->get_startline() || "";
             my $endline   = $AP->get_endline()   || "";
             my ($new_startline,$new_endline) = ("","");
             my $id_AP     = $1 if scalar($AP) =~ m/0x(.+)\)/;
             push (@$AP_to_rm, $id_AP) if $startline =~ m/;;\s+mfannot:/;
             next if ($type eq "C");
             $AP->set_type("C");
             
             # Si une annot ne presente pas de startline ou de endline ?? quoi faire
             if ($endline ne "" && $startline ne "") {
                 $new_startline = $2 if $startline =~ m/(.+)\s*(;;.+)$/ && $2 !~ m/mfannot:/;
                 $AP->set_startline($new_startline);
                 $AP->set_startpos() if $new_startline eq "";
                 $new_endline   = $2 if $endline =~ m/(.+)\s*(;;.+)$/   && $2 !~ m/mfannot:/;
                 $AP->set_endline($new_endline) ;
                 $AP->set_endpos() if $new_endline eq "";
                 push (@$AP_to_rm, $id_AP) if $new_endline eq "" && $new_startline eq "";
                 next;
             }
             elsif ($endline eq "") {
                 $new_startline = ";$startline ;; mfannot: no end found";
                 $AP->set_startline($new_startline);
                 next;
             }
             else {
                 $new_endline = ";$endline ;; mfannot: no start found";
                 $AP->set_endline($new_endline);
                 next;
             }
         }
         &Remove_AP($AP_to_rm,$contig);
     }
     $pirmaster->ObjectToMasterfile("$TMPDIR/Masterfile_copy");
}

sub Remove_AP {
    my ($AP_to_rm,$contig) = @_;
    
    my $all_annots = $contig->get_annotations();
    for (my $i = @$all_annots - 1; $i >= 0 ; $i--) {
        my $contig_AP    = @$all_annots[$i];
        my $id_contig_AP = $1 if  scalar($contig_AP) =~ m/0x(.+)\)/;
        foreach my $id_rm_AP (@$AP_to_rm) {
            splice(@$all_annots, $i, 1) if $id_rm_AP eq $id_contig_AP;
        }
    }
}

sub DefineNumberOfProcessor {
    my $nb_proc = "$TMPDIR/nb_proc";
    system("grep processor /proc/cpuinfo > $nb_proc");
    my $count_proc = 0;
    my $infh = new IO::File "<$nb_proc"
        or die "Can't read from file '$nb_proc': $!\n";
    while (my $line = <$infh>) {
        next if $line !~ m/^processor\s*:\s*\d+$/;
        $count_proc++;
    }
    return $count_proc;
}


#-----------------------------------#
# Subs forming the core of Mfannot  #
#-----------------------------------#

#------------------------#
# Subs for running flip  #
#------------------------#

sub RunFlip {
    # This function run flip with the masterfile
    # Flip is a program generating ORF
    my $cwd  = cwd();  # Get current working directory name
    chdir ("$TMPDIR"); # Need to change the temporary directory to run flip

    # Just check if Flip outfiles exist here already, if so get rid of them
    unlink("prot.lst") if (-e "prot.lst");
    unlink("prot.src") if (-e "prot.src");
    unlink("compl")    if (-e "compl");
    unlink("uncompl")  if (-e "uncompl");

    # Checking the see if the masterfile path is aboslute or relative
    my $tmpMasterfile = "$TMPDIR/Masterfile_copy";
    
    # Need to remove CR from masterfile, so let's make a local copy
    print "Making local copy of masterfile with no CRs.\n" if $DEBUG;
    my $ifh = new IO::File "<$tmpMasterfile"
        or die "Cannot read from masterfile '$tmpMasterfile': $!\n";
    my $ofh = new IO::File ">mf_noCr.all"
        or die "Cannot write to temp file 'mf_noCr.all': $!\n";  # in TMPDIR
    while (my $line = <$ifh>) {
        $line =~ s/\s+$/\n/;
        print $ofh $line;
    }
    $ofh->close();
    $ifh->close();

    my $cmdflip = "$FLIPPATH -m -l $MINLENGTHORF -g $GENCODE mf_noCr.all > $TMPDIR/flip.output";
    # -m With this switch, flip will translate the first codon of a protein by 'M' if the codon is a start codon

    system("$cmdflip >/dev/null 2>/dev/null");
    print "$cmdflip\n" if $DEBUG;
    chdir($cwd); # Changing back to the original directory
} # End sub

#--------------------------#
# Subs for running Blast   #
#--------------------------#

sub BlastFlipVSGene {
    # It runs blast with the flip results against file containing genes 
    $BLASTOUTPUT     = $TMPDIR . "/blastoutput.xml";
    my $file         = $LIB_FILE;                                # Undef should never happen in fact.
    my $escaped_file = $file;
       $escaped_file =~ s#'#'\\'#g;         
    my $command      = "$FORMATDBPATH -p 'T' -t banque -i $escaped_file -n $TMPDIR/mf -l $TMPDIR/fdb_1.log >/dev/null 2>/dev/null";
    print "$command\n" if $DEBUG;
    system($command);

    # RUN FOR BLAST : run blast with the db created and the flip results        
    my $cmdblast     = "nice -19 $BLASTPATH -m 7 -p blastp -M $MATRIX -d $TMPDIR/mf -i $TMPDIR/prot.lst -D $GENCODE -o $BLASTOUTPUT -a $NB_PROC 2> $TMPDIR/blasterr_1.txt";
    print "$cmdblast\n" if $DEBUG;
    system ($cmdblast);
} # End sub


#--------------------------------------------------#
# Subs for parsing information from Blast results  #
#--------------------------------------------------#

sub ParseInformationFromBlastResult {
    my $type        = 'PROT';
    my $file        = $LIB_FILE;
    my $blastoutput = $BLASTOUTPUT;

    die "Error: can't find $type report from blastall ?!?\n"
        if (! -r $blastoutput); # It's supposed to be here at this point
        
    my $searchfh = new IO::File "<$blastoutput"
        or die "Can't read from '$blastoutput': $!\n";
                                     
    while (my $result = PirObject::BlastOutput->FileHandleToObject($searchfh)) {
        my $iterations = $result->BlastOutput_iterations() || next;
        foreach my $iteration (@$iterations) {
            &FillFLIPBLASTPROTArrayFromBlastResult($type,$result,$iteration);
        }
    }
    $searchfh->close();
    
    foreach my $flipblastprot (@$FLIPBLASTPROTS) {
        my $homologous = $flipblastprot->homologous();
        my @sorted = sort {
            &CompareHighPrecisionFloats($a->get_evalue(),$b->get_evalue());
        } @$homologous;
        my $length = scalar(@sorted);
           $length = ($length < 10 ? $length : 10 );
        
        my %already_here    = ();
        my @best_homologous = ();
        foreach my $similar (@sorted) {
            next if scalar(@best_homologous) >= $length;
            my $ident = $similar->get_similarprot();
            push(@best_homologous,$similar) unless ($already_here{$ident}++); 
        }
        $flipblastprot->set_homologous( \ @best_homologous );
    }
} # End sub

sub CompareHighPrecisionFloats {
    # Only for floats that are in NORMALIZED scientific form.
    # Examples of different cases :
    #
    #    1       1.      1.2
    #    1.2e    1.2e3   1.2e-3
    #    e-3     1e3
    #
    # Each of these can optionally be prefixed with "+" or "-".
    #
    # Unlike Math::BigFloat, this routine handles "e-3".

    my ($x,$y) = @_;
    
    die "Unparsable number '$x'\n"
        unless $x =~ m/^([\+\-]?)             # sign
                        ([\d\.]*)             # significand
                        (?:e(-?\d*))?         # exponent
                       $/x;
    my ($xsig,$xman,$xexp) = ($1,$2,$3);
    
    die "Unparsable number '$y'\n"
        unless $y =~ m/^([\+\-]?)             # sign
                        ([\d\.]*)             # significand
                        (?:e(-?\d*))?         # exponent
                       $/x;
    my ($ysig,$yman,$yexp) = ($1,$2,$3);
    
    # Define missing optional components of number representation
    $xsig ||= "+";
    $ysig ||= "+";
    $xman = 1 if !defined($xman) || $xman eq "";
    $yman = 1 if !defined($yman) || $yman eq "";
    $xexp = 0 if !defined($xexp) || $xexp eq "";
    $yexp = 0 if !defined($yexp) || $yexp eq "";  
    
    # Compare numbers when $x or $y are effectively zero
    return 0
        if $xman == 0 && $yman == 0;  # $x == 0 and $y == 0
    return ($xsig eq '-' ? -1 : +1)
        if $xman != 0 && $yman == 0;  # $x != 0 and $y == 0
    return ($ysig eq '-' ? +1 : -1)
        if $xman == 0 && $yman != 0;  # $x == 0 and $y != 0
    
    # Easy comparisons when signs differ
    if ($xsig ne $ysig) {
        return $xsig eq '+' ? 1 : -1;
    }

    # Permutate X <=> Y if both signs are negative
    ($xman,$xexp,$yman,$yexp) = ($yman,$yexp,$xman,$xexp)
        if $xsig eq '-'; # $ysig is '-' too at this point.
    
    # At this point, $x and $y both have mantissas > 0
    return ($xexp <=> $yexp) if $xexp != $yexp;  # $x and $y have different EXP, so compare EXP
    return ($xman <=> $yman);                    # $x and $y have same EXP, so compare mantissas
}

sub FillFLIPBLASTPROTArrayFromBlastResult {
    my $type      = shift; # 'DNA' or 'PROT'
    my $result    = shift; # An object implementing PirObject::BlastOutput
    my $iteration = shift; # An object implementing PirObject::BlastOutput::Iteration

    return if (!$result);

    my $rdesc = $iteration->Iteration_query_def() ||   # priority to iteration's value
                $result->BlastOutput_query_def()  ||
                "Unknown Query Description";
    $rdesc =~ m/^\s*(\S+)/;
    my $contigname = $1 || "Unknown contig name";
    $contigname =~ s/;$//; # spurious semicolon introduced by flip
    
    my ($strand, $start, $end) = ($rdesc =~ /(orig|compl).\s+(\d+)\s+to\s+(\d+)\s+;\s+[\w\.\!]+/);
    $strand   = ($strand eq 'orig' ? 1 : -1);

    my $hitslist = $iteration->Iteration_hits() || return;
    # If we have no match.
    if (!@$hitslist){
        my $newemptyorf = new PirObject::EmptyOrf (
                                                   start      => $start,
                                                   end        => $end,
                                                   strand     => $strand,
                                                   evalue     => 9999,
                                                   contigname => $contigname,
                                                  );
        push (@$EMPTYORFS, $newemptyorf);          # Put into the array, to be processed after   
        return;           
    }
    
    return if @$hitslist < 1; # normally, only one.
    # Note: the significance() method is defined in Hit.pir
    my @hits = sort { &CompareHighPrecisionFloats($a->significance(), $b->significance() ) } @$hitslist;

    # We have an hypothetical protein and we want to know if it'real
    # Quit the function if evalue is too weak #
    # Note: CompareHighPrecisionFloats(a,b) returns: 1 if a > b, -1 if a < b, 0 if a == b
    my $hit   = $hits[0];
    if (&CompareHighPrecisionFloats($hit->significance(),$BLASTEVALUECUTOFF) == 1) { 
        # If the e-value is not enough for these ORF you can create an Empty ORF 
        my $newemptyorf = new PirObject::EmptyOrf (
                                                   start      => $start,
                                                   end        => $end,
                                                   strand     => $strand,
                                                   evalue     => $hit->significance(),
                                                   contigname => $contigname,
                                                  );
        push (@$EMPTYORFS, $newemptyorf);          # Put into the array, to be processed after   
        return;                                    # Exit the function, because there is no significant ORF 
    }
    
    # Now we have the start, we have the end, the strand and we would like to know if more than one hit is allowed
    my @overlapping;
    my $homo_hash = {};
    for (my $i = 0 ;; $i++) {
        my $hit         = $hits[$i] || last;
        my $fullheader  = $hit->Hit_def();
        my $name = $1 if $fullheader =~ /\s*(\S+)\s*;/;
        next if (not (defined ($name)) or $name eq "");
        my $evalue      = $hit->significance();
        last if &CompareHighPrecisionFloats($evalue,$BLASTEVALUECUTOFF) == 1; # $eva > $BL
        my $prot        = &TakeProteinFromPepfile ($fullheader, $LIB_FILE);
        
        my $homo_tab = $homo_hash->{$name} || ();
        my $newhomologous = new PirObject::Homologous (
                                                        similarprot      => $prot,
                                                        evalue           => $evalue,
                                                       );
        push(@$homo_tab, $newhomologous) unless $homo_tab && scalar(@$homo_tab) >= 10;  # hash ref
        $homo_hash->{$name} = $homo_tab;
    }
    
    # Now we have the start, we have the end, the strand and we would like to know if more than one hit is allowed
    my $hypfusiongene = 0;
    HIT : foreach my $hit (@hits) {
        my $fullheader   = $hit->Hit_def();  # Get the description of the query sequence
        my $hypprotein   = $1 if $fullheader =~ /\s*(\S+)\s*;/; # prot name is before the semicolon
        next if (not (defined ($hypprotein)) or $hypprotein eq "");
        my $evalue       = $hit->significance(); # Get the e-value
        my @hsps         = @{$hit->Hit_hsps()};  # High Scoring pairs
        
        last if (scalar(@hsps) == 0); # An ORF that has a good evalue but no HSP => impossible but ...
        last if &CompareHighPrecisionFloats($evalue,$BLASTEVALUECUTOFF) == 1; # ev > $BL
        last if $hsps[0]->frac_identical() < 0.5 && &CompareHighPrecisionFloats($evalue,$SHORT_HSPS_MIN_EVALUE) == 1;
        
        my $prot = &TakeProteinFromPepfile ($fullheader, $LIB_FILE);   # Take the protein corresponding to the hit
       
        #------- Calculate a sort of frame to see what's the region covered by this ORF
        #  Story : You can have, for some case, more than one protein per gene.
        #  It's a sort of fusion protein.
        #  Each of both have a functional part
        #-----------------------------------------------------------------------------#
        # To make distinction between a protein fusion and a protein annotated as twice
        # We have to check the High Scoring Pair frame. If there is no overllapping between 
        # HSP frames, it means you have many proteins on the same frame
        # If there is, it's probably because many similar proteins corresponds to the same gene
        
        my $frame      = {};
        my ($framestart,$frameend) = ($hsps[0]->start,$hsps[0]->end);

        # We don't need to check for strand because HSP are sorted as if there were on the right strand
        foreach my $hsp (@hsps) {
            next if &CompareHighPrecisionFloats($hsp->significance,$BLASTEVALUECUTOFF) == 1; # si > BL
            $framestart     = $hsp->start if ($hsp->start < $framestart);
            $frameend       = $hsp->end   if ($hsp->end   > $frameend);
        }

        $frame -> {"start"} = $framestart;
        $frame -> {"end"}   = $frameend;

        my $isoverlapping = 0; # Indiquate if wheter or not, accept the hit as annotation of the ORF 
        CURRENTFRAME : foreach my $currentframe (@overlapping) {
            # For each strand there is 4 cases when frame are overlapping

            # 1)     |----------------|             first frame
            #               |-----------------|     second frame
            
            # 2)            |----------------|      first frame
            #        |-----------------|            second frame

            # 3)          |---------|               first frame
            #        |-----------------|            second frame

            # 4)    |-----------------|             first frame
            #         |---------|                   second frame

            #       Case were we are on the right strand
            $isoverlapping = 1 if (($currentframe->{"start"} <=  $frame -> {"start"}) and ($currentframe->{"end"} >=  $frame -> {"start"}));
            $isoverlapping = 1 if (($frame -> {"start"} <=  $currentframe->{"start"}) and ($frame -> {"end"} >=  $currentframe->{"start"}));
            $isoverlapping = 1 if (($frame -> {"start"} <=  $currentframe->{"start"}) and ($currentframe -> {"end"} <=  $frame->{"end"})); 
            $isoverlapping = 1 if (($currentframe -> {"start"} <=  $frame->{"start"}) and ($frame -> {"end"} <=  $currentframe->{"end"}));  

            last CURRENTFRAME  if $isoverlapping == 1; # Go out of the loop if there is a overlapping frame  
        }
        next HIT if ($isoverlapping == 1); # If there is an overlapping, the HIT isn't good for annotation
        push (@overlapping, $frame);

        my $neworf = new PirObject::Orf (
                                         start      => $start,
                                         startBlast => [],
                                         end        => $end,
                                         strand     => $strand,
                                         evalue     => $evalue,
                                         protein    => $prot,    # Assign the protein to the ORF 
                                         hsps       => []
                                        );

        my @start_b;
        my $refhsparray = $neworf->hsps;           # An array reference,                          
        foreach my $hsp (@hsps) {
            next if &CompareHighPrecisionFloats($hsp->significance,$BLASTEVALUECUTOFF) == 1; # si > BL
            my $newhsp = new PirObject::Hsp_query_sbjct (
                                                         start_q  => $hsp->Hsp_query_from(),
                                                         end_q    => $hsp->Hsp_query_to(),
                                                         start_s  => $hsp->Hsp_hit_from(),
                                                         end_s    => $hsp->Hsp_hit_to(),
                                                         strand   => 0,
                                                        );
            push (@$refhsparray, $newhsp);

            if ($hsp->Hsp_query_from() > $hsp->Hsp_hit_from()) {
                my $start_cor = $start + ( ($hsp->Hsp_query_from() *3) - ($hsp->Hsp_hit_from() *3) ) if $strand == 1;
                   $start_cor = $start - ( ($hsp->Hsp_query_from() *3) - ($hsp->Hsp_hit_from() *3) ) if $strand != 1;
                push (@start_b, $start_cor);
            }
        }

        my $newstartblast = $neworf->startBlast;
        my $start_bl      = ($strand == 1 ? min(@start_b) : max(@start_b));
        push (@$newstartblast, $start_bl);

        my $newflipblastprot = &GetFlipBlastProtByNameAndContigName($hypprotein, $contigname);
        
        # If we can't find it, create it once, and push it on @$FLIPBLASTPROTS
        if (! defined ($newflipblastprot)) {
            $newflipblastprot = new PirObject::FlipBlastProt (   name           => $hypprotein, # First we create the flipblast prot
                                                                 contigname     => $contigname,
                                                                 orfs           => [],
                                                                 homologous     => []
                                                                );
            if ($hypfusiongene != 0) {
                my $index = &FindIndexOfGeneFusion($start,$end,$FLIPBLASTPROTS);
                @$FLIPBLASTPROTS[$index]->set_hypfusiongene($hypprotein);
                $newflipblastprot->set_hypfusiongene(@$FLIPBLASTPROTS[$index]->get_name());
            }
            push (@$FLIPBLASTPROTS, $newflipblastprot);
        }
        $hypfusiongene++;
       
        my $ref_orf_array        = $newflipblastprot->get_orfs();
        my $ref_homologous_array = $newflipblastprot->get_homologous();
        push (@$ref_orf_array, $neworf);    #    And we just add a new orf
        my $homo = $homo_hash->{$hypprotein};
        push (@$ref_homologous_array, @$homo);
    } # End foreach $hit
} # End sub

sub TakeProteinFromPepfile {
    # This function takes a protein from the blast result with a descritpion line
    # A kind of pareser of fasta file
    my $description = shift;
    my $pepfile     = shift; # not used anymore

    $description =~ s/^>?\s*//;
    $description =~ s/\s*$//;

    # Certain XML entitites are produced by blastall's XML output,
    # but not handled by PirObject XML parser. Replace them here.
    $description =~ s/&apos;/'/g;
    $description =~ s/&quot;/"/g;

    my $protein     = $CACHE_PEPLIBRARY->{$description}
       || die "Internal error: can't find library protein with description '$description'.\n";
    
    return ">$description\n" . $protein;
} # End sub

sub GetFlipBlastProtByNameAndContigName {
    # This function gives a FlipBlastProt with his name and contig name
    my $name       = shift;  #    This the name of the GetFlipBlastProt
    my $contigname = shift;  #    This is the contigname of the FlipBlastProt

    foreach my $result (@$FLIPBLASTPROTS) {
         return $result if ($result->name eq $name and $result->contigname eq $contigname);
    }
    return undef; # In the case where any object has been found
} # End sub

sub FindIndexOfGeneFusion {
    my $start_orf        = shift;
    my $end_orf          = shift;
    my $all_prev_hypprot = shift;

    my $index = 0;
    foreach my $prot (@$all_prev_hypprot) {
        my $orfs  = $prot->get_orfs();
        foreach my $orf (@$orfs){
            my $start = $orf->get_start();
            my $end   = $orf->get_end();
            return $index if $start == $start_orf && $end == $end_orf;
        }
        $index++;
    }
}

#-----------------------------------------------------------#
# Subs for selecting hypotetical protein for identification #
# of protein with exon/intron (In order to run Exonerate)   #
#-----------------------------------------------------------#

sub Select_protein {
    # This function is create in order to selection the protein for run Exonerate or not
    my $compt = 0;
    my @index;
    foreach my $flipblastprot (@$FLIPBLASTPROTS) {
        my $name           = $flipblastprot->get_name();
        my $contigname     = $flipblastprot->get_contigname();
        my $orfs           = $flipblastprot->get_orfs();
        my $homologous     = $flipblastprot->get_homologous();
        my $genefusionname = $flipblastprot->get_hypfusiongene();
        my $number_orfs    = scalar (@$orfs);
        my %strand;  # Hashtable with the number of each strand for one flipblastprot

        next if ($number_orfs < 1); # Impossible but ..........
        
        if ($number_orfs > 1) {
            my @prot_score; # Tab for score of blast and protein
            foreach my $orf(@$orfs) {
                $strand{1}++  if $orf->strand == 1;
                $strand{-1}++ if $orf->strand == -1;
                my $info_prot_score = [$orf->evalue(), $orf->protein()];
                push (@prot_score, $info_prot_score);
            }
 
            @prot_score = sort { $a->[0] <=> $b->[0] } @prot_score; # Sort @protein_score by score
            my $prot = $prot_score[0]->[1];                         # Protein who have bigger score

            if ($strand{1} && $strand{-1}) {
                my $info = [$name, $contigname, $prot, 2, $homologous, $genefusionname];
                push(@PROT_FOR_EXONERATE, $info);
                push(@index, $compt);
            }
            elsif ($strand{1} || $strand{-1}) {
                my @start_end_orf;
                my $strand = 1 if $strand{1};
                   $strand = -1 if $strand{-1};
                foreach my $orf(@$orfs){
                    my (@start_hsp,@end_hsp) = ((),());
                    my $hsps   = $orf->get_hsps();
                    my $evalue = $orf->get_evalue();
                    foreach my $hsp(@$hsps){
                        push (@start_hsp, $hsp->start_q);
                        push (@end_hsp, $hsp->end_q);
                    }
                    my ($min_start_hsp,$max_end_hsp)  = (min(@start_hsp),max(@end_hsp)); # Give the lower start and the bigger end of hsp
                    my $cor_start = $orf->start + (3 * $min_start_hsp) if $strand ==  1; # The really start of orf if strand +
                       $cor_start = $orf->start - (3 * $min_start_hsp) if $strand == -1; # The really start of orf if strand -
                    my $cor_end   = $orf->start + (3 * $max_end_hsp)   if $strand ==  1; # The really end of orf if strand +
                       $cor_end   = $orf->start - (3 * $max_end_hsp)   if $strand == -1; # The really end of orf if strand -
                    my $pair_start_end = [ $cor_start, $cor_end, $evalue ];
                    push (@start_end_orf, $pair_start_end);
                }

                @start_end_orf  = sort { $a->[0] <=> $b->[0] } @start_end_orf if $strand ==  1; # Sort @start_end_orf by start for strand +
                @start_end_orf  = sort { $b->[0] <=> $a->[0] } @start_end_orf if $strand == -1; # Sort @start_end_orf by start for strand -
            
                for (my $i=0; $i < @start_end_orf - 1; $i++) {
                    my $diff = abs($start_end_orf[$i]->[1]-$start_end_orf[$i+1]->[0]);
                    if ( 142 <= $diff ) {
                        # if distance between 2 orf who have match with one protein is higher than 142 nt => Run exonerate
                        my $info = [$name, $contigname, $prot, $strand, $homologous, $genefusionname, [$start_end_orf[$i], $start_end_orf[$i+1]]];
                        push(@PROT_FOR_EXONERATE, $info);
                        push(@index, $compt);
                    }
                    else {
                       $flipblastprot->set_frameshift(1);
                       print "   Probable frameshift in $name\n"; 
                    }
                } # End for $i
            } # End elsif
        } # End if
        $compt++;
    } # End foreach $flipblastprot

    # In order to run exonerate only one time foreach protein
    my %index_deja_vu = ();
    my @index_uni; 
    foreach my $index (@index) {
        push(@index_uni,$index) unless $index_deja_vu{$index}++; 
    }

     my %prot_deja_vu = (); 
     my @prot_uni; 
     foreach my $prot (@PROT_FOR_EXONERATE) {
         my $ident = $prot->[1] . "-" . $prot->[2];
         push(@prot_uni,$prot) unless ($prot_deja_vu{$ident}++); 
     }

     @PROT_FOR_EXONERATE = @prot_uni; 
     @index_uni = sort {$b <=> $a} @index_uni;

     # In order to remove the protein of flipblastprot when we run Exonerate
     for (my $i=0; $i < @index_uni; $i++) {
         splice(@$FLIPBLASTPROTS,$index_uni[$i],1);
     }
} # End sub

#------------------------------------#
# Subs for identifying similar ORFs  #
#------------------------------------#

sub FillHYPPROTSArrayWithFLIPBLASTPROTSArray {
    # This function fill the HYPPROTS array (array of hypothetical proteins with
    # FLIPBLASTPROTS array (array of ORF and hsp)
     mkdir("$TMPDIR/Muscle_for_start",0700) or die "Error: can't create work directory '$TMPDIR/Muscle_for_start': $!\n";
    
    # This is mainly the algorithm given by Franz
    foreach my $flipblastprot (@$FLIPBLASTPROTS) {        # For each flip blast protein
        my $name           = $flipblastprot->get_name();
        my $contigname     = $flipblastprot->get_contigname();
        my $orfs           = $flipblastprot->get_orfs();
        my $namefusiongene = $flipblastprot->get_hypfusiongene() || undef;
        my $homologous     = $flipblastprot->get_homologous()    || undef;
        my $frameshift     = $flipblastprot->get_frameshift()    || undef;
        my $numberorfs     = scalar (@$orfs);

        next if ($numberorfs < 1); # Impossible but ..........
        
        my $contig      = $pirmaster->GetContigByName($contigname);
        my $seq         = $contig->get_sequence();

        # if there is more than one orf
        my ($neworfs,$newhypprot) = ([],undef);
        
        # Sort the orf #
        # The ORFs are classified and sorted by strand and start, stop positions
        @$orfs = sort {
            my ($stranda,$strandb) = ($a->strand,$b->strand);
            my ($evaluea,$evalueb) = ($a->evalue,$b->evalue);
            if ($evaluea != $evalueb) {
                &CompareHighPrecisionFloats($evaluea,$evaluea)
            }
            elsif ($stranda != $strandb) {
                $a->strand <=> $b->strand;
            }
            elsif ($stranda == 1) {
                $a->start  <=> $b->start;
            }
            else {
                $a->end    <=> $b->end;
            }    
        } @$orfs;    

        foreach my $orf(@$orfs) {
            # Now the thing is to create a new hyp prot if the conditions are not required
            # First : if the $currentprot is not defined 
            my $start_bl = $orf->startBlast;
            my $start_cor = ( !(@$start_bl[0]) ? $orf->start : @$start_bl[0]);

            # Case 1 : first ORF
            if (not defined($newhypprot)) {
                # Here we create a new protein
                $newhypprot = new PirObject::HypProt (
                                                      name       => $name,
                                                      contigname => $contigname,
                                                      blaststart => $start_cor,
                                                      start      => $start_cor,
                                                      end        => $orf->end,
                                                      strand     => $orf->strand,
                                                      numorfs    => 1,
                                                      protein    => $orf->protein,
                                                      evalue     => $orf->evalue(), 
                                                      exons      => [],
                                                      introns    => [],
                                                      homologous => $homologous,
                                                      idbyblast  => 1,
                                                      frameshift => $frameshift
                                                     );
                next; 
            }

            # Case 2 : not the same strand
            if ($newhypprot->strand !=  $orf->strand) {
                push (@$HYPPROTS,  $newhypprot);
                $newhypprot = new PirObject::HypProt (
                                                      name       => $name,
                                                      contigname => $contigname,
                                                      blaststart => $start_cor,
                                                      start      => $start_cor,
                                                      end        => $orf->end,
                                                      strand     => $orf->strand,
                                                      numorfs    => 1,
                                                      protein    => $orf->protein,
                                                      evalue     => $orf->evalue(),  
                                                      exons      => [],
                                                      introns    => [],
                                                      homologous => $homologous,
                                                      idbyblast  => 1,
                                                      frameshift => $frameshift
                                                     );                 
                next;
            }

            # Case 3-4 : Check space between 2 ORFs, including overlapping
            if ($orf->strand == 1) {
                # Two case : right strand or opposite strand
                if (($newhypprot->end > $orf->start) or (abs ($orf->start - $newhypprot->end) < $MAXLENGTHFORGROUPINGORF)) {
                    my $newstart = ( $orf->start < $newhypprot->start ? $orf->start : $newhypprot->start);
                    $newhypprot->set_start ($newstart);
                    
                    my $newend = ( $orf->end   > $newhypprot->end ? $orf->end : $newhypprot->end);
                    $newhypprot->set_end ($newend);

                    # Check which protein is the best
                    if (&CompareHighPrecisionFloats($orf->evalue(),$newhypprot->evalue()) == -1) {
                        $newhypprot->set_protein($orf->protein);
                        $newhypprot->set_evalue($orf->evalue());
                    }

                    # Increase from 1, the number of orf, if we concatenate
                    my $numorfs = $newhypprot->numorfs;
                    $numorfs++;
                    $newhypprot->set_numorfs($numorfs);
                    next;
                }
                else {
                    push (@$HYPPROTS,  $newhypprot);
                    $newhypprot = new PirObject::HypProt (
                                                          name       => $name,
                                                          contigname => $contigname,
                                                          blaststart => $start_cor,
                                                          start      => $start_cor,
                                                          end        => $orf->end,
                                                          strand     => $orf->strand,
                                                          numorfs    => 1,
                                                          protein    => $orf->protein,
                                                          evalue     => $orf->evalue(), 
                                                          exons      => [],
                                                          introns    => [],
                                                          homologous => $homologous,
                                                          idbyblast  => 1,
                                                          frameshift => $frameshift
                                                        );
                    next;
                }
            }
            else {
                # Opposite strand
                if (($newhypprot->start > $orf->end) or (abs ($orf->end - $newhypprot->start) < $MAXLENGTHFORGROUPINGORF)) {
                    my $newstart = ( $orf->start > $newhypprot->start ? $orf->start : $newhypprot->start);
                    $newhypprot->set_start ($newstart);
                    
                    my $newend = ( $orf->end < $newhypprot->end ? $orf->end : $newhypprot->end);
                    $newhypprot->set_end ($newend);

                    # Check which protein is the best
                    if (&CompareHighPrecisionFloats($orf->evalue(),$newhypprot->evalue()) == -1) {
                        $newhypprot->set_protein ($orf->protein);
                        $newhypprot->set_evalue($orf->evalue());
                    }

                    # Add 1 to the number of orf if there is concatenation
                    my $numorfs = $newhypprot->numorfs;
                    $numorfs++;
                    $newhypprot->set_numorfs($numorfs);
                    next;
                }
                else {
                    push (@$HYPPROTS,  $newhypprot);
                    $newhypprot = new PirObject::HypProt (
                                                          name       => $name,
                                                          contigname => $contigname,
                                                          blaststart => $start_cor,
                                                          start      => $start_cor,
                                                          end        => $orf->end,
                                                          strand     => $orf->strand,
                                                          numorfs    => 1,
                                                          protein    => $orf->protein,
                                                          evalue     => $orf->evalue(), 
                                                          exons      => [],
                                                          introns    => [],
                                                          homologous => $homologous,
                                                          idbyblast  => 1,
                                                          frameshift => $frameshift
                                                         );
                    next;
                }
            }
        }  # End for each ORF
        if ($namefusiongene) {
            my $info_gene_fusion = new PirObject::HypFusion ( name => $namefusiongene );
            $newhypprot->set_hypfusiongene($info_gene_fusion);
        }
        &AdjustStartByHMM($newhypprot, $seq, $contigname);
        push (@$HYPPROTS,  $newhypprot);
    } # End for each Flip Blast Prot
} # End sub

sub AdjustStartByHMM {
    my ($hypprot,$seq,$contigname) = @_;
    
    $seq = uc($seq);
    my $isMinus     = $hypprot->get_strand() == 1 ? 0 : 1;
    my $arrow       = $isMinus ? "<==" : "==>";
    my $start       = $hypprot->get_start();
    my $old_start   = $hypprot->get_blaststart() || $start;
    my $end         = $hypprot->get_end();
    my $exons       = $hypprot->get_exons();
    my $introns     = $hypprot->get_introns();
    my $WithIntrons = (scalar(@$exons) > 1 ? 1 : 0);
    
    # Def this_prot
    my $prot = $hypprot->get_name();
    my $this_prot = &GetProteinForGeneWithoutIntrons($seq, $start, $end, $isMinus)  if !$WithIntrons;
       $this_prot = &GetProteinSequenceAndIntronsPos($exons,$introns,$seq,$hypprot) if  $WithIntrons;
    $hypprot->set_thisprot($this_prot);
    
    if ($this_prot eq "Frame-Shift-Detected") {
        $hypprot->set_startwarning("Aproximative start");
        return;
    }

    # Def Full5
    my $full5 = &GetFull5($seq,$isMinus,$this_prot,$start);
    $hypprot->set_full5($full5);
    my $hyp_st_full5 = length($full5) - length($this_prot);
    
    # Create Seq for HMM and run HMM
    my $SeqFasta = &ExtractLibSeqs($hypprot,$this_prot);
    my $flag     = $1 if  scalar($hypprot) =~ m/0x(.+)\)/;
    my $protaln  = &RunHMM("${prot}_$flag",$SeqFasta);
    
    # Read ali and def each startin homologous
    my $ali        = &ReadStockholmMultAligns($protaln);
    my $each_st    = &DefEachStartInHMM($ali);
    my $hyp_st_ali = $each_st->{"myProt"};
    delete $each_st->{"myProt"};

    # Def lim of reaseach in Full5
    my $st_pos_cmp_st_orf = {};
    while (my ($id, $homo_st_ali) = each(%$each_st)) {
        $st_pos_cmp_st_orf->{$id} = $hyp_st_full5 + ($homo_st_ali - $hyp_st_ali);
    }
    my ($right_lim_for_st,$left_lim_for_st) = &DefMaxAndMinStartInAli($st_pos_cmp_st_orf);
    
    # Def first exon if gene with intron(s).
    my $first_exon = undef;
    if ($WithIntrons) {
           $first_exon      = $exons->[0];
        my $end_first_exon  = $first_exon->get_protend();
           $full5           = substr($full5,0,$end_first_exon+(length($full5)-length($this_prot)))
    }
    
    my $aa_accepted          = { "M" => 1, "v" => 1, "l" => 1};
    my $all_possible_st      = &DefineAllPossibleStart($full5, $right_lim_for_st,$aa_accepted);
    my ($best_start,$median) = &ChooseBestStart($st_pos_cmp_st_orf,$all_possible_st,$right_lim_for_st);

    # If no M or v was found A def par similarite !!!
    my ($firstMaj,$StartInMyProt) = &DefFirstMaj($ali,$prot);
    my $SimiStart  = ($firstMaj - $StartInMyProt);
       $SimiStart  = $hyp_st_full5 + $SimiStart < 0 ? -$hyp_st_full5 : $SimiStart;
    
    # If no M or v was found
    if (!(defined $best_start)) {
        &ChangeHypProtVal($hypprot, $SimiStart, $isMinus, $seq);
        $hypprot->set_startwarning("Def by similarity no start found");
        return;
    }

    # Add info about alternative start
    my $first_M = undef;
    foreach my $st_pos (sort { $a <=> $b } keys %$all_possible_st) {
        next if $all_possible_st->{$st_pos}->{"aa"} ne "M";
        $first_M = $st_pos;
        last;
    }

    my $alt_start = $first_M    - $hyp_st_full5 if $first_M;
    my $new_start = $best_start - $hyp_st_full5;

    if ( defined($alt_start) && $alt_start != $new_start) {
        my $alternative_st_in_seq = $isMinus ? ($old_start - ($alt_start*3)) : ($old_start + ($alt_start*3));
        $hypprot->set_altstart($alternative_st_in_seq);
    }

    # Annotate similary start if 1st start is too up or down.
    # and add First start info in HypProt
    if (abs($best_start-$right_lim_for_st) > 2 && $best_start > $right_lim_for_st) {
        my $FirstStart = $isMinus ? ($old_start - ($new_start*3)) + 1 : ($old_start + ($new_start*3));
        if ($best_start > $right_lim_for_st){
            &ChangeHypProtVal($hypprot, $SimiStart, $isMinus, $seq);
            $hypprot->set_startwarning("Def by similarity");
            $hypprot->set_FirstStart($FirstStart);
        } else {
            &ChangeHypProtVal($hypprot, $new_start, $isMinus, $seq);
        }
    } else {
        my $FirstStart = $isMinus ? ($old_start - ($new_start*3)) + 1 : ($old_start + ($new_start*3)); 
        if ($best_start < $left_lim_for_st-10) {
            &ChangeHypProtVal($hypprot, $SimiStart, $isMinus, $seq);
            $hypprot->set_startwarning("Def by similarity");
            $hypprot->set_FirstStart($FirstStart);
        } else {
            &ChangeHypProtVal($hypprot, $new_start, $isMinus, $seq);
        }
    }
    return if !$WithIntrons;
    &SearchForEndIfGeneHaveIntron($hypprot,$exons,$isMinus,$seq);
}

sub ExtractLibSeqs {
    my ($hypprot,$this_prot)  = @_;
    
    my $fulltext = "";
    my $fasta = ">myProt\n";
    while ($this_prot ne "") {
            $this_prot    =~ s/[^a-zA-Z]//g;
            $this_prot    = uc($this_prot);
            my $slice  = length($this_prot) > 60 ? 60 : length($this_prot);
            $fasta    .= substr($this_prot,0,$slice)."\n";
            $this_prot = substr($this_prot,$slice);
    }
    $fulltext .= $fasta;
    
    my $homologous = $hypprot->get_homologous();
    my $name = "a";
    foreach my $prot (@$homologous) {
        my $seq = $prot->get_similarprot();
        my $fasta = ">$name\n";
        $seq =~ s/>.+\n//;
        while ($seq ne "") {
            $seq =~ s/[^a-zA-Z]//g;
            $seq = uc($seq);
            my $slice = length($seq) > 60 ? 60 : length($seq);
            $fasta .= substr($seq,0,$slice)."\n";
            $seq = substr($seq,$slice);
        }
        $fulltext .= $fasta;
        $name++;
    }
    return $fulltext;
}

sub RunHMM {
    my ($ShortName,$SeqFasta,$Sup) = @_;
    $Sup = $Sup || "";
    
    my $Dir = "$TMPDIR/HMM$Sup";
    unless(-d "$Dir"){ mkdir "$Dir" or die "Cannot create '$Dir'";}
    # unless(-d "$TMPDIR/Outputs$sup"){ mkdir "$TMPDIR/Outputs$sup" or die "Cannot create '$TMPDIR/Outputs$sup'";}
    my $ProtIn  = "$Dir/$ShortName.seq";
    my $ProtOut = "$Dir/$ShortName.pir";
    my $AliOut  = "$Dir/$ShortName.sto";
    my $ProtHMM = "$Dir/$ShortName.hmm";
    my $ProtAln = "$Dir/$ShortName.aln";
    
    # Create input file
    my $InFh = new IO::File ">$ProtIn"
        or die "Can't write to file '$ProtIn': $!\n";
    print $InFh $SeqFasta;
    $InFh->close();
    
    # 1. Run Muscle... 
    my $cmd = "$MUSCLEPATH -stable -in '$ProtIn' -out '$ProtOut' >/dev/null 2>/dev/null";
    print "\n$cmd\n" if $DEBUG;

    my $resultat = system("$cmd");
    my $hascoredump = ($resultat & 128) >> 7;  # 0 if no core dump, 1 if core dump
    my $signal      = $resultat & 127;  # SIGNAL received by subprocess, from 0 to 127;
    my $returncode  = $resultat >> 8;   # exit status of subprogram
    if ($returncode > 1 || $signal > 0 || $hascoredump == 1) {
        print "Error in execution of Muscle in sub RunHMM...\n";
    }
    
    # 2. Run Umac...
    $cmd = "$UMAC_EXE -i '$ProtOut' -o '$AliOut' -f stockholm >/dev/null 2>/dev/null";
    print "\n$cmd\n" if $DEBUG;
    
    $resultat = system("$cmd");
    $hascoredump = ($resultat & 128) >> 7;  # 0 if no core dump, 1 if core dump
    $signal      = $resultat & 127;  # SIGNAL received by subprocess, from 0 to 127;
    $returncode  = $resultat >> 8;   # exit status of subprogram
    if ($returncode > 1 || $signal > 0 || $hascoredump == 1) {
        print "Error in execution of Umac in sub RunHMM...\n";
    }
    
    # 3. Run HMMBuild...
    $cmd = "$HMMBUILD_EXE $ProtHMM $AliOut >/dev/null 2>/dev/null";
    print "\n$cmd\n" if $DEBUG;
    
    $resultat = system("$cmd");
    $hascoredump = ($resultat & 128) >> 7;  # 0 if no core dump, 1 if core dump
    $signal      = $resultat & 127;  # SIGNAL received by subprocess, from 0 to 127;
    $returncode  = $resultat >> 8;   # exit status of subprogram
    if ($returncode > 1 || $signal > 0 || $hascoredump == 1) {
        print "Error in execution of HMMBuild in sub RunHMM...\n";
    }
    
    # 4. Run HMMAlign...
    $cmd = "$HMMALIGN_EXE --outformat stockholm -o $ProtAln $ProtHMM $ProtIn >/dev/null 2>/dev/null";
    print "\n$cmd\n" if $DEBUG;
    
    $resultat = system("$cmd");
    $hascoredump = ($resultat & 128) >> 7;  # 0 if no core dump, 1 if core dump
    $signal      = $resultat & 127;  # SIGNAL received by subprocess, from 0 to 127;
    $returncode  = $resultat >> 8;   # exit status of subprogram
    if ($returncode > 1 || $signal > 0 || $hascoredump == 1) {
        print "Error in execution of HMMAlign in sub RunHMM...\n";
    }
    
    return $ProtAln;
}


sub ReadStockholmMultAligns {
    my $infile  = shift;
    my $content = [];
    
    # Read input file. This is a memory hungry slurp.
    my $alifh = new IO::File "<$infile" 
        or die "Cannot read from input file '$infile': $!\n";
    my $text = [<$alifh>]; # slurp
    $alifh->close();
    
    # Separate all block 
    my $each_block = {};
    my $block      = ();
    my $i          = 0;
    while (@$text) {
        my $line   = shift(@$text);
        my $isLast = 1 if scalar(@$text) == 0;
        if ($line !~ m/^\n$/ && !$isLast) {
            push(@$block,$line);
        }
        else {
            $each_block->{$i} = $block;
            $block = ();
            $i++;
        }
    }
    
    # Treat block by block.
    my %global_seenids    = ();
    my $nb_block_with_seq = 0;
    my $info              = {};
    my $seqlist           = [];
    my $seqobj            = undef;
    my ($PP_cons,$RF)     = ("","");
    
    my @sorted = ();
    while (my ($key, $value) = each( %$each_block)){push (@sorted,$key);}
    @sorted = sort { $a <=> $b } @sorted;
    
    foreach my $key (@sorted) {
        $block  = $each_block->{$key};
        my $nb_seq = 0;
        my %seenids = ();
        for (my $i = 0; $i < @$block; $i++) {
            my $line = $block->[$i];
            #Treat #=GC
            if ($line =~ m/#=GC\s*/) {
                my @split = split(/\s+/, $line);
                $PP_cons .= $split[-1] if $line =~ m/PP_cons/;
                $RF      .= $split[-1] if $line =~ m/RF/;
            }
            
            # Treat sequence 
            next if $line =~ m/^#/;
            my @split_line  = split(/\s+/, $line);
            my ($name,$seq) = @split_line;
            my $id = $name && $name =~ m/(.+)\// ? $1 : $name;
            $nb_seq++;
            $seenids{$id}++;
            $global_seenids{$id}++;
            
            my $begin_seq = $info->{$id}->{$seenids{$id}}->{seq};
            $seq = defined($begin_seq) ? "${begin_seq}$seq": $seq;
            $info->{$id}->{$seenids{$id}}->{seq} = $seq;

            # Treat #GR if next $line =~ m/^#=GR/
            my $next_line       = $block->[$i+1];
            next if !$next_line;
            next if $next_line  !~ m/^#=GR/;
            my @split_next_line = split(/\s+/, $next_line);
            my ($tag,$name_next,$feat,$mark)  = @split_next_line;
            my $id_next = $name_next && $name_next =~ m/(.+)\// ? $1 : $name_next;
            print "$name doesn't match with #=GR PP line\n" if $id_next ne $id;
            next if $feat ne "PP";
            my $begin_PP = $info->{$id}->{$seenids{$id}}->{PP};
            my $PP = defined($begin_PP) ? "${begin_PP}$mark": $mark;
            $info->{$id}->{$seenids{$id}}->{PP} = $PP;
        }
        $nb_block_with_seq++ if $nb_seq != 0;
    }

    while ( my ($id, $value) = each(%global_seenids) ) { 
          my $mod   = $value % $nb_block_with_seq;
          die "Sequence $id not present in all block\n" if $mod != 0;
    }
    
    my $length_stand = 0;
    for my $id ( keys %$info ) {
        my $info_for_id = $info->{$id};
        my $nb_dupli    = scalar( keys %$info_for_id);

        for my $num_dupli ( keys %$info_for_id ) {
            my $info_for_dupli = $info_for_id->{$num_dupli};
            my $id  = $nb_dupli == 1 ? $id : "${num_dupli}${id}";
            my $seq = $info_for_dupli->{seq};
            my $PP  = $info_for_dupli->{PP};
            my $length_PP    = length($PP) if $PP;
            my $length_seq   = length($seq);
            $length_stand = $length_seq if $length_stand == 0;
            die "PP and sequence haven't same length for $id\n" 
                if $PP && $length_PP != $length_seq;
            die "$id haven't standard length\n" 
                if $length_seq != $length_stand;
            $seqobj = new PirObject::AlignedSeq(
                seqId        => $id,
                sequence     => $seq,
                PP           => $PP,
            );
            push(@$seqlist,$seqobj);
        }
    }
    my $length_PP_cons  = length($PP_cons);
    die "PP_cons haven't standard length\n"
        if $length_PP_cons && $length_PP_cons != $length_stand;
    
    $text = []; # Zap input array text, free memory
            
    my $ma = new PirObject::MultAlign(
        alignedSeqs => $seqlist,
        PP_cons     => $PP_cons,
    );
    push(@$content,$ma);
    return $content;
}

sub DefEachStartInHMM {
    my $align = shift;
    
    my $each_start = {};
    my $multalign     = $align->[0];
    my $alignedSeqs   = $multalign->get_alignedSeqs();
    foreach my $alignedSeq (@$alignedSeqs) {
        my $id    = $alignedSeq->get_seqId();
        my $seq   = $alignedSeq->get_sequence();
        my $dash_seq = $seq;
           $dash_seq =~ s/\./\-/g;
        my $dash_chain = $1 if $dash_seq =~ m/^(-*)/;
        my $len_dash   = length($dash_chain);
        $each_start->{$id} = $len_dash;
    }
    return $each_start;
}

sub DefFirstMaj {
    my ($ali,$prot) = @_;
    
    my $FirstMajs = ();
    my $multalign     = $ali->[0];
    my $alignedSeqs   = $multalign->get_alignedSeqs();
    my $StartInMyProt = "";
    foreach my $alignedSeq (@$alignedSeqs) {
        my $id  = $alignedSeq->get_seqId();
        next if $id ne "myProt";
        my $seq = $alignedSeq->get_sequence();
        for ( my $i = 0 ; $i < length($seq) ; $i++) {
            my $char = uc(substr($seq,$i,1));
            next if $char !~ m/[A-Z]/;
            $StartInMyProt = $i  if $id eq "myProt";
            last;
        }
    }
    
    foreach my $alignedSeq (@$alignedSeqs) {
        my $id  = $alignedSeq->get_seqId();
        next if $id eq "myProt";
        my $seq = $alignedSeq->get_sequence();
        for ( my $i = 0 ; $i < length($seq) ; $i++) {
            my $char = substr($seq,$i,1);
            next if $char !~ m/[A-Z]/;
            push(@$FirstMajs,$i);
            last;
        }
    }
    
    return (-1,$StartInMyProt) if !$FirstMajs;
    @$FirstMajs  = sort { $a <=> $b } @$FirstMajs;
    my $FirstMaj = $FirstMajs->[0];
    return ($FirstMaj,$StartInMyProt);
}

sub GetProteinForGeneWithoutIntrons {
    my ($seq, $start, $end, $isMinus) = @_;
    
    # 1. Make hyp prot def by blast
    my $g_length =  !$isMinus ? $end - $start + 1 : $start - $end + 1;
    my $nt_seq   =  !$isMinus ? substr($seq, $start - 1 , $g_length) : substr($seq, $end - 1 , $g_length);
       $nt_seq   =~ tr/ACGT/TGCA/    if $isMinus;
       $nt_seq   = reverse $nt_seq   if $isMinus;
   
    my $protein    = "";
    foreach (my $i = 0; $i <= length($nt_seq) - 3; $i += 3) {
        my $tri_nt   = uc (substr($nt_seq, $i , 3));
        my $aa       = $CODON_TABLE->{$tri_nt} || "X";
           $aa       = lc($aa) if $tri_nt eq "GTG" && $CODON_TABLE->{$tri_nt} eq "V";
           $aa       = lc($aa) if $tri_nt eq "TTG"; 
           $protein .= $aa;
    }
    return $protein;
}

sub GetFull5 {
    my ($seq, $isMinus, $prot_seq, $start) = @_;
    
    my $use_seq =  $seq;
    $use_seq =~ tr/ACGT/TGCA/    if $isMinus;
    $use_seq =  reverse $use_seq if $isMinus;
    
    my $full_5  = $prot_seq;
    $prot_seq   = uc($prot_seq);
    my $len_seq = length($seq);
       $start   = $len_seq - $start + 1 if $isMinus;
       
     my $shift  = -3;
     my $tail_5 = [];
     for (my $currentpos = $start - 3; ; $currentpos += $shift) {
         last if $currentpos < 1;
         my $tri_nt = uc (substr($use_seq, $currentpos - 1,3));
         my $aa     = $CODON_TABLE->{$tri_nt};
         $aa        = lc($aa) if $tri_nt eq "GTG" && $CODON_TABLE->{$tri_nt} eq "V";
         $aa        = lc($aa) if $tri_nt eq "TTG"; 
         last if $aa eq "*";
         push(@$tail_5, $aa);
     }
    @$tail_5  = reverse(@$tail_5);
    my $tail  = join("",@$tail_5);
    $full_5   = $tail.$full_5;
    return $full_5;
}

sub DefEachStartInAli {
    my $align = shift;
    
    my $each_start = {};
    foreach my $seq ($align->each_seq) {
        my $id             = $seq->display_id();
        my $sequence       = $seq->seq();
        my $dash_chain     = $1 if $sequence =~ m/^(-*)/;
        my $len_dash       = length($dash_chain);
        $each_start->{$id} = $len_dash;
    }
    return $each_start;
}

sub DefMaxAndMinStartInAli {
    my $each_start = shift;
    
    my ($max_start,$min_start)  = (0,999999);
    while ( my ($seq_id, $val) = each(%$each_start) ) {
        $max_start = $val if $val > $max_start;
        $min_start = $val if $val < $min_start;
    }
    return ($max_start,$min_start);
}

sub DefineAllPossibleStart {
    my $full5               = shift;
    my $right_lim_for_start = shift;
    my $aa_accepted         = shift;
    
    my $all_possible_start = {};
    my @t_full5 = split(//, $full5);
    
    for (my $i = 0 ; $i <= $#t_full5 ; $i++) {
        my $aa = $t_full5[$i];
        next if !$aa_accepted->{$aa};
        $all_possible_start->{$i}->{"aa"} = $aa;
    }
    return $all_possible_start;
}

sub ChooseBestStart {
    my ($each_st,$all_possible_st,$right_lim_for_st) = @_;
    
    # No start was found before last start in alignment
    my $best_start  = undef;
       $best_start  = &ChooseStartIfTooFar($all_possible_st,$right_lim_for_st);
    my $median      = &Median($each_st);
    return ($best_start,$median) if $best_start;
    
    foreach my $st_pos (sort { $a <=> $b } keys %$all_possible_st) {
        #xxxxxxx attention + 2 doit etre ici d une variable.
        delete $all_possible_st->{$st_pos} if $st_pos > ($right_lim_for_st + 2);
    }
    my $aa_accepted = ["M","v","l"];
    my $alt_start   = undef;
    my $min_diff    = 100000;
    foreach my $aa (@$aa_accepted) {
        &AddInfoForPosStart($each_st,$all_possible_st,$aa);
        my $nb_homo  = scalar(keys %$each_st);
        my $diff     = "";
        
        # Start is defined with close homologous.
        $alt_start   = &ChooseStartWithCloseHomo($all_possible_st,$nb_homo);
        if (defined $alt_start) {
            $best_start = $alt_start if !(defined $best_start);
            my $diff    = $all_possible_st->{$alt_start}->{"min"};
            $min_diff   = $diff if $diff < $min_diff;
            if ($best_start != $alt_start) {
                $best_start = $alt_start if $diff <= $min_diff;
            }
        }
        next if $alt_start;
        
        # Start is defined with median.
        $alt_start   = &ChooseStartWithAllHomo($each_st,$all_possible_st,$median,$aa);
        next if !(defined $alt_start); # Normally this situation can't be happened.
        $best_start  = $alt_start if !$best_start;
        $diff        = abs($median - $alt_start);
        $min_diff    =  $diff if $diff < $min_diff;
        if ($best_start != $alt_start) {
                $best_start = $alt_start if $diff <= $min_diff && $alt_start < $best_start;
        }
    }
    return ($best_start,$median);
}

sub ChooseStartIfTooFar {
    my ($all_possible_st,$limite) = @_;
    
    foreach my $st_pos (sort { $a <=> $b } keys %$all_possible_st) {
        return $st_pos if $st_pos > $limite;
        last;
    }
    return undef;
}

sub AddInfoForPosStart {
    my $each_st         = shift;
    my $all_possible_st = shift;
    my $aa_accepted     = shift;
    
    while (my ($id, $st_homo) = each(%$each_st)) {
        next if $id gt "d";
        my $close_hyp_st = undef;
        my $min_diff  = 100000;  #very hight value
        foreach my $st_pos (sort { $a <=> $b } keys %$all_possible_st) {
            my $aa   = $all_possible_st->{$st_pos}->{"aa"};
            delete  $all_possible_st->{$st_pos}->{"count"} if $aa ne $aa_accepted 
                                                           && $all_possible_st->{$st_pos}->{"count"};
            next if $aa ne $aa_accepted;
            my $diff = abs($st_homo-$st_pos);
            ($close_hyp_st,$min_diff) = ($st_pos,$diff) if $diff < $min_diff;
        }
        next if !(defined $close_hyp_st);
        next if $all_possible_st->{$close_hyp_st}->{"aa"} ne $aa_accepted;
        $all_possible_st->{$close_hyp_st}->{"count"}++;
        $all_possible_st->{$close_hyp_st}->{"min"}  = $min_diff if ( (not defined ($all_possible_st->{$close_hyp_st}->{"min"}))
                                                                   || $min_diff <= $all_possible_st->{$close_hyp_st}->{"min"});
    }
}

sub ChooseStartWithCloseHomo {
    my $all_possible_st = shift;
    my $nb_homo         = shift;
         
    while ( my ($st_pos, $hash) = each(%$all_possible_st) ) {
        my ($aa,$count) = ($hash->{"aa"},$hash->{"count"});
        next if !$count;
        if ($nb_homo >= 4) {
           return $st_pos if $count >= 3;
        }
        elsif ($nb_homo == 2 || $nb_homo == 3) {
            return $st_pos if $count >= 2;
        }
        elsif ($nb_homo == 1) {
            return $st_pos if $count >= 1;
        }
    }
    return undef;
}

sub ChooseStartWithAllHomo {
    my $each_st         = shift;
    my $all_possible_st = shift;
    my $median          = shift;
    my $aa_accepted     = shift;
    
    foreach my $st_pos (sort (keys(%$all_possible_st))) {
        delete $all_possible_st->{$st_pos}->{"count"};
    }
    
    my $close_hyp_st = undef;
    my $min_diff     = 100000;  # very hight value
    foreach my $st_pos (sort { $a <=> $b } keys %$all_possible_st) {
        my $aa   = $all_possible_st->{$st_pos}->{"aa"};
        delete $all_possible_st->{$st_pos}->{"min"};
        delete $all_possible_st->{$st_pos}->{"count"};
        next if $aa ne $aa_accepted;
        my $diff = abs($median-$st_pos);
        ($close_hyp_st,$min_diff) = ($st_pos,$diff) if $diff < $min_diff;
    }
    return $close_hyp_st;
}

sub Median {
    my $each_st = shift;
    
    my @all_pos = ();
    while ( my ($id, $pos) = each(%$each_st) ) {
        push(@all_pos,$pos);
    }
    @all_pos = sort { $a <=> $b } @all_pos;
    my $median   = "";
    my $nb_elem  = scalar(@all_pos);
    my $last_ind = $nb_elem - 1;
    if ($nb_elem == 1) {
        $median = $all_pos[0];
    }
    elsif (($nb_elem % 2) == 0) {
        $median = $all_pos[($last_ind / 2)];
    }
    else {
        $median = int ( $all_pos[int($last_ind / 2)] 
                    + (($all_pos[int($last_ind / 2) + 1] 
                      - $all_pos[int($last_ind / 2)]) / 2));
    }
    $median = $median >= 0 ? $median : 0;
    return $median;
}

sub ChangeHypProtVal {
    my $hypprot    = shift; 
    my $new_start  = shift;
    my $isMinus    = shift;
    my $seq        = shift;
    
    my $old_start  = $hypprot->get_start;
    my $end        = $hypprot->get_end;
    my $name       = $hypprot->get_name;
    my $new_st_pos = $isMinus ? ($old_start - ($new_start*3)): ($old_start + ($new_start*3));
    $new_st_pos = length($seq) if $new_st_pos > length($seq);
    $new_st_pos = 0 if $new_st_pos < 0;
    my $exons      = $hypprot->get_exons();
    my $first_exon = $exons->[0] if scalar(@$exons);
    $first_exon->set_dnastart($new_st_pos) if $first_exon;
    $hypprot->set_start($new_st_pos);
    
    # 1. Def tri_nt start
    my $start = $new_st_pos;
    my $g_length =  !$isMinus ? $end - $start + 1 : $start - $end + 1;
    my $nt_seq   =  !$isMinus ? substr($seq, $start - 1 , $g_length) : substr($seq, $end - 1 , $g_length);
       $nt_seq   =~ tr/ACGT/TGCA/    if $isMinus;
       $nt_seq   = reverse $nt_seq   if $isMinus;
    my $tri_nt   = uc (substr($nt_seq, 0 , 3));
    $START_COUNT->{$tri_nt}++;
}

sub SearchForEndIfGeneHaveIntron {
    my $hypprot     = shift;
    my $exons       = shift;
    my $isMinus     = shift;
    my $seq         = shift;
    
    my $len_seq    = length($seq);
    my $first_exon = $exons->[0];
    my $end_exon   = $exons->[-1];
    my $end_e      = $end_exon->get_dnaend();

    if (!$isMinus) {
        for (my $i = -3;; $i += 3) {
            last if $end_e + $i > $len_seq -3;
            my $tri_nt  = uc (substr($seq, $end_e + $i, 3));
            my $codon   = $CODON_TABLE->{$tri_nt};
            next if $codon ne "*";
            my $new_end = $end_e + $i + 3;
            $end_exon->set_dnaend($new_end);
            $hypprot->set_end($new_end);  # Set the new end to the protein
            last; 
        }
    }
    elsif ($isMinus) {
        for (my $i = 0;; $i -= 3) {
            last if $end_e +$i-1 < 0;
            my $tri_nt = uc (substr($seq, $end_e + $i - 1 , 3));
               $tri_nt =~ tr/ATUGCatugc/TAACGTAACG/;
               $tri_nt = reverse ($tri_nt);# Reverse and complementary
            my $codon  = $CODON_TABLE->{$tri_nt};
            next if $codon ne "*";
            my $new_end = $end_e + $i;
            $end_exon->set_dnaend($new_end);
            $hypprot->set_end($new_end);       # Set the new end to the protein
            last; 
        }
    }
}

#-----------------------------------------#
# Subs for internal structure prediction  #
#-----------------------------------------#

sub FindExonsInHypProtArray {
    # The main is to find exons by making a local alignement
    mkdir("$TMPDIR/Exonerate",0700) or die "Error: can't create work directory '$TMPDIR/Exonerate': $!\n";
    mkdir("$TMPDIR/Intron",0700) or die "Error: can't create work directory '$TMPDIR/Intron': $!\n";
    for (my $i=0; $i < @PROT_FOR_EXONERATE ; $i++) {

        my $info = $PROT_FOR_EXONERATE[$i]; # table with values for each prot
        my ($name, $contigname, $protein, $strand, $homologous, $namefusiongene) = @$info;

        # In order to have the contig sequence
        my $contig  = $pirmaster->GetContigByName($contigname)
            or die "Internal error: can't find contig named '$contigname'.\n";
        my $dna_seq = $contig->get_sequence();
           $dna_seq = uc($dna_seq);
        my $seq     = ">sequence\n$dna_seq";

        my $length = 0;
        my @tab_prot = split(/\n/, $protein);  # check this, it may not work properly
        for (my $i = 0 ; $i <= $#tab_prot ; $i++) {
            my $line = uc $tab_prot[$i];
            next if $line =~ /^>/;
            $line =~ tr/A-Z//cd;
            $length += length($line);
        }
        my $overlappe_authorized = ((5*$length)/100);

        # Write protein and gene in fasta files
        my $fileprot      = "$TMPDIR/Exonerate/prot_for_exonerate_${i}_${name}";
        my $filecontig    = "$TMPDIR/Exonerate/gene_for_exonerate_${contigname}";
        my $exonerate_out = "$TMPDIR/Exonerate/exonerate_${i}_${name}";

        # Check if it exists
        unlink($fileprot)      or die "Impossible to delete $fileprot\n"      if (-f $fileprot);
        unlink($exonerate_out) or die "Impossible to delete $exonerate_out\n" if (-f $exonerate_out);

        # Create protein for exonerate
        my $FILEPROT = new IO::File ">$fileprot" or die "Impossible to open $fileprot\n";
        print $FILEPROT $protein, "\n";
        $FILEPROT->close() or die "Impossible to close $fileprot\n";

        # Create genome for exonerate
        if (! -f $filecontig) {
            my $FH = new IO::File ">$filecontig" or die "Impossible to open $filecontig\n";
            print $FH $seq, "\n";
            $FH->close() or die "Impossible to close $filecontig\n";
        }

        my $cmd = "$EXONERATEPATH $Exonerate_parameter --geneticcode $GENCODE $fileprot '$filecontig' > $exonerate_out"; # $Exonerate_parameter $fileprot $filecontig
        print "\n$cmd\n" if $DEBUG;

        my $resultat = system("$cmd");
        
        my $hascoredump = ($resultat & 128) >> 7;  # 0 if no core dump, 1 if core dump
        my $signal      = $resultat & 127;  # SIGNAL received by subprocess, from 0 to 127;
        my $returncode  = $resultat >> 8;   # exit status of subprogram
        if ($returncode > 1 || $signal > 0 || $hascoredump == 1) {
            print "Error in execution of Exonerate \n";
        }

        my $infh  = new IO::File "<$exonerate_out"
            or die "Can't read from file '$exonerate_out': $!\n";
        my @tab   = <$infh>;
        $infh->close();

        my $flobj = new PirObject::ExonerateOutput();
        $flobj->FillFeaturesFromTextOutput(\@tab);

        my $ExoReports      = $flobj->report;   # One report contain information about one C4 section present in exonerate Output
        my $grouped_reports = &SortAndGroupC4Report($ExoReports,$overlappe_authorized);
        
        my %group_len_covered = ();
        foreach my $groupref (@$grouped_reports) {
           my $covered = 0;
           foreach my $report (@$groupref) {
               my $cover = abs($report->query_stop() - $report->query_start()) + 1;
               $covered += $cover;
           }
           $group_len_covered{$groupref} = $covered;
        }
        
        @$grouped_reports = sort { $group_len_covered{$b} <=> $group_len_covered{$a}
                                                         ||
                                             scalar(@$a) <=> scalar(@$b)     
                                } @$grouped_reports;

        foreach my $group (@$grouped_reports) {
            my @exon_start_end = ();                                  # Tab with information about start and end of all exons present in Exonerte Output
            my %strand;
            foreach my $report (@$group) {
                my $features                 = $report->dnafeatures;  # $features contains all information present in the part GFF DNA per lines
                my $query_range              = $report->query_range;
                my $raw_score                = $report->raw_score;
                my ($start_query,$end_query) = ($query_range =~ m#(\d+)\s*->\s*(\d+)#);
                
                my $num_exon = 0;
                foreach my $lineobj (@$features) {
                    my $feat = $lineobj->feature;
                    next if $feat ne "exon";
                    my $strand_exon = $lineobj->strand;
                    $strand{1}++  if $strand_exon eq "+";         # Just in order to know if we have a transpliced gene
                    $strand{-1}++ if $strand_exon eq "-";
                    $num_exon++;
                 }

                 my $count_exon = 0;
                 foreach my $lineobj (@$features) {
                     my $feat        = $lineobj->get_feature();
                     next if $feat ne "exon";
                     
                     my $strand_exon = $lineobj->get_strand();
                     my $start       = ($strand_exon eq "-" ? $lineobj->get_end()   : $lineobj->get_start());
                     my $end         = ($strand_exon eq "-" ? $lineobj->get_start() : $lineobj->get_end());
                     my $attributes  = $lineobj->get_attributes();
                     my $info  = [$start,$end,$strand_exon,$start_query,$attributes,$end_query,$raw_score];
                     push(@exon_start_end, $info);           
                     # @exon_start_end contain information about exon with start end and strand of each exons
                     $count_exon++;
                 }
             }
                          
             if ($strand{1} && $strand{-1}) {
                 # If we have a transpliced gene 
                 &Add_comment_for_transpliced($contigname,$name,\@exon_start_end);
                 $add_text_in_header .= ";; Gene coding for $name is probably transpliced (see annotation in comments)\n";
                 next;
             }

             my $isMinus = (($strand{1} && !$strand{-1}) ? 0 : 1);
             @exon_start_end = sort {    ($a->[3] <=> $b->[3])
                                     ||  ($a->[0] <=> $b->[0])} @exon_start_end if $isMinus == 0; # Sort exons_start_end by start strand-

             @exon_start_end = sort {    ($a->[3] <=> $b->[3]) 
                                     ||  ($b->[0] <=> $a->[0])} @exon_start_end if $isMinus == 1; # Sort exons_start_end by start strand+
             
             # Correction about start and end of exon if two exons is overlapping #
             my @exon_start_end_cor =();                                             # Correction about start and end of exon if two exons is overlapping 
             for (my $i = 0; $i < (@exon_start_end-1); $i++) {
                 if ($isMinus == 0) {
                     if (!( ($exon_start_end[$i]->[1] + 1 < $exon_start_end[$i+1]->[0]) || ($exon_start_end[$i+1]->[1] + 1 < $exon_start_end[$i]->[0]) )) {  
                         # Take the minus start and the bigger stop if exons is on strand +
                         my $boolean = (($exon_start_end[$i]->[1] + 1 >= $exon_start_end[$i+1]->[0]) == 1 ? 0 : 1);
                         my $start   = $exon_start_end[$i]->[0]   if !$boolean; # if E1_end > E2_start
                         my $end     = $exon_start_end[$i+1]->[1] if !$boolean; # if E1_end > E2_start
                            $start   = $exon_start_end[$i+1]->[0] if  $boolean; # if E2_end > E1_start
                            $end     = $exon_start_end[$i]->[1]   if  $boolean; # if E2_end > E1_start
                         my $strand_exon = $exon_start_end[$i]->[2];
                         my $start_query = $exon_start_end[$i]->[3];
                         my $raw_score   = $exon_start_end[$i]->[6];
                         my $info = [$start,$end,$strand_exon,$i,$start_query,$raw_score]; # Start, End, Strand and Index
                         push(@exon_start_end_cor, $info);
                     }
                 }

                elsif ($isMinus == 1) {
                    if (!( ($exon_start_end[$i+1]->[0] + 1 < $exon_start_end[$i]->[1]) || ($exon_start_end[$i]->[0] + 1 < $exon_start_end[$i+1]->[1]) )) { 
                        # Take the minus start and the bigger stop if exons is on strand +
                        my $boolean = (($exon_start_end[$i+1]->[0] + 1 >= $exon_start_end[$i]->[1]) == 1 ? 0 : 1);
                        my $start   = $exon_start_end[$i]->[0]   if !$boolean; # if E2_start > E1_end
                        my $end     = $exon_start_end[$i+1]->[1] if !$boolean; # if E2_start > E1_end
                           $start   = $exon_start_end[$i+1]->[0] if  $boolean; # if E1_start > E2_end
                           $end     = $exon_start_end[$i]->[1]   if  $boolean; # if E1_start > E2_end
                        my $strand_exon = $exon_start_end[$i]->[2];
                        my $start_query = $exon_start_end[$i]->[3];
                        my $raw_score   = $exon_start_end[$i]->[6];
                        my $info = [$start,$end,$strand_exon,$i,$start_query,$raw_score]; # Start, End, Strand and Index
                        push(@exon_start_end_cor, $info);
                    }
                }
            }

            @exon_start_end_cor = sort { $b->[3] <=> $a->[3] } @exon_start_end_cor; # Sort by index

            for (my $i=0; $i < @exon_start_end_cor; $i++) {
                splice(@exon_start_end,$exon_start_end_cor[$i]->[3],2); # Splice information about overlapping exons
            }

            for (my $i=0; $i < @exon_start_end_cor; $i++) {  # Push information about the new exon 
                my $start       = $exon_start_end_cor[$i]->[0];
                my $end         = $exon_start_end_cor[$i]->[1];
                my $strand_exon = $exon_start_end_cor[$i]->[2];
                my $start_query = $exon_start_end_cor[$i]->[4];
                my $raw_score   = $exon_start_end_cor[$i]->[5];
                my $info        = [$start,$end,$strand_exon,$start_query,$raw_score];
                push(@exon_start_end, $info );  # Push information about the exon corrected into @exons_start_end
            }
    
            @exon_start_end = sort { $a->[3] <=> $b->[3] || $a->[0] <=> $b->[0] || $a->[1] <=> $b->[1] } @exon_start_end if $isMinus == 0;
            @exon_start_end = sort { $a->[3] <=> $b->[3] || $b->[0] <=> $a->[0] || $b->[1] <=> $a->[1] } @exon_start_end if $isMinus == 1;
            
            # Check if we haven't an exon that's makes no sense
            my ($gene_start,$gene_end) = ($exon_start_end[0]->[0],$exon_start_end[-1]->[1]);
               ($gene_start,$gene_end) = ($gene_end,$gene_start) if $isMinus == 1;
            
            my $isTranspliced = 0;
            for (my $i = @exon_start_end - 1; $i >= 0 ; $i--) {
                my ($start,$end) = ($exon_start_end[$i]->[0],$exon_start_end[$i]->[1]);
                next if !$start || !$end;
                if (($start < $gene_start ) || ($end > $gene_end)) {
                    my $file_with_alt = &Create_alternative_prot($dna_seq,\@exon_start_end,$i,$name);
                    my $delete_or_not = &Choose_best_solution($file_with_alt,$fileprot,$i,$name);
                       $isTranspliced = ( !$delete_or_not ? 1 : 0);
                    splice(@exon_start_end, $i, 1) if !$isTranspliced;
                    if ($isTranspliced) {
                        &Add_comment_for_transpliced($contigname,$name,\@exon_start_end);
                        $add_text_in_header .= ";; Gene coding for $name is probably transpliced (see annotation in comments)\n";
                        last;
                    }
                }
            }
            next if $isTranspliced;
            
            # Define the tab of intron with the information about exons localisation
            my @intron_start_end; 
            for (my $i = 0; $i < (@exon_start_end-1); $i++) {
                my $start  = ($isMinus == 1 ? $exon_start_end[$i]->[1] - 1 : $exon_start_end[$i]->[1] + 1);
                my $end    = ($isMinus == 1 ? $exon_start_end[$i+1]->[0] + 1 : $exon_start_end[$i+1]->[0] - 1);
                my $strand_intron = $exon_start_end[$i]->[2];
                my $info = [$start,$end,$strand_intron];
                push(@intron_start_end, $info);
            }

            my $hypprot = undef;
            my ($start,$end) = ($exon_start_end[0]->[0],$exon_start_end[-1]->[1]);
            my $FirstExonerateMatch = $exon_start_end[0]->[3];
            my $strand = $isMinus ? -1 : 1;
            $hypprot = new PirObject::HypProt (
                                                  name       => $name,
                                                  contigname => $contigname,
                                                  exostart   => $start,
                                                  start      => $start,
                                                  end        => $end,
                                                  strand     => $strand,
                                                  numorfs    => 1,
                                                  protein    => $protein,
                                                  exons      => [],
                                                  introns    => [],
                                                  homologous => $homologous,
                                                  firstExonerateMatch => $FirstExonerateMatch,
                                                  idbyexo    => 1
                                                 );
            push (@$HYPPROTS,  $hypprot);
            
            if ($namefusiongene) {
                my $info_gene_fusion = new PirObject::HypFusion ( name => $namefusiongene );
                $hypprot->set_hypfusiongene($info_gene_fusion);
            }

            my $hypprotexonarray = $hypprot->exons;
            for (my $i = 0; $i < @exon_start_end; $i++){
                # Fill information about exon
                my $attributes      = $exon_start_end[$i]->[4] || "";
                my $frameshift_size = $1 if $attributes =~ m/frameshifts\s+(\d+)/;
                my $hypprotexon = new PirObject::Exon (
                                                       dnastart       => $exon_start_end[$i]->[0],
                                                       dnaend         => $exon_start_end[$i]->[1],
                                                       strand         => $exon_start_end[$i]->[2],
                                                       exoscore       => $exon_start_end[$i]->[6],
                                                       frameshiftsize => $frameshift_size
                                                      );
                push (@$hypprotexonarray, $hypprotexon); 
            }
            
            my $hypprotintronarray = $hypprot->introns;
            for (my $i = 0; $i < @intron_start_end; $i++){
                # Fill information about intron
                my $hypprotintron = new PirObject::Intron (
                                                           start  => $intron_start_end[$i]->[0],
                                                           end    => $intron_start_end[$i]->[1],
                                                           strand => $intron_start_end[$i]->[2],
                                                          );
                push (@$hypprotintronarray, $hypprotintron);
            }
            &CheckRealIntrons($hypprot,$dna_seq,$name,$contigname,$pirmaster);
            &AdjustStartByHMM($hypprot, $dna_seq, $contigname);

            next if $LVL_INTRON == 0;
            
            my $introns = $hypprot->get_introns();
            for (my $i = 0; $i < @$introns; $i++) {
                 my $intron  = $introns->[$i];
                 my $isMinus = ($intron->get_strand() eq "+" ? 0 : 1);
                 my $OV      = &WhatOverlapsThis($intron->get_start(),$intron->get_end(),$contig);
                 my $APC     = &MakeApCollection($OV,$contigname);
                 $intron->set_idbyRNAw($APC);
                 foreach my $info_who_overlap (@$OV){
                     foreach my $OV_AP (@$info_who_overlap ){
                         my ($AP_min,$AP_max,$AP)  = @$OV_AP;
                         my $id_AP  = $1 if scalar($AP) =~ m/0x(.+)\)/;
                         my $tab_id = [$id_AP];
                         &Remove_AP($tab_id,$contig);
                         &AddGroupUseAP($intron,$AP);
                     }
                 }
                 next if $intron->get_type() || $LVL_INTRON == 2;
                 &LocateIntrons($dna_seq,$intron,undef,$name,$contigname,$isMinus);
            }
        }
    }  # End of each prot
} # End sub

sub SortAndGroupC4Report {
    my $ExoReports    = shift;
    my $OV_authorized = shift; 
    
    my $Group_ER      = [];
    foreach my $ER (@$ExoReports) {
        push(@$Group_ER,[$ER])
    }

    for (my $i = 0; ;) {
        last if !($i < scalar(@$Group_ER));
        my $GR        = $Group_ER->[$i];
        my $GR_ini    = $GR->[0];
        my $GR_fin    = $GR->[-1];
        my $p_startGR = $GR_ini->get_query_start();
        my $p_endGR   = $GR_fin->get_query_stop();
        my $g_startGR = $GR_ini->get_target_start();
        my $g_endGR   = $GR_fin->get_target_stop();
        
        my $best_sol     = &DefineBestSol($Group_ER,$p_startGR,$p_endGR,$g_startGR,$g_endGR,$OV_authorized,$i);
        
        $i++ if !(defined($best_sol));
        next if !(defined($best_sol));
        
        # Check if best solution of $i have for best solution $i
        my $GR_bs        = $Group_ER->[$best_sol];
        my $GR_ini_bs    = $GR_bs->[0];
        my $GR_fin_bs    = $GR_bs->[-1];
        my $p_startGR_bs = $GR_ini_bs->get_query_start();
        my $p_endGR_bs   = $GR_fin_bs->get_query_stop();
        my $g_startGR_bs = $GR_ini_bs->get_target_start();
        my $g_endGR_bs   = $GR_fin_bs->get_target_stop();
        my $best_sol_bs  = &DefineBestSol($Group_ER,$p_startGR_bs,$p_endGR_bs,$g_startGR_bs,$g_endGR_bs,$OV_authorized,$best_sol);
        
        $i++ if $best_sol_bs != $i;
        next if $best_sol_bs != $i;
        my $len_GR_bs = scalar(@$GR_bs);
        ($p_startGR < $p_startGR_bs ? 
                splice(@$GR,@$GR,0,@$GR_bs) # add $best_sol at end
              : splice(@$GR,0,0,@$GR_bs));  # add $best_sol at begin
        splice(@$Group_ER,$best_sol,1);
        next;
    }
    return $Group_ER;
}

sub DefineBestSol {
    my ($Group_ER_cp,$p_startGR,$p_endGR,$g_startGR,$g_endGR,$OV_authorized,$i) = @_;
    
    my ($best_sol,$min_dist) = (undef,undef);
    for (my $j = @$Group_ER_cp - 1; $j >= 0 ; $j--) {
        # pour def la meilleur solution si plusieur meilleur regarder celle qui est le plus proche dans le genome
        next if $i == $j;
        my $GR_ini_cp    = $Group_ER_cp->[$j]->[0];
        my $GR_fin_cp    = $Group_ER_cp->[$j]->[-1];
        my $p_startGR_cp = $GR_ini_cp->get_query_start();
        my $p_endGR_cp   = $GR_fin_cp->get_query_stop;
        my $g_startGR_cp = $GR_ini_cp->get_target_start();
        my $g_endGR_cp   = $GR_fin_cp->get_target_stop();
        
        if ($p_startGR < $p_startGR_cp) {
            next if !($p_startGR_cp > $p_endGR || $p_endGR - $p_startGR_cp < $OV_authorized);
            my $dist     = abs($g_endGR - $g_startGR_cp);
               ($min_dist,$best_sol) = ($dist,$j) if !(defined($min_dist));
               ($min_dist,$best_sol) = ( $dist < $min_dist ? ($dist, $j): ($min_dist, $best_sol));
        }
        elsif ($p_startGR > $p_startGR_cp) {
            next if !($p_startGR > $p_endGR_cp || $p_endGR_cp - $p_startGR < $OV_authorized);
            my $dist  = abs($g_endGR_cp - $g_startGR);
               ($min_dist,$best_sol) = ($dist,$j) if !(defined($min_dist));
               ($min_dist,$best_sol) = ( $dist < $min_dist ? ($dist, $j) : ($min_dist, $best_sol));
        }
    }
    return $best_sol
}

sub Create_alternative_prot {
    my ($dna_seq,$exon_start_end,$i,$name) = @_;
    
     my $r_dna_seq = $dna_seq;
        $r_dna_seq =~ tr/ACGT/TGCA/;
        $r_dna_seq = reverse $r_dna_seq;
    my ($with_exons,$without_exons,$count) = ("","",0);
    foreach my $exon_coord (@$exon_start_end) {
       my $use_seq   = ( $exon_coord->[2] eq "-" ? $r_dna_seq : $dna_seq );
       my ($start,$stop) = ( $exon_coord->[2] eq "-" ? 
                           ( (length($use_seq) + 1 - $exon_coord->[0]),(length($use_seq) + 1 - $exon_coord->[1])) 
                           : ($exon_coord->[0],$exon_coord->[1]));
        my $exon_seq = substr($use_seq,$start-1,$stop-$start+1);
        $with_exons    .= $exon_seq;
        $without_exons .= $exon_seq if $count ne $i;
        $count++;
    }
    my $prot_with_exons     = ">With_exon\n";
       $prot_with_exons    .= &TranslateInProt($with_exons);
    my $prot_without_exons  = ">Without_exon\n";
       $prot_without_exons .= &TranslateInProt($without_exons);
    my $proteins            = "$prot_with_exons\n$prot_without_exons";
    
    my $fileprot = "$TMPDIR/Exonerate/for_blast_${name}_e$i";
    
    unlink($fileprot) or die "Impossible to delete $fileprot\n" if (-f $fileprot);
    # Create protein for exonerate
    my $FILEPROT = new IO::File ">$fileprot" or die "Impossible to open $fileprot\n";
    print $FILEPROT $proteins, "\n";
    $FILEPROT->close() or die "Impossible to close $fileprot\n";
    
    return $fileprot;
}

sub Choose_best_solution {
    # return 1 if we must to delete the exon else 0
    my ($file_for_blast,$protein_file,$i,$name) = @_;
    
    # 1. FORMATDB
    my $base_name    = "$TMPDIR/Exonerate/mf_${name}_e$i";
    unlink($base_name) or die "Impossible to delete $base_name\n" if (-f $base_name);
    my $command      = "$FORMATDBPATH -p 'T' -t banque -i $protein_file -n $base_name -l $TMPDIR/Exonerate/fdb_exon.log >/dev/null 2>/dev/null";
    print "$command\n" if $DEBUG;
    my $resformatdb  = system($command);
    
    # 2. BLAST
    my $output         = "$TMPDIR/Exonerate/out_${name}_e$i";
    unlink($output) or die "Impossible to delete $output\n" if (-f $output);
    my $cmdblast = "$BLASTPATH -m 7 -p blastp -M $MATRIX -d $base_name -i $file_for_blast -o $output 2> $TMPDIR/Exonerate/blasterr_1.txt";
    print "$cmdblast\n" if $DEBUG;
    my $resblast = system ($cmdblast);
    
    my $searchfh = new IO::File "<$output"
       or die "Can't read from '$output': $!\n";
    
    my ($eval_with_exons,$eval_without_exons) = (9999,9999); # Very bad evalue 
    while (my $result = PirObject::BlastOutput->FileHandleToObject($searchfh)) {
        my $iterations = $result->BlastOutput_iterations() || next;
        foreach my $iteration (@$iterations) {
           my $rdesc = $iteration->Iteration_query_def() ||   # priority to iteration's value
                       $result->BlastOutput_query_def()  ||
                       "Unknown Query Description";

           my $hitslist = $iteration->Iteration_hits();
           return if @$hitslist < 1; # normally, only one.

           # Note: the significance() method is defined in Hit.pir
           my @hits = sort { &CompareHighPrecisionFloats($a->significance(), $b->significance() ) } @$hitslist;
           next if !$hits[0];
           my $evalue          = $hits[0]->significance(); # Get the e-value
           $eval_with_exons    = $evalue if $rdesc eq "With_exon";
           $eval_without_exons = $evalue if $rdesc eq "Without_exon";
        }
    }
    $searchfh->close();
    return ( $eval_without_exons < $eval_with_exons  ? 1 : 0);
}

sub CheckRealIntrons {
    my ($hypprot,$seq,$name,$contigname) = @_;

    my $exons   = $hypprot->get_exons();
    my $introns = $hypprot->get_introns();
    my $len_seq = length($seq);
    my ($exons_to_rm,$introns_to_rm) = ([],[]);
    for (my $i = 0;  $i < scalar(@$introns) ; $i++) {
        my $intron    = $introns->[$i];
        next if !$intron;
        my $exon      = $exons->[$i];
        my $next_exon = $exons->[$i + 1];
        my $isMinus   = ($intron->get_strand() eq "+" ? 0 : 1);
        
        my $intron_start = $intron->get_start();
        my $intron_end   = $intron->get_end();
           $intron_end   = $intron_end - 2 if $isMinus;
        my $intron_len   =  !$isMinus ? ($intron_end - $intron_start + 1) : ($intron_start - $intron_end - 1);
        next if $intron_len % 3 != 0;
        my $intron_seq   = &GetProteinForGeneWithoutIntrons($seq, $intron_start, $intron_end, $isMinus);
        next if length($intron_seq) == 0;
        next if $intron_seq =~ m/\*/;
        
        &LocateIntrons($seq,$intron,undef,$name,$contigname,$isMinus);
        my $intron_type = $intron->get_type();
        next if $intron_type;
        
        # Add comment for insertion
        my $exoStart = $intron->get_exoStart();
        my $exoEnd   = $intron->get_exoEnd();
        my $max_ins_permitted = ( $exoStart && $exoEnd && $exoStart < $exoEnd  ?
                                        $INSERTION + abs($exoStart - $exoEnd) 
                                      : $INSERTION );
        my $intron_len_aa = $intron_len/3;
        
        # Changed info for exon
        my $number_frameshift = ($exon->get_frameshiftsize() || 0) + ($next_exon->get_frameshiftsize() || 0);
        $exon->set_frameshift($number_frameshift) if $number_frameshift != 0;
        $exon->set_dnaend($next_exon->get_dnaend());
        $exon->set_insertion($intron_len_aa) if $intron_len_aa >= $max_ins_permitted;
        push(@$exons_to_rm,$i+1);
        push(@$introns_to_rm,$i);
    }
    # Removed exon and intron if necessary
    for (my $i = @$exons - 1; $i >= 0 ; $i--) {
        splice(@$exons, $i, 1) if grep($_ == $i, @$exons_to_rm);
    }
    for (my $i = @$introns - 1; $i >= 0 ; $i--) {
         splice(@$introns, $i, 1) if grep($_ == $i, @$introns_to_rm);
    }
}

sub Add_comment_for_transpliced {
    my ($contigname,$name,$exon_start_end) = @_;

    my $number         = 1;
    foreach my $exon (@$exon_start_end) {
        my ($start,$end,$strand,$start_query,$attributes,$end_query,$raw_score) = @$exon;
        my $frameshift_size = $1 if $attributes =~ m/frameshifts\s+(\d+)/;

        my $arrow = $strand eq "+" ? "==>" : "<==";
        my $start_line  = ";; $name-E$number $arrow start";
           $start_line .= ";; frameshift of $frameshift_size nt" if $frameshift_size;
        my $end_line    = ";; $name-E$number $arrow end";

        my $hyp_prot = new PirObject::AnnotPair(
                                                 type      => "C",
                                                 genename  => $name,
                                                 startpos  => $start,
                                                 endpos    => $end,
                                                 direction => $arrow,
                                                 startline => $start_line,
                                                 endline   => $end_line,
                                                 );
        &AddAnnotToPirMaster($contigname,$hyp_prot);
        $number++;
     }
}

sub MakeApCollection {
    my ($OV,$contigname) = @_;
    
    my $APC = new PirObject::AnnotPairCollection(
                  genename   => "Intron",
                  contigname => $contigname,
                  annotpairlist => [],
    );
    
    my $APL = $APC->get_annotpairlist();
    foreach my $info_who_overlap (@$OV){
       foreach my $features_who_overlap (@$info_who_overlap ){
           my $AP = $features_who_overlap->[2];
           push(@$APL,$AP);
       }
    }
    return $APC;
}

sub CommentAllRNAwIntron {
    my $contigs   = $pirmaster->get_contigs();
   
    foreach my $contig (@$contigs) {
    my $annotations = $contig->get_annotations();
    foreach my $annot (@$annotations) {
        my $genename = $annot->get_genename();
        next if $genename && $genename ne "comment";
        my $start_line = $annot->get_startline();
        next if $start_line !~ m/group=/;
        $annot->set_type("C")
        }
    }
}

#------------------------------------#
# Subs for processing ORFs => genes  #
#------------------------------------#

sub TreatGeneFusion {
    # This function is supposing to find start
    # to find end for gene with exons and introns
    # to treat the case of gene fusion
    &AddInfoAboutGeneFusion($HYPPROTS);

    foreach my $hypprot (@$HYPPROTS) {
        my $strand      = $hypprot->get_strand();
        my $isMinus     = ($strand == 1 ? 0 : 1);
        my $contig      = $pirmaster->GetContigByName ($hypprot->get_contigname());
        my $exons       = $hypprot->get_exons();
        my $idByExo     = (scalar(@$exons) != 0 ? 1 : 0);
        
        my $seq         = $contig->get_sequence();                                   
        my $len_seq     = length($seq);
        
        # We have a gene fusion.
        my $isFusioned = $hypprot->get_hypfusiongene() || undef;
        if ($isFusioned) {
            &TreatmentOfFusion($hypprot,$contig,$isMinus,$len_seq,$exons);
        }
    } # End foreach $hypprot
} # End function

sub AddInfoAboutGeneFusion {
    my $hypprots = shift;
    
    foreach my $hypprot1 (@$hypprots) {
        my $contigname1 = $hypprot1->get_contigname();
        
        my $infofusiongene1 = $hypprot1->get_hypfusiongene() || undef;
        next if !$infofusiongene1;
        
        my $namefusiongene1 = $infofusiongene1->get_name() || undef;
        next if !$namefusiongene1;
        
        my $strand1        =  $hypprot1->get_strand();
        my ($start1,$end1) = ($hypprot1->get_start(),$hypprot1->get_end());
           ($start1,$end1) = ($end1,$start1) if $strand1 != 1;
        
        foreach my $hypprot2 (@$hypprots) {
            next if $hypprot1 eq $hypprot2;
            
            my $contigname2 = $hypprot2->get_contigname();
            next if $contigname1 ne $contigname2;
             
            my $genename2   = $hypprot2->get_name();
            next if $genename2 ne $namefusiongene1;
            
            my $strand2        =  $hypprot2->get_strand();
            my ($start2,$end2) = ($hypprot2->get_start(),$hypprot2->get_end());
               ($start2,$end2) = ($end2,$start2) if $strand2 != 1; ;
            
            next if $strand1 != $strand2;
            next if ( $start2 < $start1 && $end2 < $start1 ) || ($start2 > $end1 && $end2 > $end1);
            
            my $start_f = $hypprot2->get_blaststart() || $hypprot2->get_exostart();
            $infofusiongene1->set_start($start_f);
            $infofusiongene1->set_end($hypprot2->get_end());
        }
    }
}

sub TreatmentOfFusion {
    my $hypprot   = shift;
    my $contig    = shift;
    my $isMinus   = shift;
    my $len_seq   = shift;
    my $exons     = shift;
    my $idByExo   = (scalar(@$exons) != 0 ? 1 : 0);
    
    my $start_gene   = $hypprot->get_start();
       $start_gene   = ( $isMinus ? $len_seq - $start_gene + 1 : $start_gene);
    my $fusion_info  = $hypprot->get_hypfusiongene();
    my $startwarning = $hypprot->get_startwarning() || "";
    my $start_fusion = $fusion_info->get_start();
    return if !(defined($start_fusion));
       $start_fusion = ( $isMinus ? $len_seq - $start_fusion + 1 : $start_fusion);
    my $fusion_name  = $fusion_info->get_name();
     
    # Add comment for the second gene
    if ($start_gene > $start_fusion) {
        my $simi_start = $hypprot->get_blaststart() || $hypprot->get_exostart();
        $hypprot->set_start($simi_start);
        my $first_exon =  $exons->[0]          if $idByExo;
        $first_exon->set_dnastart($simi_start) if $idByExo;
        $startwarning .= $startwarning ne "" ?
                         " / contiguous and in phase with $fusion_name" 
                         : "contiguous and in phase with $fusion_name";
        $hypprot->set_startwarning("$startwarning") if $startwarning;
        $hypprot->set_posiffusion(2);
        return;
    }
    
    $hypprot->set_posiffusion(1);
    # Adjust end if it's first gene
    my $newendpos  = ( $isMinus ? $len_seq - $start_fusion + 2 : $start_fusion - 1);
    $hypprot->set_end($newendpos);
    
    # Adjust end of last exon
    my $end_exon = $exons->[-1]       if $idByExo;
    $end_exon->set_dnaend($newendpos) if $idByExo;
}

#-------------------------------------------------#
# Subs for making annotations of mini exons       #
#-------------------------------------------------#

sub AnnotateMiniExons {
    # This fonction is used in order to identify mini exons
    mkdir("$TMPDIR/Muscle_for_exons",0700) or die "Error: can't create work directory '$TMPDIR/Muscle_for_exons': $!\n";
    foreach my $hypprot (@$HYPPROTS) {
        my $name       = $hypprot->get_name();
        my $contigname = $hypprot->get_contigname();
        next if (not (defined ($name)) or ($name eq ""));
        
        my $contig      = $pirmaster->GetContigByName($contigname);  
        my $seq         = uc($contig->get_sequence());                                   
        my $reverse_seq = $seq;
           $reverse_seq =~ tr/ACGT/TGCA/;
           $reverse_seq = reverse $reverse_seq;
           
        my $exons   = $hypprot->get_exons();
        my $introns = $hypprot->get_introns();
        next if scalar(@$exons) < 2;    # For protein with exon/intron
        
        my $prot_sequence   = &GetProteinSequenceAndIntronsPos($exons,$introns,$seq,$hypprot);
        next if $prot_sequence eq "Frame-Shift-Detected";
        $prot_sequence      = substr($prot_sequence, 0, -1);
        #next if (index($prot_sequence,"*") >= 0 );
        
        my $file_for_alignment = &MakeFileForAlignment($hypprot,"Muscle_for_exons",10);
        
        my $result_file = $file_for_alignment;
           $result_file =~ s/.fasta$/.aln/;

        my $cmd = "$MUSCLEPATH -in $file_for_alignment -stable -clwstrict -out $result_file >/dev/null 2>/dev/null";
        print "\n$cmd\n" if $DEBUG;
        system ("$cmd");
        
        my $alignio = new Bio::AlignIO(-format => 'clustalw',
                                       -file   => $result_file);
                                       
        my $align = $alignio->next_aln();
        my $percent_id =  $align->percentage_identity();
        
        my $nt_frame    = 15;
INTRON: for (my $i = 0; $i < @$introns; $i++) {
            my $intron             = $introns->[$i];
            my $intron_pos_hypprot = $intron->get_intronpos();
            my $isMinus            = ($intron->get_strand() eq "+" ? 0 : 1);
            my $use_seq            = ($isMinus ? "$reverse_seq" : "$seq");
            my $len_seq            = length($seq);
            my ($hypprot_seq, $intron_pos_align) = &DefineSeqOfHypprotAndPosOfIntronInAlignment($align,$intron_pos_hypprot);
            
            # Make sub-alignement
            my ($sub_ali_homo,$intron_pos_sub) = &MakeSubAlignment($align,$hypprot_seq,$intron_pos_align,$nt_frame); 
            # Alignment of hypprot
            my $sub_ali_prot = &RemoveHypprotInAlignment($sub_ali_homo);
            # Percent of each aa on each pos in homologous prot
            my $percent      = &AaPercentInHomologous($sub_ali_homo);
            
            # Indicate if the position is conserved on hypprot 
            # compare hypprot aa with the other aa in alignment
            my $conserved_seq = &CompareEachPosOfHypprotWithHomologous($sub_ali_prot,$percent);
            # position of missing exon in sub-align
            my ($len_adjust_prev,$len_adjust_next) = &DefineAdjustIntron($conserved_seq,$intron_pos_sub,$percent_id);
            next if $len_adjust_prev eq "-" && $len_adjust_next eq "-"; # special convention
            next if $len_adjust_prev == 0 && $len_adjust_next == 0;
            
            my ($sub_percent,$exon_ali)  = &DefineSeqAndAliOfResearchExon($percent,$sub_ali_homo,$intron_pos_sub,$len_adjust_prev,$len_adjust_next);
            
            my $max_percent = 0;
            foreach my $hash (@$sub_percent) {
                 while ( my ($nt_in_ref, $percent) = each(%$hash)) {
                     next INTRON if $nt_in_ref eq "-";
                     $max_percent = $percent if $percent > $max_percent;
                     # Escape if we have a gap in homologous sequence around intron must be conserved. 
                 }
            }
            my $HaveBadConservation = 1 if $max_percent < 0.7;
            
            &LocateIntrons($seq,$intron,undef,$name,$contig->get_name(),$isMinus) if $LVL_INTRON == 0;
            my $apc = $intron->get_idbyRNAw() || die "idbyRNAw() is Empty\n";
            my $apl = $apc->get_annotpairlist();
            my $nb_intron = scalar(@$apl);
            next if $HaveBadConservation && $nb_intron <= 1;
            
            my $tot_len                       = $len_adjust_prev + $len_adjust_next;
            my ($sc_each_pos,$ave_sc,$max_sc) = &DefineEachPosAndAveScore($sub_percent,$exon_ali);
            my $initial_solution              = substr($sub_ali_prot->seq(),$intron_pos_sub+1-$len_adjust_prev,$tot_len);
            my $HaveBadPos                    = &HaveABadPos($exon_ali,$sc_each_pos,$initial_solution);
            my $ini_pam_sc                    = $HaveBadPos ? -999 : &CalculatePamScore($initial_solution,$sub_percent);
            
            next if $ini_pam_sc >= $ave_sc && $HaveBadPos == 0;
            my $previous_exon = @$exons[$i]   || next;
            my $next_exon     = @$exons[$i+1] || next;
            &AdjustExonsIntron ($intron,$previous_exon,$next_exon,$len_adjust_prev,$len_adjust_next,"deconstruct",$isMinus);
            my ($intron_start,$intron_end) = ($intron->get_start(),$intron->get_end());
            if ($nb_intron > 2) {
                my $comment = "three introns found";
                $intron->set_comment($comment);
                next;
            }
            &SortAPL($apl,$isMinus) if $nb_intron > 1;
            if ($nb_intron < 2 && $len_adjust_prev + $len_adjust_next == 1) {
                # Initial annotation is considered to be true, let's return to it.
                &AdjustExonsIntron($intron,$previous_exon,$next_exon,$len_adjust_prev,$len_adjust_next,"reconstruct",$isMinus);
                next;
            }
            my $list_of_hyp_exons = &FindHypMiniExon($use_seq,$intron,$sub_percent,$isMinus,$nb_intron,$apl,$max_sc,$ini_pam_sc);
            #@$list_of_hyp_exons  = a tab with [seq,score,$length_prefix,$length_core,$length_suffix,$pos] foreach hyp exons
            if (@$list_of_hyp_exons == 0) {
                # No solution found, reconstruction of initial annnotation
                &AdjustExonsIntron($intron,$previous_exon,$next_exon,$len_adjust_prev,$len_adjust_next,"reconstruct",$isMinus);
                next; #next intron
            }
            &DefineEachIntronType($list_of_hyp_exons,$nb_intron,$apl,$isMinus,$len_seq);
            &AddSpliceScore($use_seq,$intron,$list_of_hyp_exons,$isMinus);
            @$list_of_hyp_exons   = sort {   $b->{"pam_score"} <=> $a->{"pam_score"}
                                          || $b->{"splice_score"} <=> $a->{"splice_score"}} @$list_of_hyp_exons;
            $list_of_hyp_exons    = &SelectBestHypExons($list_of_hyp_exons);
            if (@$list_of_hyp_exons == 0) {
                # No solution found
                &AdjustExonsIntron($intron,$previous_exon,$next_exon,$len_adjust_prev,$len_adjust_next,"reconstruct",$isMinus);
                next; #next intron
            }
            # At this point, all pam_scores are the same
            @$list_of_hyp_exons   = sort {   $b->{"splice_score"} <=> $a->{"splice_score"}
                                          || $a->{"core"}         <=> $b->{"core"}
                                          || $a->{"position"}     <=> $b->{"position"}} @$list_of_hyp_exons;
            my $best_solution     = shift(@$list_of_hyp_exons);
            &AddCommentsForOtherSolutions($hypprot,$i,$list_of_hyp_exons,$isMinus,$contigname) if scalar(@$list_of_hyp_exons) > 0 ;
            &AddMiniExon($introns,$exons,$i,$best_solution,$isMinus);
            $i++; # Because we add an entry in @$introns
        }
    }
}

sub GetProteinSequenceAndIntronsPos {
    my $exons   = shift;
    my $introns = shift;
    my $seq     = shift;
    my $hypprot = shift;
    
    my $name         = $hypprot->get_name();
    my $dna_sequence = "";
    my $length_tot   = 0;
    for (my $i = 0 ; $i < scalar(@$exons) ; $i++) {
        my $hasFrameshift = $exons->[$i]->frameshiftsize();
        return "Frame-Shift-Detected" if $hasFrameshift;
        my $start         = $exons->[$i]->dnastart()   || next;
        my $end           = $exons->[$i]->dnaend()     || next;
        my $isMinus       = ($exons->[$i]->strand eq "+" ? 0 : 1);
        ($start,$end)     = ($end,$start) if $isMinus;
        my $length_exon   = $end - $start + 1;
        my $exon_seq      = uc (substr($seq, $start - 1 , $length_exon ));
        my $reverse_exon  = $exon_seq;
           $reverse_exon  =~ tr/ACGT/TGCA/;
           $reverse_exon  = reverse $reverse_exon;
           $dna_sequence .= (!$isMinus ? $exon_seq : $reverse_exon);
        my $start_pos     = int($length_tot/3) + 1;
        $length_tot      += $length_exon;
        my $end_pos       = int($length_tot/3);
        my $phase         = $length_tot % 3;
        $exons->[$i]->set_protstart($start_pos);
        $exons->[$i]->set_protend($end_pos);
        $introns->[$i]->set_intronpos($end_pos) if defined($introns->[$i]);
        $introns->[$i]->set_phase($phase)       if defined($introns->[$i]);
    }
    
    my $dna_length    = length($dna_sequence);
    die "The protein $name is not valid, its length is not a multiple of three\n"
       if $dna_length % 3 != 0;
       
    my $prot_sequence = &TranslateInProt($dna_sequence);
    $hypprot->set_thisprot($prot_sequence);
    return $prot_sequence;
}

sub MakeFileForAlignment {
    my $hypprot = shift;
    my $dir     = shift;
    my $length  = shift;
    
    my $name       = $hypprot->get_name();
    my $contigname = $hypprot->get_contigname();
    my $homologous = $hypprot->get_homologous();
    my $prot       = $hypprot->get_thisprot();
    my $flag       = $1 if  scalar($hypprot) =~ m/0x(.+)\)/;
    
    my $full_5 = "";
    my $name_of_file = "$TMPDIR/$dir/$contigname"."_$name"."_$flag.fasta";
    
    die "The file $name_of_file already exist"
        if (-e $name_of_file);
    
    # Open the file
    my $file_for_alignment = new IO::File ">$name_of_file" or die "Impossible to open $name_of_file\n";
    
    # Write into the file
    
    my $format_prot = &Format($prot); 
    print $file_for_alignment $format_prot;
    
    my $id = "a"; # Use in order to be sure that's two seq use by muscle have differnt name
    
    for (my $i = 0; $i < $length; $i++) {
        my $homologous = @$homologous[$i];
        last if !$homologous;
        my $similar_prot = $homologous->get_similarprot();
           $similar_prot =~ s/\n+$//;
           $similar_prot =~ s/^>(.+)/>$id $1/;
        print $file_for_alignment "$similar_prot\n\n";
        $id++;
    }
    
    # Close the file
    $file_for_alignment->close() or die "Impossible to close $name_of_file\n";
    return ($name_of_file);
}

sub Format {
    my $seq  = shift;
    
    my $format_seq = ">mfaprot\n";
    for (my $i = 0 ; $i <= length($seq); $i += 60 ) {
        my $rest_length = length($seq) - $i;
        if ( $rest_length <= 60 ) {
            $format_seq .= substr($seq, $i , $rest_length);
            $format_seq .= "\n";
        }
        else {
            $format_seq .= substr($seq, $i , 60);
            $format_seq .= "\n";
        }
    }
    return $format_seq;
}

sub DefineSeqOfHypprotAndPosOfIntronInAlignment {
    # In order to define the sequence of the hyppothetical protein
    # and to define the position of intron on the alignment.
    my $align              = shift;
    my $intron_pos_hypprot = shift;
    
    my $hypprot_seq        = undef;
    my $pos_in_alignment   = undef;
    foreach my $seq ($align->each_seq) {
        my $id = $seq->display_id();
        next if $id ne "mfaprot";
        $hypprot_seq      = $seq;
        $pos_in_alignment = $align->column_from_residue_number( $id, $intron_pos_hypprot);
        last;
    }
    return ($hypprot_seq, $pos_in_alignment);
}

sub MakeSubAlignment {
    # In order to make sub-alignment
    my $align       = shift;
    my $hypprot_seq = shift;
    my $pos         = shift;
    my $nt_frame    = shift;
    
    my $left_substring  = substr($hypprot_seq->seq(),0,$pos);
    my $right_substring = substr($hypprot_seq->seq(),$pos,length($hypprot_seq->seq())-$pos);
    my $left_length     = length($left_substring) - 1;
    my $right_length    = length($right_substring);
    my $num1            = ( $left_length >= ($nt_frame - 1) ? ($nt_frame - 1) : $left_length);
    my $num2            = ( $right_length >= $nt_frame ? $nt_frame : $right_length);
    my $sub_align       = $align->slice($pos - $num1 , $pos + $num2);

    return ($sub_align,$num1) ;
}

sub RemoveHypprotInAlignment {
    # Remove hypprot in each sub-alignment 
    # and return sub-alignment for hypprot.
    my $align = shift;
    
    my $sub_ali_prot = undef;
    foreach my $seq ($align->each_seq) {
        next if $seq->display_id() ne "mfaprot";
        $sub_ali_prot = $seq;
        $align->remove_seq($seq);
        last;
    }
    return $sub_ali_prot;
}

sub AaPercentInHomologous {
    my $homologous_align = shift;
    
    my $position = [];
    my $length   = $homologous_align->length();
    my $nb_seq   = scalar($homologous_align->each_seq);
    for (my $pos = 1; $pos <= $length; $pos++) {
        my $count    = {};
        my $percent  = {};
        foreach my $seq ($homologous_align->each_seq) {
            my $sub = $seq->subseq($pos, $pos);
            $count->{$sub}++;
        }
        while ( my ($key, $value) = each(%$count) ) {
            my $percentage = ($value/$nb_seq);
            $percent->{ $key } = $percentage; 
        }
        $position->[$pos - 1] = $percent;
    }
    return $position;
}

sub CompareEachPosOfHypprotWithHomologous {
    my $sub_ali_prot    = shift;
    my $percent_in_homo = shift;
    
    my $similarity = [];
    my $length     = $sub_ali_prot->length();
    for (my $pos = 1; $pos <= $length; $pos++) {
        my $aa_in_homo_same_pos = $percent_in_homo->[$pos - 1];
        my $sub = $sub_ali_prot->subseq($pos, $pos);
        my $aa  = ( $aa_in_homo_same_pos->{$sub} ? "-" : $sub );
        $similarity->[$pos - 1] = $aa;
        # Put 1 in $pos when we have a similar aa in hypprot and in homologous protein.
        # Put a letter in $pos when we have a difference between hypprot and homologous.
    }
    return $similarity;
}

sub DefineAdjustIntron {
    # Define portion of non homologous region taking into account
    # of the accepeted separation between 2 disimilarity 
    my $conserved_seq  = shift;
    my $intron_pos     = shift;
    my $percent_id     = shift;
    
    my $string = join('', @$conserved_seq);
    # String is : -------------FLML---------- 
    # 1 is used for a similar aa in hypprot and in homologous protein.
    # Letters is used for when we have a difference between hypprot and homologous
    my $length       = length($string);
    
    my $left         = substr($string,0,$intron_pos+1);
    my $one_aa_left  = substr($string,$intron_pos,1);
    
    my $right        = substr($string,$intron_pos+1);
    my $one_aa_right = substr($string,$intron_pos+1,1);
    
    return ("-","-") if $one_aa_left eq "-" && $one_aa_right eq "-" && $percent_id < 50; 
    
    my $missing_left  = &DefineMissingLeft($left);
    my $missing_right = &DefineMissingRight($right);
        
    my $length_left   = length($missing_left);
    my $length_right  = length($missing_right);
    my $length_tot    = $length_left + $length_right;
    return ("-","-") if $one_aa_left eq "-" && $one_aa_right eq "-" && $length_tot < 2 && $percent_id < 50;
    return($length_left,$length_right);
}

sub DefineMissingLeft {
    my $substring = shift;
    
    my $length = length($substring);
    my $missing_left = "";
    my $max_similarity_accepted = 2;
    my $max_similarity_string = "";
    for (my $i = 0; $i < $max_similarity_accepted; $i++){
         $max_similarity_string .= "-";
    }
    for (my $i = $length; $i > 1; $i--){
        my $aa = substr($substring,$i - $max_similarity_accepted,$max_similarity_accepted);
        last if $aa eq $max_similarity_string;
        $aa = chop($aa) if $i != $max_similarity_accepted;
        $missing_left = $aa . $missing_left;
    }
    $missing_left =~ s/^-//;
    return $missing_left;
}

sub DefineMissingRight {
    my $substring = shift;
    
     my $length = length($substring);
    my $missing_right = "";
    my $max_similarity_accepted = 2;
    my $max_similarity_string = "";
    for (my $i = 0; $i < $max_similarity_accepted; $i++){
         $max_similarity_string .= "-";
    }
    for (my $i = 0; $i <= $length - $max_similarity_accepted; $i++){
        my $aa = substr($substring,$i,$max_similarity_accepted);
        last if $aa eq $max_similarity_string;
        $aa = substr($substring,$i,1) if $i != $length - $max_similarity_accepted;
        $missing_right .= $aa;
    }
    $missing_right =~ s/-$//;
    return $missing_right;
}

sub AdjustExonsIntron {
    my $intron          = shift;
    my $previous_exon   = shift;
    my $next_exon       = shift;
    my $len_adjust_prev = shift;
    my $len_adjust_next = shift;
    my $DeOrReConstruct = shift;
    my $isMinus         = shift;
    
    my $first_adjust   = ($DeOrReConstruct eq "deconstruct" ? 1 : 0);
    my $phase          = $intron->get_phase();
    my $previous_m     = ($isMinus ?  3 : -3);
    my $next_m         = ($isMinus ? -3 :  3);
    my $adjust_i_start = ($isMinus ? -1 :  1);
    my $adjust_i_end   = ($isMinus ?  1 : -1);
    my $adjust_phase_previous = ($isMinus ? $phase : -$phase);
    my $adjust_phase_next     = ($isMinus ? (-(3 - $phase)) : (3 - $phase));
    
    my $adjust_end        = ($previous_m * $len_adjust_prev) + $adjust_phase_previous;
       $adjust_end        = -$adjust_end if !$first_adjust;
    my $previous_exon_end = $previous_exon->get_dnaend() + $adjust_end;
    my $intron_start      = $previous_exon_end + $adjust_i_start;
    $previous_exon->set_dnaend($previous_exon_end);
    $intron->set_start($intron_start);
    
    my $adjust_start      =  ($next_m * ($len_adjust_next-1)) + $adjust_phase_next;
       $adjust_start      = -$adjust_start if !$first_adjust;
    my $next_exon_start   = $next_exon->get_dnastart() + $adjust_start;
    my $intron_end        =  $next_exon_start + $adjust_i_end;
    $next_exon->set_dnastart($next_exon_start);
    $intron->set_end($intron_end);
}

sub DefineSeqAndAliOfResearchExon {
    my ($percent,$sub_ali_homo,$intron_pos_sub,$len_adjust_prev,$len_adjust_next) = @_;
    
    my $start = $intron_pos_sub - $len_adjust_prev + 1;
    my $end   = $intron_pos_sub + $len_adjust_next;
    my $sub_percent  = [];
      @$sub_percent  = @$percent[$start..$end];
    my $sub_align    = $sub_ali_homo->slice($start + 1, $end + 1);

    return ($sub_percent,$sub_align);
}

sub DefineEachPosAndAveScore {
    my ($sub_percent,$exon_ali) = @_;
    
    my $length    =  scalar(@$sub_percent);
    my ($seq_score,$score_each_pos) = ({},{});
    foreach my $seq ($exon_ali->each_seq) {
        my ($score,$pos) = (0,0);
        $seq_score->{$seq->seq}->{"count"}++;
        next if $seq_score->{$seq->seq}->{"score"};
        for (;;) {
            my $hash_of_nt = $sub_percent->[$pos];
            my $nt_sub     = $seq->subseq($pos + 1, $pos + 1);
            my $min_score  = 999;
            while ( my ($nt_in_ref, $percent) = each(%$hash_of_nt)) {
                next if !($nt_in_ref ne "-" || $nt_sub ne "-");
                $score    += $percent * $matrix->get_entry($nt_in_ref,$nt_sub);
                $min_score = $matrix->get_entry($nt_in_ref,$nt_sub) if $matrix->get_entry($nt_in_ref,$nt_sub) < $min_score;
            }
            $score_each_pos->{$pos} = $min_score if !$score_each_pos->{$pos} || $min_score < $score_each_pos->{$pos};
            $pos++;
            last if $pos >= $length;
        }
        my $ScoreIsNeg = $score < 0 ? 1 : 0;
        $score =  &Arrondi(abs($score),1);
        $score = $ScoreIsNeg ? -$score : $score;
        $seq_score->{$seq->seq}->{"score"} = $score;
    }
    
    my ($ave_score,$tot_seq) = (0,0);
    while ( my ($seq, $hash) = each(%$seq_score)) {
        next if $seq =~ m/-/;
        my ($count,$score)   = ($hash->{"count"},$hash->{"score"});
        $ave_score += $score * $count;
        $tot_seq   += $count;
    }
    $ave_score = $ave_score / $tot_seq;
    my @sort_score = sort{ $seq_score->{$a}->{"score"} <=> $seq_score->{$b}->{"score"} } keys %$seq_score;
    my ($min_score,$max_score) = ($seq_score->{$sort_score[0]}->{"score"},$seq_score->{$sort_score[-1]}->{"score"});
    return($score_each_pos,$ave_score,$max_score);
}

sub Arrondi {
    my ($n,$precision) = @_;
    return int((10**$precision)*$n + 0.5) / (10**$precision);
}

sub HaveABadPos { 
    my ($exon_ali,$score_each_pos,$initial_solution) = @_;

    my $length     =  length($initial_solution);    
    my $max_sc_pos = {};
    foreach my $seq ($exon_ali->each_seq) {
        die "Hypothetic exon have not the same length that research seq" 
            if $length != length($seq->seq);
        my ($pos,$max_score) = (0,-999);
        for (;;) {
            my $nt_ini     = substr($initial_solution,$pos,1);
            my $nt_homo    = substr($seq->seq,$pos,1);
            return 1 if $nt_ini eq "-";
            next if !($nt_homo ne "-");
            my $score  = $matrix->get_entry($nt_homo,$nt_ini);
            $max_sc_pos->{$pos} = $score if !$max_sc_pos->{$pos} || $score > $max_sc_pos->{$pos};
            $pos++;
            last if $pos >= $length;
        }
    }
    
    for (my $i = 0; $i < $length; $i++) {
        return 1 if $max_sc_pos->{$i} < $score_each_pos->{$i};
    }
    return 0;
}

sub LocateIntrons {
    my ($seq,$intron,$annot,$name,$contigname,$isMinus) = @_;
    
    my $isExoIntron = defined($intron) ? 1 : 0;
    my $start       = $isExoIntron ? $intron->get_start() : $annot->get_startpos();
    my $end         = $isExoIntron ? $intron->get_end()   : $annot->get_endpos();
    ($start,$end)   = ($end,$start) if $isMinus;
    my $length      = $end - $start + 1;
    my $intron_seq  = substr($seq,$start - 1,$length);
    
    my $conf_file       = PirObject::MfAnnotExternalProgs->ImportFromTextFile($EXTCONFIGFILE);
    my $genecomsets     = $conf_file->get_geneprogs(); # This is a HASH genename => <MfAnnotGeneCommandSet>
    my $commandobjectII = $genecomsets->{"IntronII"};
    my $commandobjectI  = $genecomsets->{"IntronI"};
    
    my $flag = $1 if $intron && scalar($intron) =~ m/0x(.+)\)/;
       $flag = $1 if $annot  && scalar($annot)  =~ m/0x(.+)\)/;
    
    my $name_of_file      = "$TMPDIR/Intron/$name.$flag.fasta";
    my $outputfile_prefix = "$TMPDIR/Intron/$name.$flag";
    
    die "The file $name_of_file already exist"
        if (-e $name_of_file);
   
    # Open the file
    my $intron_file = new IO::File ">$name_of_file" or die "Impossible to open $name_of_file\n";
    # Write into the file
    print $intron_file ">myintron\n";
    print $intron_file $intron_seq;
    # Close the file
    $intron_file->close() or die "Impossible to close $name_of_file\n";
    
    my $annotpaircollectionsII = &ExecuteExternalProgram($commandobjectII,"IntronII",undef,$name_of_file,"$outputfile_prefix-II.xml");
    my $annotpaircollectionsI  = &ExecuteExternalProgram($commandobjectI,"IntronI",  undef,$name_of_file,"$outputfile_prefix-I.xml");
    my $annotpaircollection    = &MakeOneApCollection($annotpaircollectionsII,$annotpaircollectionsI,$contigname);
    if ($isExoIntron == 1) {
        &AddGroupUseAPC($intron,$annotpaircollection);
        &AddInfoAboutIdIntrons($intron,$annotpaircollection,$contigname,$isMinus);
    }
    else {
        my $APL = $annotpaircollection->get_annotpairlist();
        foreach my $AP (@$APL) {
            my ($AP_start,$AP_end) = ($AP->get_startpos(),$AP->get_endpos());
            &AdjustCoordInWholeMF($annot->get_startpos(),$annot->get_endpos(),$AP,$isMinus);
            my $contig = $pirmaster->GetContigByName($contigname) or die "Can't get contig by name in LocateIntrons\n";
            $AP->set_type("C");
            &AddAnnotToPirMaster($contigname,$AP);
        }
    }
}

sub MakeOneApCollection {
    my ($APCII,$APCI,$contigname) = @_;
    
    my $APC = new PirObject::AnnotPairCollection(
                             genename      => "Intron",
                             contigname    => $contigname,
                             annotpairlist => [],
    );
    
    my $annotpairlistarray = $APC->get_annotpairlist();
    foreach my $APCs (@$APCII,@$APCI) {
        my $APL = $APCs->get_annotpairlist();
        push(@$annotpairlistarray, @$APL);
    }
    return $APC;
}

sub AddGroupUseAPC {
    my ($intron,$APC) = @_;
    
    my $APL = $APC->get_annotpairlist();
    foreach my $AP (@$APL) {
        &AddGroupUseAP($intron,$AP);
    }
}

sub AddGroupUseAP {
    my ($intron,$AP) = @_;
    
    my $AP_startline = $AP->get_startline();
    my $AP_endline   = $AP->get_endline();
            
    my $type        = $1    if $AP_startline =~ m#group=(.+)#;
       die "Internal error : external AP does not contain type on startline?!?\n" unless $type;
    
    my $intron_type  = $intron->get_type() || "";
       $intron_type .= "," if $intron_type;
       $intron_type .= $type;    
       $intron->set_type($intron_type);
} 

sub AddInfoAboutIdIntrons {
    # Used in order to define position of AP in whole masterfile
    my ($intron,$APC,$contigname,$isMinus,$IsExoIntron) = @_;
    
    my ($i_start,$i_end) = ($intron->get_start(),$intron->get_end());
    my $APL = $APC->get_annotpairlist();
    foreach my $AP (@$APL) {
        &AdjustCoordInWholeMF($i_start,$i_end,$AP,$isMinus);
    }
    $intron->set_idbyRNAw($APC);
}

sub AdjustCoordInWholeMF {
    my ($start,$end,$AP,$isMinus) = @_;

    my $AP_start  = $AP->get_startpos();
    my $AP_end    = $AP->get_endpos();
    my $new_start = ($isMinus ? $end + $AP_start - 1 : $start + $AP_start - 1);
    my $new_end   = ($isMinus ? $end + $AP_end   - 1 : $start + $AP_end   - 1);
    $AP->set_startpos($new_start);
    $AP->set_endpos($new_end);
}

sub SortAPL {
    my ($apl,$isMinus) = @_;

    @$apl = sort { $a->get_startpos() <=> $b->get_startpos() } @$apl if !$isMinus;    
    @$apl = sort { $b->get_startpos() <=> $a->get_startpos() } @$apl if  $isMinus;
}

sub FindHypMiniExon {
    my ($seq,$intron,$research_seq,$isMinus,$nb_intron,$apl,$best_pam_sc,$ini_pam_sc) = @_;
    
    my $len_seq      = length($seq);
    my $intron_start = $intron->get_start();                           # Bio coord
    my $intron_end   = $intron->get_end();                             # Bio coord
       $intron_start = $len_seq + 1 - $intron_start if $isMinus;
       $intron_end   = $len_seq + 1 - $intron_end   if $isMinus;
    
    my $list_of_hyp_exons      = [];
    my $zones                  = &DefineZone($intron,$isMinus,$intron_start,$intron_end,$len_seq);
    my $aa_length_missing_exon = scalar(@$research_seq);
    my $region_nt_length       = $aa_length_missing_exon * 3;
    my $max_score_in_matrix    = $matrix->get_entry("W","W");                 # Max score on the diagonal of PAM matrix
    my $min_pam_score          = $best_pam_sc - ($aa_length_missing_exon * 1/4 * $max_score_in_matrix);
    
    for (my $i = 0; $i < scalar(@$zones); $i++) {
        my $z_start = @$zones[$i]->[0];  # Computer coord
        my $z_end   = @$zones[$i]->[1];  # Computer coord
        my $length  = $z_end - $z_start + 1;
        next if $length < $MINEXONSIZE;
        foreach my $length_prefix (0 .. ($region_nt_length - $MINEXONSIZE)) {
#print STDERR "ZONE = $i    PREFIX = $length_prefix    TIME = ",(time - $^T),"\n";
            foreach my $length_suffix (0 .. ($region_nt_length - $MINEXONSIZE-$length_prefix)) {
                my $nt_length_missing_exon = $region_nt_length - ($length_prefix + $length_suffix);
                next if $nt_length_missing_exon > $region_nt_length;
                
                my $prefix = substr($seq,$intron_start - 1,$length_prefix);
                my $suffix = substr($seq,$intron_end - $length_suffix,$length_suffix);
                foreach my $pos ($z_start..($z_end-$nt_length_missing_exon)) {
                    my $core        = substr($seq,$pos,$nt_length_missing_exon);
                    my $length_core = length($core);
                    next if $length_core <= 6 && $ini_pam_sc >= 0;
                    my $exon_seq    = $prefix.$core.$suffix;
                    my $prot_seq    = &TranslateInProt($exon_seq);
                    next if index($prot_seq, "*") >= 0 ;
                    my $pam_score        = &CalculatePamScore($prot_seq,$research_seq);
                    my $len_fisrt_intron = $pos - $intron_start + 1;
                    my $info_about_hyp_exon = { seq       => $prot_seq,
                                                nt_seq    => $exon_seq,
                                                pam_score => $pam_score,
                                                prefix    => $length_prefix,
                                                core      => $length_core,
                                                suffix    => $length_suffix,
                                                position  => $pos,
                                                len_first_intron => $len_fisrt_intron
                                              };
                    push(@$list_of_hyp_exons,$info_about_hyp_exon);
                }
            }
        }
        @$list_of_hyp_exons   = sort { $b->{"pam_score"} <=> $a->{"pam_score"} } @$list_of_hyp_exons;
    }
    return $list_of_hyp_exons;
}

sub DefineZone {
    my $intron       = shift;
    my $isMinus      = shift;
    my $intron_start = shift;
    my $intron_end   = shift;
    my $len_seq      = shift; 
    
    my $apc        = $intron->get_idbyRNAw();
    my $apl        = $apc->get_annotpairlist();
    my $nb_intron  = scalar(@$apl);
    my $zone_coord = [];
    
    if ($nb_intron == 0) {
        my $start = $intron_start + $MININTRONSIZE - 1;
        my $end   = $intron_end   - $MININTRONSIZE - 1;
        push(@$zone_coord, [$start,$end]);
    }
    elsif ($nb_intron == 1) {
        my $ap = $apl->[0];
        my ($ap_start,$ap_end) = &ApPosStrandFW($ap,$len_seq);
        my $start1   = $intron_start + $MININTRONSIZE - 1;
        my $end1     = $ap_start - 2;
        my $start2   = $ap_end;
        my $end2     = $intron_end - $MININTRONSIZE - 1;
        push(@$zone_coord, [$start1,$end1]) if $end1   > $start1;
        push(@$zone_coord, [$start2,$end2]) if $end2   > $start2;
    }
    elsif ($nb_intron == 2) {
        my $ap1 = $apl->[0];
        my $ap2 = $apl->[1];
        my ($ap1_start,$ap1_end) = &ApPosStrandFW($ap1,$len_seq);
        my ($ap2_start,$ap2_end) = &ApPosStrandFW($ap2,$len_seq);
        
        my $start1   = $intron_start + $MININTRONSIZE - 1;
        my $end1     = $ap1_start - 2;
        my $start2   = $ap1_end;
        my $end2     = $ap2_start - 2;
        my $start3   = $ap2_end;
        my $end3     = $intron_end - $MININTRONSIZE - 1;
        push(@$zone_coord, [$start2,$end2]) if $end2   > $start2;  # Central zone in first
        push(@$zone_coord, [$start1,$end1]) if $end1   > $start1;
        push(@$zone_coord, [$start3,$end3]) if $end3   > $start3;
    }
    return $zone_coord;
}

sub CalculatePamScore {
    my $seq_of_hyp_exon = shift;
    my $research_seq    = shift;
    
    die "Hypothetic exon have not the same length that research seq" 
        if scalar(@$research_seq) != length($seq_of_hyp_exon);
    my $length =  length($seq_of_hyp_exon);
    
    my $score = 0;
    foreach my $pos (0 .. $length - 1){
        my $nt_in_hyp_exon = substr($seq_of_hyp_exon,$pos,1);
        my $hash_of_nt     = $research_seq->[$pos];
        while ( my ($nt_in_ref, $percent) = each(%$hash_of_nt)) {
            $score += $percent * $matrix->get_entry($nt_in_hyp_exon,$nt_in_ref);
        }
    }
    return $score;
}

sub SelectBestHypExons {
    my $list_of_hyp_exons = shift;
    
    my $best_hyp_exons    = [];
    my $best_pam_score    = @$list_of_hyp_exons[0]->{"pam_score"};
    my $best_splice_score = @$list_of_hyp_exons[0]->{"splice_score"};
    my $best_position     = @$list_of_hyp_exons[0]->{"position"};
    my $best_core         = @$list_of_hyp_exons[0]->{"core"};
    
    foreach my $hyp_exon (@$list_of_hyp_exons) {
        my $pam_score    = $hyp_exon->{"pam_score"};
        my $splice_score = $hyp_exon->{"splice_score"};
        my $position     = $hyp_exon->{"position"};
        my $core         = $hyp_exon->{"core"};
        next if $pam_score < $best_pam_score;
        next if $splice_score < $best_splice_score - 0.05;
        next if abs($best_position - $position) < 6 && abs($best_position - $position) != 0;
        next if abs(($best_position + $best_core) - ($position + $core)) < 6 && abs(($best_position + $best_core) - ($position + $core)) != 0;
        push(@$best_hyp_exons,$hyp_exon);
    }
    return $best_hyp_exons;
}

sub DefineEachIntronType {
    my $best_hyp_exons = shift;
    my $nb_intron      = shift;
    my $apl            = shift;
    my $isMinus        = shift;
    my $len_seq        = shift;
    
    foreach my $best_hyp_exon (@$best_hyp_exons) {
        my $hyp_exon_pos = $best_hyp_exon->{"position"};
        if ($nb_intron == 0) {
             $best_hyp_exon->{"ap_first_intron"}  = undef;
             $best_hyp_exon->{"ap_second_intron"} = undef;
        }
        elsif ($nb_intron == 1) {
            my $ap = $apl->[0];
                        
            my ($ap_start,$ap_end) = &ApPosStrandFW($ap,$len_seq);
            $best_hyp_exon->{"ap_first_intron"}  = undef if $hyp_exon_pos <  $ap_start;
            $best_hyp_exon->{"ap_second_intron"} = $ap   if $hyp_exon_pos <  $ap_start;
            $best_hyp_exon->{"ap_first_intron"}  = $ap   if $hyp_exon_pos >= $ap_start;
            $best_hyp_exon->{"ap_second_intron"} = undef if $hyp_exon_pos >= $ap_start;
        }
        elsif ($nb_intron == 2) {
            my $ap1 = $apl->[0];
            my ($ap1_start,$ap1_end) = &ApPosStrandFW($ap1,$len_seq);
            
            my $ap2 = $apl->[1];
            my ($ap2_start,$ap2_end) = &ApPosStrandFW($ap2,$len_seq);
            
            $best_hyp_exon->{"ap_first_intron"}  = undef  if $hyp_exon_pos <  $ap1_start;
            $best_hyp_exon->{"ap_second_intron"} = $ap1   if $hyp_exon_pos <  $ap1_start;
            $best_hyp_exon->{"ap_first_intron"}  = $ap2   if $hyp_exon_pos >= $ap2_start;
            $best_hyp_exon->{"ap_second_intron"} = undef  if $hyp_exon_pos >= $ap2_start;
            $best_hyp_exon->{"ap_first_intron"}  = $ap1   if ($ap1_start < $hyp_exon_pos && $hyp_exon_pos < $ap2_start);
            $best_hyp_exon->{"ap_second_intron"} = $ap2   if ($ap1_start < $hyp_exon_pos && $hyp_exon_pos < $ap2_start);
         }
    }
}

sub AddSpliceScore {
    my $seq            = shift;
    my $old_intron     = shift;
    my $best_hyp_exons = shift;
    my $isMinus        = shift;

    foreach my $best_hyp_exon (@$best_hyp_exons) {
        my $score_nt_first_intron   = 0;
        my $score_nt_second_intron  = 0;
        my $start_old_intron        = $old_intron->get_start();
        my $end_old_intron          = $old_intron->get_end();
           $start_old_intron        = length($seq) + 1 - $start_old_intron if $isMinus;
           $end_old_intron          = length($seq) + 1 - $end_old_intron   if $isMinus;
        
        my $start_first_intron      = $start_old_intron + $best_hyp_exon->{"prefix"};
        my $end_first_intron        = $best_hyp_exon->{"position"};
        
        my $type_first_intron = "";
        if ($best_hyp_exon->{"ap_first_intron"}) { 
        my $first_intron            = $best_hyp_exon->{"ap_first_intron"};
        my $first_intron_startline  = $first_intron->get_startline();
           $type_first_intron       = $1    if $first_intron_startline =~ m#group=(.+)#;
            die "Internal error : external AP does not contain type on startline?!?\n" unless $type_first_intron;
        }
        
        my $start_second_intron     = $end_first_intron + $best_hyp_exon->{"core"} + 1;
        my $end_second_intron       = $end_old_intron - $best_hyp_exon->{"suffix"};
        
        my $type_second_intron = "";
        if ($best_hyp_exon->{"ap_second_intron"}) { 
        my $second_intron           = $best_hyp_exon->{"ap_second_intron"} if $best_hyp_exon->{"ap_second_intron"};
        my $second_intron_startline = $second_intron->get_startline();
           $type_second_intron      = $1    if $second_intron_startline =~ m#group=(.+)#;
            die "Internal error : external AP does not contain type on startline?!?\n" unless $type_second_intron;
        }
        
        my $best_splice_core    = 0;
           $best_splice_core   += ($type_first_intron  ne "II" ? 25 : 64.5);
           $best_splice_core   += ($type_second_intron ne "II" ? 25 : 64.5);

        if ($type_first_intron eq "II") {
            $score_nt_first_intron = &ScoreNtLTypeII($seq,$start_first_intron,0) 
                                   + &ScoreNtRTypeII($seq,$end_first_intron,0);
        } else {
            $score_nt_first_intron = &ScoreNtLTypeI($seq,$start_first_intron,0) 
                                   + &ScoreNtRTypeI($seq,$end_first_intron,0);
        }
        if ($type_second_intron eq "II") {
            $score_nt_second_intron = &ScoreNtLTypeII($seq,$start_second_intron,0) 
                                    + &ScoreNtRTypeII($seq,$end_second_intron,0);
        } else {
            $score_nt_second_intron = &ScoreNtLTypeI($seq,$start_second_intron,0) 
                                    + &ScoreNtRTypeI($seq,$end_second_intron,0);
        }
        my $sc = ($score_nt_first_intron + $score_nt_second_intron) / $best_splice_core;
        $best_hyp_exon->{"splice_score"} = ($score_nt_first_intron + $score_nt_second_intron) / $best_splice_core;
    }
}

sub AddMiniExon {
    my $introns        = shift;
    my $exons          = shift;
    my $i              = shift;
    my $best_solution  = shift;
    my $isMinus        = shift;
    
    my $prefix_len            = ( $isMinus ? -$best_solution->{"prefix"} :  $best_solution->{"prefix"});
    my $core_len              = ( $isMinus ? -$best_solution->{"core"}   :  $best_solution->{"core"});  
    my $suffix_len            = ( $isMinus ?  $best_solution->{"suffix"} : -$best_solution->{"suffix"}); 
    my $first_intron_len      = ( $isMinus ? -$best_solution->{"len_first_intron"} : $best_solution->{"len_first_intron"});
    my $strand                = ( $isMinus ? "-" : "+");
    my $adjust_start_new_exon = ( $isMinus ?  -1 :  1);
    my $adjust_end_new_exon   = ( $isMinus ?   1 : -1);
    my $adjust_start_intron   = ( $isMinus ?  -1 :  1);
    my $adjust_end_intron     = ( $isMinus ?   1 : -1);
    
    my $exon_prev    = $exons->[$i];
    my $large_intron = $introns->[$i];
    
    # Exons #
    # Adjust end of previous exon
    my $end_of_previous_exon = $exon_prev->get_dnaend() + $prefix_len;
    $exon_prev->set_dnaend($end_of_previous_exon);
    
    # Add the mini exon
    my $start_of_new_exon = $end_of_previous_exon - $prefix_len + $first_intron_len + $adjust_start_new_exon;
    my $end_of_new_exon   = $start_of_new_exon + $core_len + $adjust_end_new_exon;
    my $new_exon = new PirObject::Exon (
                                             dnastart  => $start_of_new_exon,
                                             dnaend    => $end_of_new_exon,
                                             strand    => $strand
                                           );
    splice(@$exons, $i + 1, 0, $new_exon);
    
    # Adjust start of next exon
    my $exon_next = $exons->[$i+2];
    my $start_of_next_exon  = $exon_next->get_dnastart() + $suffix_len;
    $exon_next->set_dnastart($start_of_next_exon);
    
    # Introns #
    my $apc                   = $large_intron->get_idbyRNAw();
    # The first intron
    my $start_of_first_intron = $end_of_previous_exon + $adjust_start_intron;
    my $end_of_first_intron   = $start_of_new_exon    + $adjust_end_intron;
    my $first_intron_apc      = $apc->DeepClone();
    
    my $first_intron = new PirObject::Intron (
                                             start    => $start_of_first_intron,
                                             end      => $end_of_first_intron,
                                             strand   => $strand,
                                             idbyRNAw => $first_intron_apc
                                           );
    my $ap_first_intron = $best_solution->{"ap_first_intron"};
    if ($ap_first_intron) {
        my $apc1               = $first_intron->get_idbyRNAw();
        my $annotpairlistarray = [$ap_first_intron];
        $apc1->set_annotpairlist($annotpairlistarray);
        my $startline  = $ap_first_intron->get_startline();           
        my $type       = $1    if $startline =~ m#group=(.+)#;
        die "Internal error : external AP does not contain type on startline?!?\n" unless $type;
        $first_intron->set_type($type);
    }

    # The second intron
    my $start_of_second_intron = $end_of_new_exon     + $adjust_start_intron;
    my $end_of_second_intron   = $start_of_next_exon  + $adjust_end_intron;
    my $second_intron_apc      = $apc->DeepClone();
    
    my $second_intron = new PirObject::Intron (
                                             start    => $start_of_second_intron,
                                             end      => $end_of_second_intron,
                                             strand   => $strand,
                                             idbyRNAw => $second_intron_apc
                                           );
    
    my $ap_second_intron = $best_solution->{"ap_second_intron"};
    if ($ap_second_intron) {
        my $apc2               = $second_intron->get_idbyRNAw();
        my $annotpairlistarray = [$ap_second_intron];
        $apc2->set_annotpairlist($annotpairlistarray);
        my $startline  = $ap_second_intron->get_startline();           
        my $type       = $1    if $startline =~ m#group=(.+)#;
        die "Internal error : external AP does not contain type on startline?!?\n" unless $type;
        $second_intron->set_type($type);
    }
    
    splice(@$introns, $i, 1);
    splice(@$introns, $i, 0, $first_intron,$second_intron);
}

sub AddCommentsForOtherSolutions {
    my $hyprot         = shift;
    my $i              = shift;
    my $best_hyp_exons = shift;
    my $isMinus        = shift;
    my $contigname     = shift;
    
    my ($introns,$exons) = ( $hyprot->get_introns(), $hyprot->get_exons());
    
    my $strand       = ( $isMinus ? "-" : "+");
    my $arrow        = ( $isMinus ? "<==" : "==>");
    my $exon_prev    = $exons->[$i];
    my $exon_next    = $exons->[$i+1];
    
    my $list_alt_exons = $hyprot->get_altexons();
    foreach my $solution (@$best_hyp_exons) {
        
        my $prefix_len            = ( $isMinus ? -$solution->{"prefix"} :  $solution->{"prefix"});
        my $core_len              = ( $isMinus ? -$solution->{"core"}   :  $solution->{"core"});
        my $suffix_len            = ( $isMinus ?  $solution->{"suffix"} : -$solution->{"suffix"});
        my $first_intron_len      = ( $isMinus ? -$solution->{"len_first_intron"} : $solution->{"len_first_intron"});
        my $adjust_start_new_exon = ( $isMinus ?  -1 :  1);
        my $adjust_end_new_exon   = ( $isMinus ?   1 : -1);
        my $number_exon           = $i+2;
        
        # Define end of previous exon.
        my $end_of_previous_exon = $exon_prev->get_dnaend() + $prefix_len;
        
        # Define pos of hypothetic exon.
        my $start_of_hyp_exon = $end_of_previous_exon - $prefix_len + $first_intron_len + $adjust_start_new_exon;
        my $end_of_hyp_exon   = $start_of_hyp_exon + $core_len + $adjust_end_new_exon;
        
        # Define start of next exon.
        my $start_of_next_exon  = $exon_next->get_dnastart() + $suffix_len;
        
        my $start_line = ";; Alternative solution for exon $number_exon, end previous exon = $end_of_previous_exon";
        my $end_line   = ";; Alternative solution for exon $number_exon, start next exon = $start_of_next_exon";
        
        my $AP = new PirObject::AnnotPair(
                                      type      => "G",
                                      genename  => "comment",
                                      startpos  => $start_of_hyp_exon,
                                      endpos    => $end_of_hyp_exon,
                                      direction => $arrow,
                                      startline => $start_line,
                                      endline   => $end_line,
                                      ); 
        push(@$list_alt_exons, $AP);
        &AddAnnotToPirMaster($contigname,$AP);
    }
    $hyprot->set_altexons($list_alt_exons);
}

#-------------------------------------------------#
# Subs for putting annotations in the masterfile  #
#-------------------------------------------------#

sub AnnotateMfFromHYPPROTSArray {
    # This function annotates the masterfile from the blast results
    foreach my $hyprot (@$HYPPROTS) {
        my $name = $hyprot->get_name();
        next if (not (defined ($name)) or ($name eq ""));
        
        my $contigname = $hyprot->get_contigname();
        my $contig     = $pirmaster->GetContigByName($contigname);
        my $start      = $hyprot->get_start();
        my $alt_start  = $hyprot->get_altstart();
        my $end        = $hyprot->get_end();
        my $prot       = $hyprot->get_protein();
        my $exons      = $hyprot->get_exons();
        my $isMinus    = ($hyprot->get_strand() == 1 ? 0 : 1);
        my $fusion     = $hyprot->get_hypfusiongene();
        my $idByBlast  = $hyprot->get_idbyblast();
        my $idByExo    = $hyprot->get_idbyexo();
        my $frameshift = $hyprot->get_frameshift();
        my $homologous = $hyprot->get_homologous();
        my $arrow      = ($isMinus ? '<==' : '==>');
        
        my $NotToAnnot = &SuspectIsInAFamily($hyprot,$contig);
        next               if $NotToAnnot == 1;
        my $ToComment  = 1 if $NotToAnnot == 2;
                
        # Annot the gene
        my $linename             = $name;                     # The name gene in start and endline
        my ($startline,$endline) = ( $ToComment ? (";",";") : ("",""));
        
        # Define start line and end line
        $startline  .= ";     G-$linename $arrow start";
        $endline    .= ";     G-$linename $arrow end";
        
        my $isFusioned      = $hyprot->get_hypfusiongene() || undef;
        my $startlinenumber = ( $isMinus && $isFusioned ? 0 : 2);
        my $endlinenumber   = ( $isMinus && $isFusioned ? 2 : 0);
        
        my $info_fusion     = $hyprot->get_hypfusiongene() || undef;
        my $fusion_name     = $info_fusion->get_name()     || undef if $info_fusion;
        my $posiffusion     = $hyprot->get_posiffusion()   || undef;
        
        my $len_orf = 0;
        if ( !(defined($isFusioned)) && $alt_start && (abs($start-$alt_start)/3 >= 100)  ) {
            $len_orf     = abs($start-$alt_start)/3;
            $fusion_name = "orf$len_orf";
            $posiffusion = 2;
            $startlinenumber = ( $isMinus ? 0 : 2);
            $endlinenumber   = ( $isMinus ? 2 : 0);
        }
        
        my $A_type           = "C" if $ToComment;
        my $altexons         = $hyprot->get_altexons();
        my $FirstMissingExon = ($hyprot->get_firstExonerateMatch() && $hyprot->get_firstExonerateMatch() > 10) ? 1 : 0;
        my $protannot = new PirObject::AnnotPair (
                                                   type              => $A_type || "G", 
                                                   genename          => "$name",
                                                   startpos          => $start,
                                                   endpos            => $end,
                                                   direction         => $arrow,
                                                   startline         => $startline,
                                                   endline           => $endline,
                                                   startlinenumber   => $startlinenumber,
                                                   endlinenumber     => $endlinenumber,
                                                   posiffusion       => $posiffusion,
                                                   namefusiongene    => $fusion_name,
                                                   idbyblast         => $idByBlast,
                                                   idbyexo           => $idByExo,
                                                   altexons          => $altexons,
                                                   firstmissingexon  => $FirstMissingExon
                                                 );
        $protannot->set_exoscore($exons->[0]->get_exoscore) if scalar(@$exons) == 1;
        my $startwarning = $hyprot->get_startwarning() || "";
        # Add comment for frameshift
        $startwarning .= ($startwarning ne "" ?
                         " / present probably a frameshift" 
                       : "present probably a frameshift") 
                           if $frameshift;

        # Add comment for alternative start
        $startwarning .= ($startwarning ne "" ?
                         " / alternative ATG start pos $alt_start" 
                       : "alternative ATG start pos $alt_start")
                           if (!$fusion && $alt_start && $len_orf < 100);
        
        # Annotation of fusion between Orf and gene
        if ($alt_start && $len_orf >= 100 && !$fusion) {
            my $orf_end                = ( $isMinus ? $start + 1 : $start - 1);
            my ($start_line,$end_line) = ( $ToComment ? (";",";") : ("",""));
               $start_line            .= ";     G-$fusion_name $arrow start";
               $end_line              .= ";     G-$fusion_name $arrow end";
            
            my $orfannot = new PirObject::AnnotPair (
                                       type              => $A_type || "G", 
                                       genename          => $fusion_name,
                                       startpos          => $alt_start,
                                       endpos            => $orf_end,             # gene start
                                       direction         => $arrow,
                                       startline         => $start_line,
                                       endline           => $end_line,
                                       startlinenumber   => $startlinenumber,
                                       endlinenumber     => $endlinenumber,
                                       namefusiongene    => $name,
                                       posiffusion       => 1
                                     );
            &AddAnnotToPirMaster($contigname,$orfannot);
            $startwarning .= ($startwarning ne "" ?  
                         " / contiguous and in phase with $fusion_name" 
                       : "contiguous and in phase with $fusion_name");
        }
        
        my $prot_startline = $protannot->get_startline();
        $prot_startline .= " ;; mfannot: $startwarning" if $startwarning;
        $protannot->set_startline($prot_startline);
        
        my $res = &AddAnnotToPirMaster($contigname,$protannot);

        # Go out of the function if the protein has not been added
        next if (!defined ($res) or $res == 0);
        &AddCommForFirstStart($hyprot,$contigname);
        
        next if ($name =~ /^orf/);       # if it's an ORF, then it goes to through, because an ORF must not have
        next if (scalar (@$exons) <= 1); # if there is only one exon, and if option is not checked, go to the next prot
        
        # Annotating exons
        my $number = 1;
        foreach my $exon (@$exons) {
            my $start     = $exon->get_dnastart();
            my $end       = $exon->get_dnaend();
            my $strand    = $exon->get_strand();
            my $exo_score = $exon->get_exoscore();
            my $insertion = $exon->get_insertion();
            my $frameshift_size = $exon->get_frameshiftsize();
            
            my ($start_line,$end_line) = ( $ToComment ? (";",";") : ("",""));

               $start_line .= ";     G-$linename-E$number $arrow start";
               $start_line .= " ;; mfannot: frameshift of $frameshift_size nt" if $frameshift_size;
               if (defined($insertion)) {
               $start_line .= $start_line =~ m/ ;; \.+/ ?
                              " / insertion of $insertion a.a" 
                            : " ;; mfannot: insertion of $insertion a.a";
               }
               $end_line   .= ";     G-$linename-E$number $arrow end";
            
            my $annot = new PirObject::AnnotPair (
                                                       type      => $A_type || "E",
                                                       genename  => "$name",
                                                       startpos  => $start,
                                                       endpos    => $end,
                                                       direction => $arrow,
                                                       startline => $start_line,
                                                       endline   => $end_line,
                                                       exoscore  => $exo_score
                                                     );
            $number++;
            &AddAnnotToPirMaster($contigname,$annot);
        } # End foreach $exon

        # Annotating introns
        my $introns = $hyprot->get_introns();
        $number = 1;
        foreach my $intron (@$introns) {
            my $start    = $intron->get_start();
            my $end      = $intron->get_end();
            my $strand   = $intron->get_strand();
            my $type     = $intron->get_type();
            my $idbyRNAw = $intron->get_idbyRNAw();
            my $comment  = $intron->get_comment() || "";
            
            my ($start_line,$end_line) = ( $ToComment ? (";",";") : ("",""));
               $start_line .= ";     G-$linename-I$number $arrow start";
               $start_line .= " /group=$type" if $type;
               $end_line   .= ";     G-$linename-I$number $arrow end";
           my $I_startwarning = "$comment" if $comment;

            my $annot = new PirObject::AnnotPair (
                                                         type         => $A_type || "I",
                                                         genename     => "$name",
                                                         startpos     => $start,
                                                         endpos       => $end,
                                                         direction    => $arrow,
                                                         startline    => $start_line,
                                                         endline      => $end_line,
                                                         introntype   => $type
                                                        );
            my $I_startline = $annot->get_startline();
            $I_startline   .= " ;; mfannot: $I_startwarning" if $I_startwarning;
            $annot->set_startline($I_startline);                                          
            $number++;
            &AddAnnotToPirMaster($contigname,$annot);
            
            my $APC = $idbyRNAw;
            next if !$idbyRNAw;
            my $APL = $APC->get_annotpairlist();
            my $nb_intron = scalar(@$APL);
            if ($nb_intron > 1){
                foreach my $AP (@$APL) {
                    &AddAnnotToPirMaster($contigname,$AP) if scalar(@$APL > 1);
                }
            }
        } # End foreach $intron
    } # End foreach $hyprot
    &CommentAllRNAwIntron;
} # End sub

sub SuspectIsInAFamily {
    my ($hyprot,$contig) = @_;
    my $HP_start     = $hyprot->get_start();
    my $HP_stop      = $hyprot->get_end();
    my $HP_name      = $hyprot->get_name();
    my $HP_idbyblast = $hyprot->get_idbyblast();
    my $HP_introns   = $hyprot->get_introns();
    my $HP_exons     = $hyprot->get_exons();
        
    ($HP_start, $HP_stop) = ($HP_stop, $HP_start) if $HP_start > $HP_stop;
    my $annot_who_overlap = &WhatOverlapsThis($HP_start,$HP_stop,$contig);
    return 0 if scalar(@$annot_who_overlap) == 0;
    
    my ($IsInAP,$ContainAP)    = &IsInOrContainAP($annot_who_overlap,$HP_start,$HP_stop);
    my ($OVInPercent,$AP_name,$AP_score) = (0,"",0);
    my $hyprot_score = GetExoScore($HP_exons);
    if (scalar(@$IsInAP) != 0) {
        # HP is in AP
        my $to_rm            = [];
        foreach my $list_who_overlap (@$IsInAP) {
            my ($HP_isIntronic,$G_AP,$G_score,$count) = (0,"",0,0);
            my $containComment = 0;
            foreach my $AP_who_overlap (@$list_who_overlap ) {
                my $AP        = $AP_who_overlap->[2];
                my $AP_type   = $AP->get_type();
                my $AP_name = $AP->get_genename();
                $containComment = 1 if $AP_name eq "comment";
                   $G_AP      = $AP if $AP_type eq "G";
                my $exo_score = $AP->get_exoscore();
                $G_score     += $exo_score if $exo_score;
                $count++                   if $exo_score;

                next if $AP_type ne "I"; # Was id by exo
                my ($I_start, $I_stop) = ($AP_who_overlap->[0],$AP_who_overlap->[1]);
                   ($I_start, $I_stop) = ($I_stop, $I_start) if $I_start > $I_stop;
                if ($I_start <= $HP_start && $I_stop >= $HP_stop) {
                    $HP_isIntronic = 1;
                    last;
                }
            }
            next if $containComment;

            $G_score = ($count == 0 ? $G_AP->get_exoscore : $G_score/$count);
            if ($HP_isIntronic == 0) {
                if ($HP_idbyblast) {
                    push(@$to_rm,$list_who_overlap);
                }
                else {
                    return 1 if !$G_AP->get_idbyexo();
                    ($G_score > $hyprot_score) ? return 1 : return 2;
                }
            }
        }
        &RemoveAPlist($to_rm,$contig);
    }

    if (scalar(@$ContainAP) != 0) {
        # HP is in AP
        my ($to_rm,$to_cm,$same_annot) = ([],[],0);
        foreach my $list_who_overlap (@$ContainAP) {
            my ($G_AP_isIntronic,$G_AP,$G_score,$count) = (0,"",0,0);
            my $containComment = 0;
            foreach my $AP_who_overlap (@$list_who_overlap) {
                my $AP      = $AP_who_overlap->[2];
                my $AP_type = $AP->get_type();
                my $AP_name = $AP->get_genename();
                $containComment = 1 if $AP_name eq "comment";
                   $G_AP    = $AP if $AP_type eq "G";
                my $exo_score = $AP->get_exoscore();
                $G_score += $exo_score if $exo_score;
                $count++ if $exo_score;

                next if $AP_type ne "G";
                my ($AP_start, $AP_stop) = ($AP_who_overlap->[0],$AP_who_overlap->[1]);
                   ($AP_start, $AP_stop) = ($AP_stop, $AP_start) if $AP_start > $AP_stop;

                $same_annot = 1 if $AP_start == $HP_start && $AP_stop == $HP_stop && $AP_name eq $HP_name;
                foreach my $intron (@$HP_introns) {
                    my ($I_start, $I_stop) = ($intron->get_start(),$intron->get_end());
                       ($I_start, $I_stop) = ($I_stop, $I_start) if $I_start > $I_stop;
                    if ($I_start <= $AP_start && $I_stop >= $AP_stop) {
                        $G_AP_isIntronic   = 1;
                        last;
                    }
                }
                last if $G_AP_isIntronic;
            }
            next if $containComment;

            $G_score = ($count == 0 ? 0 : $G_score/$count);
            if ($G_AP_isIntronic == 0) {
                if ($HP_idbyblast || $same_annot == 1) {
                    push(@$to_rm,$list_who_overlap);
                }
                elsif ( !$HP_idbyblast && $G_AP->get_idbyexo()) {
                    return 1 if ( $G_score > $hyprot_score );
                    push(@$to_rm,$list_who_overlap);
                }
                else {
                    return 1 if !$G_AP->get_idbyexo();
                    push(@$to_cm,$list_who_overlap);
                }
            }
        }
        &RemoveAPlist($to_rm,$contig);
        &CommentAPlist($to_cm)
    }
    else {
        &ReadFamilyList() if (scalar(keys %$FAMILY_LIST) == 0);
        ($OVInPercent,$AP_name,$AP_score) = &OVInPercent($annot_who_overlap,$HP_start,$HP_stop,$HP_name);
    }
    return 0 if (scalar(@$ContainAP) != 0 || scalar(@$IsInAP) != 0) ;
    
    if    ($OVInPercent == 101 && !$HP_idbyblast){
        return 1;
    }
    elsif ($OVInPercent >  75 && !$HP_idbyblast && $hyprot_score < $AP_score){
        return 1;
    }
    elsif ($OVInPercent >  75){
        $add_text_in_header .= ";; Gene coding for $HP_name and $AP_name is probably in family\n";
        return 0;
    }
    else {
        return 0;
    }
}

sub ReadFamilyList {    
    my $infh  = new IO::File "<$family_lib"
        or die "Can't read from file '$family_lib': $!\n";
    
	while( <$infh> ){
        my $line = $_;
        next if $line =~ m/^#/ || $line =~ m/^\s+$/;
        $line =~ s/\n$//;
        my @list = split(/\s+=\s+/,$line);
        next if scalar(@list) == 0;
        my $MainName = lc($list[0]);
        foreach my $name (@list) {
            $name = lc($name);
            $FAMILY_LIST->{$name} = $MainName;
        }
    }
}

sub OVInPercent {
    my ($annot_who_overlap,$HP_start,$HP_stop,$HP_name) = @_;
    
    my $HP_len    = abs($HP_start-$HP_stop);
    my ($OVPercent,$AP_name,$AP_score) = (0,"","");
    foreach my $list_who_overlap (@$annot_who_overlap) {
        foreach my $AP_who_overlap (@$list_who_overlap ) {
            my $AP      = $AP_who_overlap->[2];
            my $All     = $AP_who_overlap->[3];
            my $AP_type = $AP->get_type();
            next if $AP_type ne "G";
            return 0 if $AP->get_startline() =~ /G-orf\d+/;
            $AP_name    = $AP->get_genename();
            $AP_score   = $AP->get_exoscore || 0;
            
            # Special case know is a family...
            if (defined($FAMILY_LIST->{lc($HP_name)}) && defined($FAMILY_LIST->{lc($AP_name)})) {
                return (101,$AP_name,$AP_score) if $FAMILY_LIST->{lc($HP_name)} eq $FAMILY_LIST->{lc($AP_name)};
            }
            my ($AP_start, $AP_stop) = ($AP_who_overlap->[0],$AP_who_overlap->[1]);
               ($AP_start, $AP_stop) = ($AP_stop, $AP_start) if $AP_start > $AP_stop;
            my $AP_len = abs($AP_start - $AP_stop);
            my $Min_len = $AP_len > $HP_len ? $HP_len + 1 : $AP_len + 1;
            my $OVLen = 0;
            if ($HP_start < $AP_start){
                $OVLen = $HP_stop - $AP_start + 1;
            }
            else {
                $OVLen = $AP_stop - $HP_start + 1;
            }    
            $OVPercent = ($OVLen*100)/$Min_len;
        }
    }
    return ($OVPercent,$AP_name,$AP_score);
}

sub IsInOrContainAP {
    my ($annot_who_overlap,$HP_start,$HP_stop) = @_;
    
    my $IsInAP    = []; # If HP is in an other Gene
    my $ContainAP = []; # List of AP contained in HP
    
    foreach my $list_who_overlap (@$annot_who_overlap) {
        foreach my $AP_who_overlap (@$list_who_overlap ) {
            my $AP      = $AP_who_overlap->[2];
            my $All     = $AP_who_overlap->[3];
            my $AP_type = $AP->get_type();
            next if $AP_type ne "G";
            my ($AP_start, $AP_stop) = ($AP_who_overlap->[0],$AP_who_overlap->[1]);
               ($AP_start, $AP_stop) = ($AP_stop, $AP_start) if $AP_start > $AP_stop;
            if ($HP_start <= $AP_start && $HP_stop >= $AP_stop) { 
                # AP in HP
                push(@$ContainAP, $list_who_overlap);
                last;
            }
            elsif ($AP_start <= $HP_start && $AP_stop >= $HP_stop) {
                # HP in AP
                push(@$IsInAP, $list_who_overlap);
                last;
            }
        }
    }
    return ($IsInAP,$ContainAP);
}
sub GetExoScore {
    my $exons = shift;

    my ($count,$score) = (0,0);
    foreach my $exon (@$exons){
        next if !$exon->get_exoscore();
        $score += $exon->get_exoscore();
        $count++;
    }
    my $hyprot_score = ($count == 0 ? 0 : $score/$count);
    return $hyprot_score;
}

sub RemoveAPlist {
    my ($list_to_rm,$contig) = @_;
    
    my $all_annots = $contig->get_annotations();
    my $alt_exons = [];
    foreach my $list_who_overlap (@$list_to_rm) {
        foreach my $AP_who_overlap (@$list_who_overlap) {
            my $AP_alt_exons  = $AP_who_overlap->[2]->get_altexons();
            push(@$alt_exons,$AP_alt_exons) if scalar(@$AP_alt_exons) != 0;
        }
    }
    
    # Remove Gene Exon and Intron.
    for (my $i = @$all_annots - 1; $i >= 0 ; $i--) {
        my $contig_AP    = @$all_annots[$i];
        my $id_contig_AP = $1 if  scalar($contig_AP) =~ m/0x(.+)\)/;
        
        foreach my $list_who_overlap (@$list_to_rm) {
            foreach my $AP_who_overlap (@$list_who_overlap ) {
                my $rm_AP         = $AP_who_overlap->[2];
                my $AP_alt_exons  = $rm_AP->get_altexons();
                my $id_rm_AP   =  $1 if  scalar($rm_AP) =~ m/0x(.+)\)/;
                splice(@$all_annots, $i, 1) if $id_rm_AP eq $id_contig_AP;
            }
        }
    }
    
    # Remove alt exons
    return if !$alt_exons;
    for (my $i = @$all_annots - 1; $i >= 0 ; $i--) {
        my $contig_AP    = @$all_annots[$i];
        my $id_contig_AP = $1 if  scalar($contig_AP) =~ m/0x(.+)\)/;
        
        foreach my $list_who_overlap (@$alt_exons) {
            foreach my $rm_AP (@$list_who_overlap) {
                my $id_rm_AP   =  $1 if  scalar($rm_AP) =~ m/0x(.+)\)/;
                splice(@$all_annots, $i, 1) if $id_rm_AP eq $id_contig_AP;
            }
        }
    }
}

sub AddCommForFirstStart {
    my ($hyprot,$contigname) = @_;

    my $posiffusion   = $hyprot->get_posiffusion()  || 0;
    my $arrow         = $hyprot->get_strand() eq "1" ? "==>" : "<==";
    my $name          = $hyprot->get_name();
    my $FirstStart    = $hyprot->get_FirstStart();
    my $start         = $hyprot->get_start();
    
    return if !$FirstStart;
    return if $posiffusion == 2;
    my $comment = new PirObject::AnnotPair( type            => "C",
                                            genename        => $name,
                                            startpos        => $FirstStart,
                                            startline       => ";; G-$name $arrow start ;; First start found $start",
                                            );
                                            
    &AddAnnotToPirMaster($contigname,$comment);
}

sub CommentAPlist {
    my $list_to_comment = shift; 
    
    foreach my $list_who_overlap (@$list_to_comment) {
        foreach my $AP_who_overlap (@$list_who_overlap ) {
            my $cm_AP      = $AP_who_overlap->[2];
            my $genename   = $cm_AP->get_genename();
            next if $genename eq "comment";
            $cm_AP->set_type("C");
            my ($startline,$endline) = (";",";");
            $startline .= $cm_AP->get_startline();
            $endline   .= $cm_AP->get_endline();
            $cm_AP->set_startline($startline);
            $cm_AP->set_endline($endline);
        }
    }
}

#-----------------------------------#
# Subs for using external programs  #
#-----------------------------------#

sub Annotate_Using_external_programs {
    my $conf_file       = PirObject::MfAnnotExternalProgs->ImportFromTextFile($EXTCONFIGFILE);
    my $genecomsets     = $conf_file->get_geneprogs(); # This is a HASH genename => <MfAnnotGeneCommandSet>
    my $ext_select_prog = shift || $EXTSELECTPROG;
    # Here we build a list of external programs to run; by default all
    # of them are executed, but this can be modified by the option --ext_select, which
    # we parse here.
    
    # Create one file per contig
    my $work_dir = "$TMPDIR/Contig";
    &CreateContigFile if (!(-d $work_dir));

    # Default: all of them
    my @allprogs      = map { split(/\s*,\s*/,$_) } keys %$genecomsets;
    my %allprogs      = map { lc($_) => 1  }        @allprogs;
    my %progs_to_run  = %allprogs; # copy, which will be adjusted
   
    # What do we have in --ext_select? Parse it
    $ext_select_prog="" if $ext_select_prog eq "all";
    my @ext_selected  = split(/\s*,\s*/, $ext_select_prog);

    my @no_ext = grep(/^no/ && $_ ne "none",@ext_selected);
    if (@no_ext) { 
        # There are some 'no', which means ( ALL minus the 'no's )
        foreach my $noext (@no_ext) {
            $noext =~ s/^no//;
            delete $progs_to_run{lc $noext};
        }
    } 
    elsif (@ext_selected) { 
        # There are no 'nos', which means --ext_select is the full list
        %progs_to_run = map { lc($_) => 1 } @ext_selected;
    } # No else needed
   
    # Print warnings about unknown names in --ext_select
    foreach my $prog (sort keys %progs_to_run) {
        next if $prog eq "none";
        print "   Warning: no external programs specified for '$prog' in '$EXTCONFIGFILE'\n"
        unless $allprogs{lc $prog};
    }
   
    # Run each external program command set.
    my @extcomsets = sort {
        $genecomsets->{$a}->get_filerank() <=> $genecomsets->{$b}->get_filerank()
    } keys %$genecomsets; # Now sorted; these are keys with possible MULTIPLE names, e.g. "rns,rnl"

    my %dir = ();
    tie %dir, 'IO::Dir', $work_dir;
    foreach my $comsetnames (@extcomsets) {
        foreach my $genename (split(/\s*,\s*/,$comsetnames)) {
            next if ! $progs_to_run{lc $genename};
            if (lc($genename) ne lc("IntronI") && lc($genename) ne lc("IntronII")) {
                print "    '$genename'...\n" if !$DEBUG;
            }
            foreach (keys %dir) {
                next if $_ =~ /^\./;
                next if $_ =~ /\.xml$/;
                next if !(-f "$work_dir/$_");
                my $commandobject = $genecomsets->{$comsetnames};
                my $mf            = "$work_dir/$_";
                my $out           = "$mf-$genename.xml";
                my $APC           = &ExecuteExternalProgram($commandobject,$genename,undef,$mf,$out);
                &AnnotateFromExternalAPC($genename,$APC);
                $annotate_intron_typeI  = 1 if lc($genename) eq lc("IntronI");
                $annotate_intron_typeII = 1 if lc($genename) eq lc("IntronII"); 
            } # End foreach genename1, genename2, ...
        } # End foreach "genename1,genename2"
    } # End foreach keys
} # End sub

sub CreateContigFile {
    mkdir("$TMPDIR/Contig",0700);
    my $contigs = $pirmaster->get_contigs();
    foreach my $contig (@$contigs) {
        my $seq       = $contig->get_sequence();
           $seq       =~ s/!//g;
        my $name      = $contig->get_name();
        
        my $contig_file = "$TMPDIR/Contig/$name";
        my $CF = new IO::File ">$contig_file" or die "Cannot open : $contig_file\n";
        print $CF ">$name\n$seq\n";
        $CF->close();
    }
}

sub ExecuteExternalProgram {
    my $commandobject             = shift;
    my $genename                  = shift;
    my $alternate_masterfile      = shift;
    my $alternate_plainmasterfile = shift;
    my $alternate_outfile         = shift;

    my $outfile_gene = $alternate_outfile || "$TMPDIR/result_for_$genename.xml";
   
    my $substitutions = {
        "OUTFILE"        => "$outfile_gene",       # What will be created, a series of AnnotPairCollections
        "PLAINFASTAFILE" => ($alternate_plainmasterfile || "$TMPDIR/mf_noCr.all"),
        "MASTERFILE"     => ($alternate_masterfile || "$MASTERFILE"),
        "DEBUG"          => $DEBUG ? "#" : "",     # See the config file text
        "GENENAME"       => $genename,             # Optional; the Execute command use this but you can override it yourself)
        "TMPDIR"         => "$TMPDIR",             # Mfannot's tmp dir
        "GENCODE"        => "$GENCODE",
        "MODPATH"        => "$MODEL_PATH", 
    };

    $commandobject->set_debug($DEBUG);
    my $OutAndErrDir = dirname($outfile_gene)."/err_out";
    unless(-d $OutAndErrDir) {mkdir $OutAndErrDir or die "Cannot create '$OutAndErrDir'";}
    my ($outfile,$errfile) = $commandobject->Execute(
                                                     "$OutAndErrDir",
                                                     "$OutAndErrDir",
                                                      $substitutions,
                                                     );

    # Read back AnnotPairCollections;
    my $infh = new IO::File "<$outfile_gene"; # Which should be your %OUTFILE%
    if (! $infh){ 
        print "Cannot read result for '$genename'; maybe there were problems with the commands?\n";
        print "See outfile '$outfile' and errfile '$errfile' for more info.\n" if $DEBUG;
        return [];
    }

    my @annotpaircollections = PirObject->FileHandleToObject($infh);
    $infh->close();
    \@annotpaircollections;
}

sub AnnotateFromExternalAPC {
    my $genename             = shift;
    my $annotpaircollections = shift; # Ref to array of APC
    
    # Process each AnnotPairCollection
    foreach my $annotcollection (@$annotpaircollections) {
        my $header       = $annotcollection->get_contigname();
        my ($contigname) = ($header =~ m#^>?\s*(\S+)#)
            or die "Can't parse header line '$header'\n";
        next if $contigname eq "consensus";
        my $contig      = $pirmaster->GetContigByName($contigname)
            or die "Can't get contig by name in AnnotateFromExternalAPC\n";
        my $dna_seq     = $contig->get_sequence();
           $dna_seq     =~ s/\!//g;
        my $seq_length  = $contig->get_sequencelength();
        # Annotate the results, using the annotpairlist field of
        # your annotcollection (an AnnotPairCollection object).
        my $annotpairs = $annotcollection->get_annotpairlist();
        foreach my $annot (@$annotpairs){
            my $type       = $annot->get_type()     || "G";
            my $a_genename = $annot->get_genename() || $genename;
            my $startpos   = $annot->get_startpos()
               || die "Can't find startpos() from annotpair obtained from external analysis?!? Object=\n" . $annot->ObjectToXML() . "\n";
            my $endpos     = $annot->get_endpos(); # Can be undef
            
            my $isMinus = 1  if defined($endpos) && $startpos > $endpos;
            my $arrow = $isMinus ? "<==" : "==>";
            &LocateIntrons($dna_seq,undef,$annot,$a_genename,$contigname,$isMinus)
                if (lc($a_genename) eq "rnl" || lc($a_genename) eq "rns" || lc($a_genename) eq "rnpb")
                                                   && $LVL_INTRON != 2;
            
            my $direction  = $annot->get_direction()  || $arrow;
            my $score      = $annot->get_score() || "";
            my $start_line = $annot->get_startline();
               $start_line = ";     G-$genename $arrow start" if !defined($start_line);
            my $end_line   = $annot->get_endline();  # Can be undef
               $end_line   = ";     G-$genename $arrow end"   if !defined($end_line) && $type eq "G";
            
            my ($AP_start, $AP_stop) = $startpos > $endpos ? ($endpos, $startpos) : ($startpos, $endpos);
            my $annot_who_overlap    = &WhatOverlapsThis($AP_start,$AP_stop,$contig);
            my ($IsInAP,$ContainAP)  = ([],[]);
               ($IsInAP,$ContainAP)  = &IsInOrContainAP($annot_who_overlap,$AP_start,$AP_stop) if $type ne "AC";
            if ((scalar(@$ContainAP) !=  0 || scalar(@$IsInAP) != 0) &&  $start_line !~ m/group=/) {
               my $idByHMMdef  = !$annot->get_idbyHMM() ? 0 : 1;
               $start_line    .= $idByHMMdef && $annot->get_idbyHMM() == 1 ? " ;; mfannot: score : $score" :" ;; mfannot: evalue : $score";
            }
            
            $annot->set_type($type);
            $annot->set_genename($a_genename);
            $annot->set_direction($direction);
            $annot->set_startline($start_line);
            $annot->set_endline($end_line);

            # Added comment and adjust pos for partial rna
            my $a_startline    = $annot->get_startline() || next;
            
            if ($annot->get_idbyHMM() && $annot->get_idbyHMM() == 1 || lc($a_genename) eq "rnpb" ) {
                $a_startline .= $a_startline =~ m/ ;; \.+/ ?
                           " / Approximative annotation" 
                         : " ;; mfannot: Approximative annotation";
                $annot->set_startline($a_startline);
            }

            if ( $endpos < 0 || $startpos < 0 ) {
                if ($startpos < 0) {
                    $a_startline .= $a_startline =~ m/ ;; \.+/ ?
                           " / Partial annotation, start found at pos : $startpos" 
                         : " ;; mfannot: Partial annotation, start found at pos : $startpos";
                    $annot->set_startline($a_startline);
                    $annot->set_startpos(1);
                }
                else {
                    $a_startline .= $a_startline =~ m/ ;; \.+/ ?
                           " / Partial annotation, stop found at pos : $endpos" 
                         : " ;; mfannot: Partial annotation, stop found at pos : $endpos";
                    $annot->set_startline($a_startline);
                    $annot->set_endpos(1);
                }
            }
            if ( $endpos > $seq_length || $startpos > $seq_length ) {
                if ($startpos > $seq_length) {
                    $a_startline .= $a_startline =~ m/ ;; \.+/ ?
                           " / Partial annotation, start found at pos : $startpos" 
                         : " ;; mfannot: Partial annotation, start found at pos : $startpos";
                    $annot->set_startline($a_startline);
                    $annot->set_startpos($seq_length);
               }
                else {
                    $a_startline .= $a_startline =~ m/ ;; \.+/ ?
                           " / Partial annotation, stop found at pos : $endpos" 
                         : " ;; mfannot: Partial annotation, stop found at pos : $endpos";
                    $annot->set_startline($a_startline);
                    $annot->set_endpos($seq_length);
                }
            }
            my $add_external_annot = 1;
            if ($genename eq "IntronII" || $genename eq "IntronI") {
                &AdjustIntronicAnnot_ForInitialAnnot($contigname,$annot);
                $add_external_annot = (scalar(@$annotpairs) > 1 || $LVL_INTRON == 2 )? 1 : 0;
            }
            &AddAnnotToPirMaster($contigname,$annot) if $add_external_annot == 1;
        } # End foreach annotpair
    } # End foreach annotpaircollection (one per contig)
} # End sub

sub AdjustIntronicAnnot_ForInitialAnnot {
    my ($contigname,$annot) = @_;
    
    my $contig            = $pirmaster->GetContigByName($contigname) or die "Can't get contig by name in AnnotateEmptyOrfs\n";
    my $a_start           = $annot->startpos() || die "Start position is not defined in AnnotPair :\n ".$annot->ObjectToXML()."\n";
    my $a_end             = $annot->endpos()   || die "End position is not defined in AnnotPair :\n ".$annot->ObjectToXML()."\n";
    my $annot_who_overlap = &WhatOverlapsThis($a_start,$a_end,$contig);
    
    foreach my $info_who_overlap (@$annot_who_overlap){
        FEATURE: foreach my $features_who_overlap (@$info_who_overlap ){
            my $features_min    = $features_who_overlap->[0];
            my $features_max    = $features_who_overlap->[1];
            my $feature         = $features_who_overlap->[2];
            
            next if $feature->type ne 'I';
            next if $features_min >  $a_start || $a_start > $features_max ||
                    $features_min >  $a_end   || $a_end   > $features_max;

            my $a_startline = $annot->startline();
            my $type        = $1    if $a_startline =~ m#group=(.+)#;
            die "Internal error : external AP does not contain type on startline?!?\n" unless $type;

            my $intron_type  = $feature->introntype() || "";
               $intron_type .= "," if $intron_type;
               $intron_type .= $type;    
            $feature->set_introntype($intron_type);
                
            my $feature_startline = $feature->startline();
            
            $feature_startline  =~ s/\s*\/\s*group\s*=\s*\S+//i;
            $feature_startline .= " /group=$intron_type";
            $feature->set_startline($feature_startline);
        } # End foreach $features_who_overlap
    } # End foreach $info_who_overlap
} # End sub

#-----------------------------------------#
# Subs for adjusting intronic boundaries  #
#-----------------------------------------#

sub Adjust_all_intronic_junctions {
    my $contigs     = $pirmaster->get_contigs();
   
   my %adjustement = (   # This used to be a more complex table... 
        -6 => [-6],-5 => [-5],-4 => [-4],
        -3 => [-3],-2 => [-2],-1 => [-1],
         0 => [0],1 => [1],2 => [2],
         3 => [3],4 => [4],5 => [5],
         6 => [6]
    );
    
    my @introns_info = ();
    foreach my $contig ( @$contigs) {
        my $annotations = $contig->get_annotations();
        my $contig_name = $contig->get_name();
        
        my $seq         = uc($contig->sequence());
           $seq         =~ s/!//g;
        my $reverse_seq = $seq;
           $reverse_seq =~ tr/ACGT/TGCA/;
           $reverse_seq = reverse $reverse_seq;
           
        foreach my $annot (@$annotations){
            my $a_type = $annot->type();
            next if $a_type ne "I";
            my $a_strand    = $annot->direction()  || next;
            my $isMinus     = ($a_strand eq "==>" ? 0 : 1 );
            my $use_seq     = ($isMinus ? "$reverse_seq" : "$seq");
            push (@introns_info,[$contig,$annot,$seq,$use_seq]);
        }
    }
    return if !@introns_info;
    
    # Add comment if 0 or 2 introns are id.
     if ($LVL_INTRON == 1 || $LVL_INTRON == 2) {
        foreach my $intron (@introns_info) {
            my ($contig,$annot,$seq,$use_seq,$adjust_info) = @$intron;
    
            my $a_introntype   = $annot->get_introntype()   || "";
            my $a_startline    = $annot->get_startline()    || next;
            my @intron_type    = split(/,/, $a_introntype);
            my $nb_type        = @intron_type;
    
            if ($nb_type == 0) {
                $a_startline .= $a_startline =~ m/ ;; \.+/ ?
                              " / no intron type identified" 
                            : " ;; mfannot: no intron type identified";
                $annot->set_startline($a_startline);
            }
            elsif ($nb_type == 2 ) {
                $a_startline .= $a_startline =~ m/ ;; \.+/ ?
                              " / two introns identified" 
                            : " ;; mfannot: two introns identified";
                $annot->set_startline($a_startline);
            }
        } # End foreach $intron
    }

    # Research intron type II
    my $count       = 1;
    if ($annotate_intron_typeII  == 0) {
        my %new_contig_for_intronII = ();
        my $add_to_mf_for_intronII  = "";
        foreach my $intron (@introns_info) {
            my ($contig,$annot,$seq,$use_seq) = @$intron;
            
            next if defined($annot->introntype());
            
            my $contig_name   = $contig-> get_name();
            my $a_start       = $annot->startpos()   || next;
            my $a_end         = $annot->endpos()     || next;
            my $a_strand      = $annot->direction()  || next;
            my $isMinus       = ($a_strand eq "==>" ? 0 : 1 );
            ($a_start,$a_end) = ($a_end,$a_start) if $isMinus;
            my $a_startline   = $annot->startline()  || next;
            my $name_of_gene  = $1 if ($a_startline =~ m#;\s*[gG]-(\S+)\s+(==>|<==)\s*start#);
            
            my $intron_seq    = substr($seq,$a_start - 1,abs($a_end-$a_start)+1);
            my $signature     = [$contig_name,$name_of_gene,$a_start,$a_end,$a_strand];
            $new_contig_for_intronII{$count} = $signature;
            $add_to_mf_for_intronII .= ">A$count\n$intron_seq\n\n";
            $count++;
        } # End foreach $intron
        &Research_for_intron($add_to_mf_for_intronII,\%new_contig_for_intronII,"IntronII") if $add_to_mf_for_intronII ne "";
    } # End if
    
    #Adjust intron type II
    foreach my $intron (@introns_info) {
        my ($contig,$annot,$seq,$use_seq) = @$intron;
        
        my $a_introntype = $annot->introntype() || "";
        next if ($a_introntype ne "II");
        &Adjust_TypeII($contig,$annot,$use_seq,\%adjustement);
        $intron->[1] = undef; # This intron is done
    } # End foreach intron
    
    @introns_info = grep( defined($_->[1]) , @introns_info);
    return if !@introns_info;
    
    # Add splicescore for other intron (maybe type I)
    foreach my $intron (@introns_info) {
        my ($contig,$annot,$seq,$use_seq) = @$intron;
        
        my $a_introntype = $annot->introntype() || "";
        my $adjust_info = &Add_splicescore($contig,$annot,$use_seq,\%adjustement);
        return if !$adjust_info;
        push(@$intron, $adjust_info);
    } # End foreach $intron
    
    # Adjust intron if splicescore is good
    foreach my $intron (@introns_info) {
        my ($contig,$annot,$seq,$use_seq,$adjust_info) = @$intron;
        my ($tab_scores,$name_intron,$num_intron,$annot_who_overlap,$annotation,$isMinus) = @$adjust_info;
        
        my $a_splicescore = $annot->splicescore();
        next if $a_splicescore < 19;
        &AdjustBoundaries($tab_scores,$name_intron,$num_intron,$annot_who_overlap,$annotation,$isMinus,$contig);
        $intron->[1] = undef; # This intron is done
    }
    
    @introns_info = grep( defined($_->[1]) , @introns_info);
    return if !@introns_info;
    
    # Research intron type I
    if ($annotate_intron_typeI  == 0) {
        my %new_contig_for_intronI = ();
        my $add_to_mf_for_intronI  = "";
        foreach my $intron (@introns_info) {
            my ($contig,$annot,$seq,$use_seq) = @$intron;
            
            next if defined($annot->introntype());
            
            my $contig_name   = $contig->get_name();
            my $a_start       = $annot->startpos()   || next;
            my $a_end         = $annot->endpos()     || next;
            my $a_strand      = $annot->direction()  || next;
            my $isMinus       = ($a_strand eq "==>" ? 0 : 1 );
            ($a_start,$a_end) = ($a_end,$a_start) if $isMinus;
            my $a_startline   = $annot->startline()  || next;
            my $name_of_gene  = $1 if ($a_startline =~ m#;\s*[gG]-(\S+)\s+(==>|<==)\s*start#);
            
            my $intron_seq   = substr($seq,$a_start - 1,abs($a_end-$a_start)+1);
            my $signature    = [$contig_name,$name_of_gene,$a_start,$a_end,$a_strand];
            $new_contig_for_intronI{$count} = $signature;
            $add_to_mf_for_intronI .= ">A$count\n$intron_seq\n\n";
            $count++;
        } # End foreach intron
        &Research_for_intron($add_to_mf_for_intronI,\%new_contig_for_intronI,"IntronI") if $add_to_mf_for_intronI ne "";
    } # End if 
    
    # Add comment if adjustement failed.
    foreach my $intron (@introns_info) {
        my ($contig,$annot,$seq,$use_seq,$adjust_info) = @$intron;
        my ($tab_scores,$name_intron,$num_intron,$annot_who_overlap,$annotation,$isMinus) = @$adjust_info;

        my $a_splicescore  = $annot->get_splicescore();
        my $a_introntype   = $annot->get_introntype()   || "";
        my $a_startline    = $annot->get_startline()    || next;
        my @intron_type    = split(/,/, $a_introntype);
        my $nb_type        = @intron_type;

        if ($nb_type == 0 && $LVL_INTRON == 0) {
            $a_startline .= $a_startline =~ m/ ;; \.+/ ?
                          " / no intron type identified" 
                        : " ;; mfannot: no intron type identified";
            $annot->set_startline($a_startline);
        }
        elsif ($nb_type == 2 && $LVL_INTRON == 0) {
            $a_startline .= $a_startline =~ m/ ;; \.+/ ?
                          " / two introns identified" 
                        : " ;; mfannot: two introns identified";
            $annot->set_startline($a_startline);
        }
        elsif ($nb_type ==  1) {
            &AdjustBoundaries($tab_scores,$name_intron,$num_intron,$annot_who_overlap,$annotation,$isMinus,$contig);
        }
    } # End foreach $intron
} # End sub

sub Research_for_intron {
    my $introns_fasta            = shift;
    my $r_hash_of_new_contigname = shift;
    my $intron_group             = shift;
    
    my $conf_file     = PirObject::MfAnnotExternalProgs->ImportFromTextFile($EXTCONFIGFILE);
    my $genecomsets   = $conf_file->get_geneprogs(); # This is a HASH genename => <MfAnnotGeneCommandSet>
    my $commandobject = $genecomsets->{$intron_group};
    
    my $masterfile_for_introns = $TMPDIR . "/masterfile_for_". $intron_group ;
    
    my $MF = new IO::File ">$masterfile_for_introns" or die "Cannot open : $masterfile_for_introns\n";
    print $MF $introns_fasta;
    $MF->close();
    my $annotpaircollections = &ExecuteExternalProgram($commandobject,$intron_group,undef,$masterfile_for_introns);
    $annotpaircollections    = &Adjust_coord_for_postannot($annotpaircollections,$r_hash_of_new_contigname);
    &AnnotateFromExternalAPC($intron_group,$annotpaircollections);
} # End sub

sub Adjust_TypeII {
    my $contig      = shift;
    my $annot       = shift;
    my $use_seq     = shift;
    my $adjustement = shift;
    
    my $contig_name = $contig-> get_name();
    my $a_start     = $annot->startpos()   || return;
    my $a_end       = $annot->endpos()     || return;
    my $a_startline = $annot->startline()  || return;
    my $a_endline   = $annot->endline()    || return;
    my $a_strand    = $annot->direction()  || return;
    my $isMinus     = ($a_strand eq "==>" ? 0 : 1 );
    my ($name_intron , $num_intron)  = ($1,$2) if  $a_startline =~ m#;\s+(G-.+)-I(\d+).+#;
    my $name_of_gene = $1 if ($a_startline =~ m#;\s*[gG]-(\S+)\s+(==>|<==)\s*start#);
    my ($start_pos,$end_pos) = ($isMinus ? ((length($use_seq) + 1 - $a_start),(length($use_seq) + 1 - $a_end)) : ($a_start,$a_end));
    
    my $phase = &WhichPhase($annot, $num_intron, $contig);    
    my $annot_who_overlap = &WhatOverlapsThis($a_start,$a_end,$contig);
    
    # View for previous and next exons
    my $previous_exon_name  = $name_intron."-E".$num_intron;
    my $next_exon_name      = $name_intron."-E".($num_intron+1);
    my ($previous_exon_feat,$next_exon_feat) = &Previous_and_next_exons($previous_exon_name,$next_exon_name,$annot_who_overlap);
    last if (!$previous_exon_feat || !$next_exon_feat);
    
    # Length of previous exon
    my $previous_exon_length = &Length_annot($previous_exon_feat);
    
    # Length of next exon
    my $next_exon_length = &Length_annot($next_exon_feat);

    my @tab_scores = ();
    foreach my $adjust_start_pos (sort { $a <=> $b } keys %$adjustement) {
        my $tab = $adjustement->{$adjust_start_pos};
        foreach my $adjust_end_pos (@$tab){
            my $key      = $adjust_start_pos.','.$adjust_end_pos;
            my $scores   = undef;
            
            next if (($previous_exon_length + $adjust_start_pos) <= 5);
            next if (($next_exon_length - $adjust_end_pos) <= 5);
            
            my $score_nt = &ScoreNtLTypeII($use_seq,$start_pos,$adjust_start_pos) 
                         + &ScoreNtRTypeII($use_seq,$end_pos,$adjust_start_pos);
            
            $score_nt -= abs($adjust_start_pos);
            # $scores is a ref to quintuplet ($score_nt,$score_aa,abs($adjust_start),$adjust_start,$adjust_end) or undef if adjustment is invalid
            $scores = &CheckForCorrespondance($phase, $start_pos, $end_pos, $use_seq, $key,$score_nt,$annot);
            push (@tab_scores, $scores ) if defined $scores; 
        }
    }
    
    @tab_scores = sort { ($b->[0] - $b->[2]) <=> ($a->[0] - $a->[2])
                                  || $b->[1] <=> $a->[1]
                                  || $a->[2] <=> $b->[2]
                                  || $a->[3] <=> $b->[3]} @tab_scores;

    if (!$tab_scores[0]->[0] || $tab_scores[0]->[0] < 40) {
        &AddCommentToAnnotField($annot,"startline",";;  Splice boundaries incertain");
        return;
    }
    &AdjustBoundaries(\@tab_scores,$name_intron,$num_intron,$annot_who_overlap,$annot,$isMinus,$contig);
} # End sub

sub Adjust_coord_for_postannot {
    my $annotpaircollections     = shift;
    my $r_hash_of_new_contigname = shift;
    
    foreach my $annotpaircollection (@$annotpaircollections) {
        my $contig = $annotpaircollection->get_contigname();
        $contig =~ s/^>*A//;
        # $signature is a quintuplet contig_name, name_of_gene, lower_pos, higher_pos, direction
        my $signature  = $r_hash_of_new_contigname->{$contig};
        my $sig_contig = $signature->[0];
        my $lower_pos  = $signature->[2];
        my $higher_pos = $signature->[3];
        my $strand     = $signature->[4];
        $annotpaircollection->set_contigname(">$sig_contig");
        my $annotpairs = $annotpaircollection->get_annotpairlist();
    
        my $new_ap = [];
        foreach my $annot (@$annotpairs){
            my $annot_strand   = $annot->direction();
            next if $annot_strand ne $strand ;
            my $annot_startpos = $annot->startpos();
            my $annot_endpos   = $annot->endpos();
        
            my $isMinus     = ($annot_strand eq "==>" ? 0 : 1 );
            $annot_startpos = $lower_pos + $annot_startpos  - 1;
            $annot_endpos   = $lower_pos + $annot_endpos - 1;
        
            $annot->set_startpos($annot_startpos);
            $annot->set_endpos($annot_endpos);
            push(@$new_ap,$annot);
        }
    $annotpaircollection->set_annotpairlist($new_ap);
    }
    return $annotpaircollections;
}

sub Add_splicescore {
    my $contig      = shift;
    my $annot       = shift;
    my $use_seq     = shift;
    my $adjustement = shift;
    
    my $contig_name = $contig->get_name();
    my $a_start     = $annot->startpos()   || next;
    my $a_end       = $annot->endpos()     || next;
    my $a_startline = $annot->startline()  || next;
    my $a_endline   = $annot->endline()    || next;
    my $a_strand    = $annot->direction()  || next;
    my $isMinus     = ($a_strand eq "==>" ? 0 : 1 );
    my ($name_intron , $num_intron)  = ($1,$2) if  $a_startline =~ m#;\s+(G-.+)-I(\d+).+#;
    my $name_of_gene = $1 if ($a_startline =~ m#;\s*[gG]-(\S+)\s+(==>|<==)\s*start#);
    my ($start_pos,$end_pos) = ($isMinus ? ((length($use_seq) + 1 - $a_start),(length($use_seq) + 1 - $a_end)) : ($a_start,$a_end));
    
    my $phase = &WhichPhase($annot, $num_intron, $contig);    
    my $annot_who_overlap = &WhatOverlapsThis($a_start,$a_end,$contig);
    
    # View for previous and next exons
    my $previous_exon_name  = $name_intron."-E".$num_intron;
    my $next_exon_name      = $name_intron."-E".($num_intron+1);
    my ($previous_exon_feat,$next_exon_feat) = &Previous_and_next_exons($previous_exon_name,$next_exon_name,$annot_who_overlap);
    return if (!$previous_exon_feat || !$next_exon_feat);
    
    # Length of previous exon
    my $previous_exon_length = &Length_annot($previous_exon_feat);
    # Length of next exon
    my $next_exon_length     = &Length_annot($next_exon_feat);
    
    my @tab_scores = ();
    foreach my $adjust_start_pos (sort { $a <=> $b } keys %$adjustement) {
        my $tab = $adjustement->{$adjust_start_pos};
        foreach my $adjust_end_pos (@$tab){
            my $key      = $adjust_start_pos.','.$adjust_end_pos;
            my $scores   = undef;
            
            next if (($previous_exon_length + $adjust_start_pos) <= 5 && $key ne "0,0");
            next if (($next_exon_length - $adjust_end_pos) <= 5 && $key ne "0,0");
            
             my $score_nt = &ScoreNtLTypeI($use_seq,$start_pos,$adjust_start_pos) 
                          + &ScoreNtRTypeI($use_seq,$end_pos,$adjust_start_pos);

            #$score_nt -= abs($adjust_start_pos);
            # $scores is a ref to quintuplet ($score_nt,$score_aa,abs($adjust_start),$adjust_start,$adjust_end) or undef if adjustment is invalid
            $scores = &CheckForCorrespondance($phase, $start_pos, $end_pos, $use_seq, $key,$score_nt,$annot);
            push (@tab_scores, $scores ) if defined $scores; 
        }
    }
    
    @tab_scores = sort { ($b->[0] - $b->[2]) <=> ($a->[0] - $a->[2]) 
                                  || $b->[1] <=> $a->[1]
                                  || $a->[2] <=> $b->[2]
                                  || $a->[3] <=> $b->[3]} @tab_scores;

    my $splice_score = $tab_scores[0]->[0];
    if ($splice_score >= 19 && $LVL_INTRON == 0){
        $annot->set_introntype("sigI");
    }
    $annot->set_splicescore($tab_scores[0]->[0]);
    return [\@tab_scores,$name_intron,$num_intron,$annot_who_overlap,$annot,$isMinus];
} # End sub

sub ScoreNtLTypeII {
    my $use_seq          = shift;
    my $start_pos        = shift;
    my $adjust_start_pos = shift;
    
    my $start_char_plus1 = substr($use_seq,$start_pos + $adjust_start_pos - 1,1);  # Each nt between -6 and 6 of feature_min
    my $start_char_plus2 = substr($use_seq,$start_pos + $adjust_start_pos ,1);
    my $start_char_plus3 = substr($use_seq,$start_pos + $adjust_start_pos + 1,1);
    my $start_char_plus4 = substr($use_seq,$start_pos + $adjust_start_pos + 2,1);
    my $start_char_plus5 = substr($use_seq,$start_pos + $adjust_start_pos + 3,1);
   
   my $score_nt  = 0;
      $score_nt += 10  if  $start_char_plus1   eq 'G';
      $score_nt += 7.5 if  $start_char_plus2   eq 'T';
      $score_nt += 9   if  $start_char_plus3   eq 'G';
      $score_nt += 10  if  ($start_char_plus4  eq 'C' || $start_char_plus4  eq 'T');
      $score_nt += 10  if  $start_char_plus5   eq 'G';

    return $score_nt;
}

sub ScoreNtRTypeII {
    my $use_seq        = shift;
    my $end_pos        = shift;
    my $adjust_end_pos = shift;
        
    my $end_char_minus1  = substr($use_seq,$end_pos + $adjust_end_pos -1,1);
    my $end_char_minus2  = substr($use_seq,$end_pos + $adjust_end_pos -2,1);
    
    my $score_nt  = 0;
       $score_nt += 9   if ($end_char_minus1    eq 'C' || $end_char_minus1  eq 'T');
       $score_nt += 9   if  $end_char_minus2    eq 'A';
   return $score_nt;
}

sub ScoreNtLTypeI {
    my $use_seq          = shift;
    my $start_pos        = shift;
    my $adjust_start_pos = shift;
    
    my $start_char_minus1 = substr($use_seq,$start_pos + $adjust_start_pos -2,1);  # Each nt between -6 and 6 of feature_min
    my $start_char_minus2 = substr($use_seq,$start_pos + $adjust_start_pos -3,1);
    my $start_char_minus3 = substr($use_seq,$start_pos + $adjust_start_pos -4,1);
    
    my $score_nt  = 0;
       $score_nt += 5   if $start_char_minus1 eq 'T';
       $score_nt += 3   if $start_char_minus2 eq 'G';
       $score_nt += 3   if $start_char_minus3 eq 'G';
       
   return $score_nt;
}

sub ScoreNtRTypeI {
    my $use_seq        = shift;
    my $end_pos        = shift;
    my $adjust_end_pos = shift;
    
    my $end_char_minus1   = substr($use_seq,$end_pos + $adjust_end_pos -1,1);
    my $end_char_minus2   = substr($use_seq,$end_pos + $adjust_end_pos -2,1);
    my $end_char_minus3   = substr($use_seq,$end_pos + $adjust_end_pos -3,1);
    my $end_char_minus4   = substr($use_seq,$end_pos + $adjust_end_pos -4,1);
    my $end_char_minus5   = substr($use_seq,$end_pos + $adjust_end_pos -5,1);
    my $end_char_minus6   = substr($use_seq,$end_pos + $adjust_end_pos -6,1);
    my $end_char_minus7   = substr($use_seq,$end_pos + $adjust_end_pos -7,1);
    my $end_char_minus8   = substr($use_seq,$end_pos + $adjust_end_pos -8,1);
    my $end_char_minus9   = substr($use_seq,$end_pos + $adjust_end_pos -9,1);
    
     my $score_nt  = 0;
        $score_nt += 10  if $end_char_minus1   eq 'G';
        $score_nt += 0.5 if ($end_char_minus2  eq 'T' || $end_char_minus2  eq 'A');
        $score_nt += 0.5 if ($end_char_minus3  eq 'T' || $end_char_minus3  eq 'A');
        $score_nt += 0.5 if ($end_char_minus4  eq 'T' || $end_char_minus4  eq 'A');
        $score_nt += 0.5 if ($end_char_minus5  eq 'T' || $end_char_minus5  eq 'A');
        $score_nt += 0.5 if ($end_char_minus6  eq 'T' || $end_char_minus6  eq 'A');
        $score_nt += 0.5 if ($end_char_minus7  eq 'T' || $end_char_minus7  eq 'A');
        $score_nt += 0.5 if ($end_char_minus8  eq 'T' || $end_char_minus8  eq 'A');
        $score_nt += 0.5 if ($end_char_minus9  eq 'T' || $end_char_minus9  eq 'A');

    return $score_nt;
}

sub AdjustBoundaries {
    my $tab_scores        = shift;
    my $name_intron       = shift;
    my $num_intron        = shift;
    my $annot_who_overlap = shift;
    my $feature_intron    = shift;
    my $isMinus           = shift;
    my $contig            = shift;
    
    my ($adjust_start,$adjust_end) = ($tab_scores->[0]->[3],$tab_scores->[0]->[4]);
    my $previous_exon_name         = $name_intron."-E".$num_intron;
    my $next_exon_name             = $name_intron."-E".($num_intron+1);
    
    # Use to defined previous and next exon
    my ($previous_exon_feat,$next_exon_feat) = &Previous_and_next_exons($previous_exon_name,$next_exon_name,$annot_who_overlap);
    ($adjust_start,$adjust_end) = (-$adjust_start,-$adjust_end) if $isMinus;
    
    # Adjust intron
    my $feature_intron_start = $feature_intron->get_startpos();
    $feature_intron->set_startpos($feature_intron_start + $adjust_start);
    
    my $feature_intron_end   = $feature_intron->get_endpos();
    $feature_intron->set_endpos($feature_intron_end + $adjust_end);
    
    # Adjust previous exon
    if (defined $previous_exon_feat) {
        my $previous_exon_end   = $previous_exon_feat->get_endpos();
        $previous_exon_feat->set_endpos($previous_exon_end + $adjust_start);
    }
    
    # Adjust next exon
    if (defined $next_exon_feat) {
        my $next_exon_start   = $next_exon_feat->get_startpos();
        $next_exon_feat->set_startpos($next_exon_start + $adjust_end);
    }
} # End sub

sub Previous_and_next_exons {
    my $previous_exon_name = shift;
    my $next_exon_name     = shift;
    my $annot_who_overlap  = shift;
    
    my $previous_exon_feat = undef;
    my $next_exon_feat     = undef;
    
    foreach my $annotation_who_overlap (@$annot_who_overlap){
        foreach my $feature_overlap (@$annotation_who_overlap) {
            my $feature            = $feature_overlap->[2];
            next if $feature->get_genename() eq "comment";
            my $feature_startline  = $feature->get_startline();
            my ($annotname)        = ($feature_startline =~ m#^;\s+(\S+)#);
            $previous_exon_feat    = $feature if ($annotname eq $previous_exon_name);
            $next_exon_feat        = $feature if ($annotname eq $next_exon_name);
            last if $previous_exon_feat && $next_exon_feat;
        } # End foreach $feature_who_overlap
    } # End foreach $annotation_who_overlap
    return($previous_exon_feat,$next_exon_feat);
} # End sub

sub CheckForCorrespondance {
    my $phase     = shift;
    my $start_pos = shift;   # Bio coordinates
    my $end_pos   = shift;   # Bio coordinates
    my $seq       = shift;
    my $key       = shift; 
    my $score_nt  = shift;
    my $annot     = shift;
    
    my $startline = $annot->startline();
    
    my ($adjust_start,$adjust_end)       = split(/,/,$key);
    my ($old_substring1,$old_substring2) = ("","");
    my ($new_substring1,$new_substring2) = ("","");
    
    my $comp_phase     = $phase == 0 ? 0 : 3-$phase;
    my $new_phase      = ($phase + $adjust_start) % 3;
    my $comp_new_phase = $new_phase == 0 ? 0 : 3-$new_phase;
    
    if ($adjust_start <= 0) {
        my $from_old = $start_pos + $adjust_start - 1 - $new_phase;
        my $len_old  = abs($adjust_start)+$new_phase;
        my $from_new = $start_pos + $adjust_start - $new_phase - 1;
        $old_substring1 = substr($seq,$from_old,$len_old);
        $new_substring1 = substr($seq,$from_new,$new_phase);
    }
    elsif ($adjust_start > 0) {
        my $from_old = $start_pos - $phase - 1;
        my $len_old  = $phase;
        my $from_new = $start_pos - $phase - 1;
        my $len_new  = $adjust_start + $phase;
        $old_substring1 = substr($seq,$from_old,$len_old);
        $new_substring1 = substr($seq,$from_new, $len_new);
    }
    
    if ($adjust_end >= 0) {
        my $from_old = $end_pos;
        my $len_old  = $comp_new_phase + $adjust_end;
        my $from_new = $end_pos + $adjust_end;
        my $len_new  = $comp_new_phase;
        $old_substring2   = substr($seq,$from_old, $len_old);
        $new_substring2   = substr($seq,$from_new, $len_new);
    }
    elsif ($adjust_end < 0) {
        my $from_old = $end_pos ;
        my $len_old  = $comp_phase;
        my $from_new = $end_pos + $adjust_end;
        my $len_new  = - $adjust_end + $comp_phase;
        $old_substring2   = substr($seq,$from_old, $len_old);
        $new_substring2 = substr($seq,$from_new,$len_new);
    }
  
    my $old_substring = "$old_substring1$old_substring2";
    my $new_substring = "$new_substring1$new_substring2";

    if (length($old_substring) != length($new_substring)){
        print "   WARNING : Combination $adjust_start,$adjust_end not used for adjust boundaries because they add or delete amino acid \n";
        return undef;
    }
    
    if (length($new_substring)%3 != 0){
        print "   WARNING : Combination $adjust_start,$adjust_end not used for adjust boundaries because they shift the initial readingframe\n
                  Initial phase is $phase the new phase is $new_phase \n
                  Sequence used at start of intron is $new_substring1 \n
                  Sequence used at end of intron is $new_substring2 \n
                  Whole sequence used for check for stop codon is $new_substring\n";
        return undef;
    }
    
    my @new_aa = ();
    my @old_aa = ();
    for (my $sub_start_pos = 0;  $sub_start_pos <= length($new_substring)-3; $sub_start_pos += 3){
        my $new_codon = substr($new_substring,$sub_start_pos,3);
        push (@new_aa, $CODON_TABLE->{$new_codon} );  # undef is OK here
        my $old_codon = substr($old_substring,$sub_start_pos,3);
        push (@old_aa, $CODON_TABLE->{$old_codon} );  # undef is OK here
    }
    
    my $score_aa = 0;
    for (my $i = 0;  $i < @new_aa; $i++){
        my $old_aa    = $old_aa[$i] || "X";
        my $new_aa    = $new_aa[$i] || "X";
        $score_aa += $matrix->get_entry($old_aa,$new_aa);   
        return undef if $score_aa < 0;
    }
     
    $score_aa = $score_aa / (@new_aa || 1);
    $score_aa = 9999 if $adjust_start == 0 && $adjust_end == 0;  # 9999 is SUPER GOOD
    return [$score_nt,$score_aa,abs($adjust_start),$adjust_start,$adjust_end];
} # End sub



#---------------------------------#
# Subs for comment gene fusion    #
#---------------------------------#

sub CommentFusion {
    my $contigs   = $pirmaster->get_contigs();

    foreach my $contig ( @$contigs) {
        my $annotations = $contig->get_annotations();
        my $contig_name = $contig->get_name();
        
        foreach my $annot (@$annotations) {
            my $posiffusion = $annot->get_posiffusion();
            next if !$posiffusion;
            my $arrow       = $annot->get_direction();
            my $gene_name   = $annot->get_genename();
            my $start       = $annot->get_startpos();
            my $end         = $annot->get_endpos();
            my $fusion_name = $annot->get_namefusiongene();            
            &AddCommentForFusion($contig_name,$start,$arrow,$gene_name,$fusion_name,"start",1) if $posiffusion == 1;
            &AddCommentForFusion($contig_name,$end,$arrow,$gene_name,$fusion_name,"end",1) if $posiffusion == 2;
            my $comment = &ModifCommentForFirstStart($annot,$annotations);
            next if !$comment;
            my $contig  = $pirmaster->GetContigByName($contig_name);
            my $id_comment  = $1 if scalar($comment) =~ m/0x(.+)\)/;
            my $tab_id = [$id_comment];
            &Remove_AP($tab_id,$contig);
        }
    }
}

sub AddCommentForFusion {
    # Add comment if it's first gene this comment surround the two genes
    my $contigname  = shift;
    my $pos         = shift;
    my $arrow       = shift;
    my $gene_name   = shift;
    my $fusion_name = shift;
    my $tag         = shift;
    my $line_number = shift;
    
    $pos = $pos + 1 if $arrow eq "==>" and $tag eq "end";
    $pos = $pos - 1 if $arrow eq "<==" and $tag eq "end";
    
    my $name = ($tag eq "start" ? "${gene_name}_$fusion_name" : "${fusion_name}_$gene_name");
    my $line = ";; G-$name $arrow $tag";
   
    my $comment = new PirObject::AnnotPair(
                                        type            => "C",  
                                        genename        => $name,
                                        startpos        => $pos,
                                        direction       => $arrow,
                                        startline       => $line,
                                        startlinenumber => $line_number
                                       );
    &AddAnnotToPirMaster($contigname,$comment);
}

#---------------------------------#
# Subs for processing empty ORFs  #
#---------------------------------#

sub AnnotateEmptyOrfs {
   # This function takes the empty array of ORF and annotate it as ORFs
   # It means ORF having non corresponding gene in a pepfile
   my $orf_a_annoter = scalar(@$EMPTYORFS);  
     
    foreach my $emptyorf (@$EMPTYORFS) {
         # Process each non corresponding orf
         # Get informations  about empty ORF
         my $contigname = $emptyorf->get_contigname();     # Get the contigname corresponding to the empty ORFs
         my $strand_orf = $emptyorf->get_strand();

         my $arrow = $strand_orf == 1 ? '==>' : '<==';
         my ($start_orf,$end_orf) = ($emptyorf->get_start(),$emptyorf->get_end());
         
         my $minimumlengthorf  = $MINLENEMPTYORF;    # Minimum Orf size, below this size, the ORF is no more kept
         my $contig            = $pirmaster->GetContigByName($contigname) or die "Can't get contig by name in AnnotateEmptyOrfs\n";
         my $annotations       = $contig->get_annotations(); # Get the annotations, for the same contig belonging to empty ORF
         my $seq               = $contig->get_sequence();    # Get the sequence
            $seq               =~ s/!//g;                    # Remove ! from the sequence
            
        my $length_orf = $strand_orf == 1 ? $end_orf - $start_orf + 1 : $start_orf - $end_orf + 1;
        next if  ($length_orf < $minimumlengthorf);  #  Size Verification
     
        my $possible_start = ();
        my $start_info     = ();
        # Other checking, such as overlapping..........
        my $isMinus   = $strand_orf == 1 ?  0 : 1;
        my $posOffset = $isMinus         ? -3 : 3;
        for (;;$start_orf += $posOffset) {
            my $start_info     = ();
            $length_orf = $strand_orf == 1 ? $end_orf - $start_orf + 1 : $start_orf - $end_orf + 1;
            last if  ($length_orf < $minimumlengthorf);  #  Size Verification 
            
            my $codon = uc (substr($seq, $start_orf - 1, 3)) if !$isMinus;
               $codon = uc (substr($seq, $start_orf - 3, 3)) if  $isMinus;
               $codon =~ tr/ACGT/TGCA/ if $isMinus;
               $codon = reverse $codon if $isMinus;
            $start_info = ["ATG",$start_orf] 
                if defined($CODON_TABLE->{$codon}) && $CODON_TABLE->{$codon} eq "M" && $codon =~ m/ATG/i;
            $start_info = ["GTG",$start_orf] 
                if defined($CODON_TABLE->{$codon}) && $CODON_TABLE->{$codon} eq "V" && $codon =~ m/GTG/i && $START_COUNT->{"GTG"};
            $start_info = ["TTG",$start_orf] 
                if defined($CODON_TABLE->{$codon}) && $codon =~ m/TTG/i && $START_COUNT->{"TTG"};
            push(@$possible_start,$start_info) if $start_info;
        }
        $emptyorf->set_possible_start($possible_start);
    }
    
    my $hash_OV    = {};
    foreach my $emptyorf (@$EMPTYORFS) {
        # Process each non corresponding orf
        # Get informations  about empty ORF
        my $possible_starts   = $emptyorf->get_possible_start();
        next if !$possible_starts || scalar(@$possible_starts) == 0;
        my $strand_orf = $emptyorf->get_strand();
        my $arrow = $strand_orf == 1 ? '==>' : '<==';
   
        my ($start_orf,$end_orf) = ($emptyorf->get_start(),$emptyorf->get_end());

        my $contigname        = $emptyorf->get_contigname();     # Get the contigname corresponding to the empty ORFs
        my $contig            = $pirmaster->GetContigByName($contigname) or die "Can't get contig by name in AnnotateEmptyOrfs\n";
        my $annotations       = $contig->get_annotations(); # Get the annotations, for the same contig belonging to empty ORF

        my $tab_OV = !$hash_OV->{$contigname} ? () : $hash_OV->{$contigname};
        
        # Other checking, such as overlapping..........
        my $isMinus   = ($strand_orf == 1 ? 0 : 1);

        my $annotIsOK_gene_without_intron =  scalar(@$possible_starts) != 0 ? 1 : 0;
        next if $annotIsOK_gene_without_intron == 0;

        my ($ToAnnot,$isOV) = (0,0);
        foreach my $possible_start (@$possible_starts) {
            my $tri_nt    = $possible_start->[0];
            next if $tri_nt eq "GTG";
            next if $tri_nt eq "TTG";
            
            
            $start_orf    = $possible_start->[1];
            my $min_orf   = $strand_orf == 1 ? $start_orf : $end_orf;
            my $max_orf   = $strand_orf == 1 ? $end_orf   : $start_orf;
            
            # Special case
            my $isLongOrf = ((($max_orf-$min_orf+1)/3)-1 >= $OVERLAPORFOVGENE) ? 1 : 0;
            $ToAnnot = 1 if $isLongOrf;
            
            my $annot_who_overlap = &WhatOverlapsThis($start_orf,$end_orf,$contig);
            if (scalar(@$annot_who_overlap) == 0) {
                $ToAnnot = 1;
                last;
            }
            else {
                ($tab_OV,$isOV,$ToAnnot) = &CheckIfOrfIsToAnnot($annot_who_overlap,$min_orf,$max_orf,$isLongOrf,$emptyorf,$tab_OV,$isOV);
                last if $ToAnnot;
            }
        }
        
        if ( $ToAnnot == 1) {
            my $orfannot = &CreateOrfAnnot($end_orf,$start_orf,$isMinus,$possible_starts);
            &AddAnnotToPirMaster($contigname,$orfannot);
            push(@$tab_OV,$orfannot) if $isOV;
        } # End of if
        $hash_OV->{$contigname} = $tab_OV;
    } # End of for each empty orfs
    &RemovedOVOrfs($hash_OV);
    &AnnotGTGUpstream();
}

sub CheckIfOrfIsToAnnot {
    my ($annot_who_overlap,$min_orf,$max_orf,$isLongORF,$emptyorf,$tab_OV,$isOV) = @_;

    my $ToAnnot = 0;
    my $overlappingcutoff = "";
    foreach my $info_who_overlap (@$annot_who_overlap){
        FEAT: foreach my $features_who_overlap (@$info_who_overlap ){
            my $features_min            = $features_who_overlap->[0];
            my $features_max            = $features_who_overlap->[1];
            my $feature_annot_type      = $features_who_overlap->[2]->type;
            my $feature_annot_direction = $features_who_overlap->[2]->direction;
            my $feature_startpos        = $features_who_overlap->[2]->startpos;
            my $feature_endpos          = $features_who_overlap->[2]->endpos;
            my $feature_endline         = $features_who_overlap->[2]->endline;
            
            #       ------------         ORF
            # * ------------------- **   Gene
            return ($tab_OV,$isOV,$ToAnnot) if ( ($features_min <= $min_orf && $features_max >= $max_orf) && $feature_annot_type eq "G" );
            
            # No overlap with tRNA
            if ($isLongORF == 0) {
                # Not to annot if OV tRNA
                if ($features_who_overlap->[2]->genename =~ /^trn/){
                    my $max_start = $features_min > $min_orf ? $features_min : $min_orf;
                    my $min_end   = $features_max < $max_orf ? $features_max : $max_orf ;
                    return ($tab_OV,$isOV,$ToAnnot) if (0 < ( $min_end - $max_start + 1));
                }
                
                $overlappingcutoff = &DefineOVByPourcent($min_orf,$max_orf,$info_who_overlap,$emptyorf)
                    if $feature_annot_type ne "O" && $overlappingcutoff eq "";
                
                # Overlap with gene start or end accepted if < overlappingcutoff
                if ( ($feature_annot_type eq "G" && $features_who_overlap->[3] eq "YES")    # Gene without intron
                || ($feature_annot_type eq "E" && $features_who_overlap->[3] eq "YES")) {   # First or last exon
                
                    if ( ( $feature_annot_type eq "G" )                                    # Gene whithout intron
                    || ( ($features_who_overlap->[4] eq "FIRST" || $features_who_overlap->[4] eq "LAST")
                    && ( ! ($max_orf < $features_min || $min_orf > $features_max)))) {
                        my $max_start = ( ( $features_min > $min_orf ) ? $features_min : $min_orf);
                        my $min_end   = ( ( $features_max < $max_orf ) ? $features_max : $max_orf );
                        return ($tab_OV,$isOV,$ToAnnot) if ($overlappingcutoff < ( $min_end - $max_start + 1)); # XXX tmp on accepte aucun OV 
                    }
                }
            }
            if ($feature_annot_type eq "O") {
                push(@$tab_OV,$features_who_overlap->[2]);
                $isOV = 1;
            }
        }
    }
    $ToAnnot = 1;
    return($tab_OV,$isOV,$ToAnnot);
}

sub DefineOVByPourcent {
    my ($min_orf,$max_orf,$info_who_overlap,$emptyorf) = @_;
    
    my $OV_autorized  = "";
    foreach my $features_who_overlap (@$info_who_overlap ){
        my $type   = $features_who_overlap->[2]->type;
        my $isFull = $features_who_overlap->[3] eq "YES" ? 1 : 0;
        next if $type eq "O" || $type ne "G";
        $OV_autorized = $isFull ? 
                     &DefineCutForGeneWithoutIntron($min_orf,$max_orf,$info_who_overlap,$emptyorf)
                   : &DefineCutForGeneWithIntron($min_orf,$max_orf,$info_who_overlap,$emptyorf);
        $OV_autorized = 1 if $OV_autorized eq  "";
    }

    return $OV_autorized;
}

sub DefineCutForGeneWithoutIntron {
    my ($min_orf,$max_orf,$info_who_overlap,$emptyorf) = @_;
    
    foreach my $features_who_overlap (@$info_who_overlap ){
        my $min_gen = $features_who_overlap->[0];
        my $max_gen = $features_who_overlap->[1];
        my $len_ORF = $max_orf - $min_orf + 1;
        my $len_GEN = $max_gen - $min_gen + 1;
        my $OV_autorized = $len_ORF < $len_GEN ? ($OVERLAPPINGCUTOFF*$len_ORF)/100 : ($OVERLAPPINGCUTOFF*$len_GEN)/100;
        return $OV_autorized;
    }
}

sub DefineCutForGeneWithIntron {
    my ($min_orf,$max_orf,$info_who_overlap,$emptyorf) = @_;
    
    foreach my $features_who_overlap (@$info_who_overlap ){
        next if  $features_who_overlap->[2]->type ne "E";
        my $isFirst = $features_who_overlap->[4] eq "FIRST" ? 1 : 0;
        my $isLast  = $features_who_overlap->[4] eq "LAST"  ? 1 : 0;
        next if !$isLast && !$isFirst;
        my $GEN_isMinus = $features_who_overlap->[2]->direction eq "<==" ? 1 : 0;
        my $min_gen = $features_who_overlap->[0];
        my $max_gen = $features_who_overlap->[1];
        next if ($max_orf < $min_gen || $min_orf > $max_gen);
        my $len_ORF = $max_orf - $min_orf + 1;
        my $len_GEN = $max_gen - $min_gen + 1;
        my $OV_autorized = $len_ORF < $len_GEN ? ($OVERLAPPINGCUTOFF*$len_ORF)/100 : ($OVERLAPPINGCUTOFF*$len_GEN)/100;
        return $OV_autorized;
    }
}

sub CreateOrfAnnot {
    my ($end_orf,$start_orf,$isMinus,$possible_starts) = @_;

    my $arrow   = !$isMinus ? "==>" : "<==";
    my $orfsize = !$isMinus ? (($end_orf - $start_orf + 1)/3) - 1 : (($start_orf - $end_orf + 1)/3) -1;
    my $GenenameORF = "orf". $orfsize;
    
    # Annotate the longer ORF and keep the other in comment.
    my ($startline,$endline,$orfannot) = ("","","");
    $startline    = ";     G-$GenenameORF $arrow start";
    $endline      = ";     G-$GenenameORF $arrow end";
    
    $orfannot = new PirObject::AnnotPair(
                                     type      => "O",  
                                     genename  => $GenenameORF,
                                     startpos  => $start_orf,
                                     endpos    => $end_orf,
                                     direction => $arrow,
                                     startline => $startline,
                                     endline   => $endline,
                                     possStart => $possible_starts
                                   );
    return ($orfannot);
}

sub RemovedOVOrfs() {
    my ($hash_ORFs) = @_;
    
    foreach my $contigname ( keys %$hash_ORFs ) {
        my $OV_ORFs = $hash_ORFs->{$contigname};
         
        # Removed duplicate to $OV_ORFs
        my ($already_in,$clean_ORFs) = ({},());
        foreach my $ORF (@$OV_ORFs){
            my $id = $1 if scalar($ORF) =~ m/0x(.+)\)/;
            next if $already_in->{$id};
            $already_in->{$id}++;
            push(@$clean_ORFs,$ORF);
        }
        
        # Set ATG start foreach ORF in $OV_orfs
        my $ATG_ORFs = &SetATGstartForOrfs($clean_ORFs);
                            
        # Make a list of AP to rm.
        my $AP_toRM = &MakeListOfORFsToRM($ATG_ORFs);
        
        my $tab_AP_toRM = ();
        foreach my $id (keys %$AP_toRM) {
            push(@$tab_AP_toRM,$id);
        }
        
        my $contig = $pirmaster->GetContigByName($contigname) or die "Can't get contig by name in AnnotateEmptyOrfs\n";
        &Remove_AP($tab_AP_toRM,$contig)   
    }
}

sub SetATGstartForOrfs {
    my ($clean_ORFs) = @_;
    
    my $ATG_ORFs = ();
    foreach my $ORF (@$clean_ORFs) {
        my $possStarts = $ORF->get_possStart();
        my $first_ATG  = "";
        foreach my $posStart (@$possStarts) {
            next if $posStart->[0] ne "ATG";
            $first_ATG = $posStart->[1];
            last if $first_ATG ne "";
        }
        next if !$first_ATG;
        $ORF->set_startpos($first_ATG) if $ORF->get_startpos() != $first_ATG;
        push(@$ATG_ORFs,$ORF);
    }
    
    return $ATG_ORFs if !$ATG_ORFs;
    @$ATG_ORFs = sort { abs($b->get_startpos() - $b->get_endpos()) <=> abs($a->get_startpos() - $a->get_endpos()) ||
                        $b->get_direction()                        cmp $a->get_direction()                        ||
                        $a->get_startpos()                         <=> $b->get_startpos()} @$ATG_ORFs;

    return $ATG_ORFs;
}

sub MakeListOfORFsToRM {
    my ($ATG_ORFs) = @_;
    
    my $AP_toRM = {};
    foreach my $ORF_1 (@$ATG_ORFs) {
        my $id_1 = $1 if scalar($ORF_1) =~ m/0x(.+)\)/;
        next if $AP_toRM->{$id_1};
        my $start_1   = $ORF_1->get_startpos();
        my $end_1     = $ORF_1->get_endpos();
        my $isMinus_1 = $ORF_1->get_direction() eq "==>" ? 0 : 1;
        my ($min_1,$max_1) = !$isMinus_1 ? ($start_1,$end_1) : ($end_1,$start_1);
        my $orfsize_1   = (($max_1 - $min_1 + 1)/3) - 1;
        foreach my $ORF_2 (@$ATG_ORFs){ # Attention a ne pas retraiter 2 * les meme cas
            my $id_2 = $1 if scalar($ORF_2) =~ m/0x(.+)\)/;
            next if $AP_toRM->{$id_2};
            next if $ORF_1 eq $ORF_2;
            my $start_2   = $ORF_2->get_startpos();
            my $end_2     = $ORF_2->get_endpos();
            my $isMinus_2 = $ORF_2->get_direction() eq "==>" ? 0 : 1;
            my ($min_2,$max_2) = !$isMinus_2 ? ($start_2,$end_2) : ($end_2,$start_2);
            my $orfsize_2   = (($max_2 - $min_2 + 1)/3) - 1;
            next if $orfsize_2 >= $OVERLORFOVORF;
            my $OV_autorized = ($OVERLAPPINGCUTOFF*$orfsize_2)/100;
            $OV_autorized    =  &Arrondi(abs($OV_autorized),1);
            my $max_start = ( ( $min_1 > $min_2) ? $min_1 : $min_2);
            my $min_end   = ( ( $max_1 < $max_2) ? $max_1 : $max_2);
            my $OV_len = ( $min_end - $max_start + 1);
            next if $OV_len < 0;
            next if ($OV_autorized > ( $min_end - $max_start + 1));
            $AP_toRM->{$id_2}++;
        }
    }
    return $AP_toRM;
}

sub AnnotGTGUpstream {
    my $contigs   = $pirmaster->get_contigs();
    
    foreach my $contig (@$contigs) {
        my $annotations = $contig->get_annotations();
        my $cg_len      = $contig->get_sequencelength();
        foreach my $annot (@$annotations) {
        next if $annot->get_type() ne "O";
        my $lim_5 = &define5lim($annot,$annotations,$cg_len);
        my $GTGup = &DefineGTGup($annot,$lim_5);
        }
    }
}

sub define5lim {
    my ($ORFannot,$annotations,$cg_len)= @_;
    
    my $lim_5 = "";
    foreach my $annot (@$annotations) {
        next if $ORFannot eq $annot;
        next if $annot->get_type() eq "C";
        my $ORF_five   = $ORFannot->get_startpos();
        my $ORFisMinus = $ORFannot->get_direction eq "==>" ? 0 : 1;
        if ($ORFisMinus == 1) {
            my $min = $annot->get_startpos() < $annot->get_endpos() ? $annot->get_startpos : $annot->get_endpos();
            next if $min < $ORF_five;
            $lim_5 = $min if !$lim_5;
            $lim_5 = $lim_5 < $min ? $lim_5 : $min;
        }
        else {
            my $max = $annot->get_startpos() > $annot->get_endpos() ? $annot->get_startpos : $annot->get_endpos();
            next if $max > $ORF_five;
            $lim_5 = $max if !$lim_5;
            $lim_5 = $lim_5 > $max ? $lim_5 : $max;
        }
    }
    if ($lim_5 eq "") {
    my $isMinus = $ORFannot->get_direction eq "<==" ? 1 : 0;
        $lim_5 = !$isMinus ? 1 : $cg_len;
    }
    return $lim_5;
}

sub DefineGTGup {
    my ($annot,$lim_5) = @_;

    my $possible_starts = $annot->get_possStart();
    my $isMinus         = $annot->get_direction eq "<==" ? 1 : 0;
    my $ori_start       = $annot->get_startpos();
    my ($alt_GTG,$aa)   = "";
    foreach my $pos_start (@$possible_starts) {
        next if ($pos_start->[1] < $lim_5)      && !$isMinus;
        next if ($pos_start->[1] >= $ori_start) && !$isMinus;
        next if ($pos_start->[1] > $lim_5)      && $isMinus;
        next if ($pos_start->[1] <= $ori_start) && $isMinus;
        $aa = $pos_start->[0];
        next if $aa eq "ATG";
        $alt_GTG = $pos_start->[1];
    }
    my $startline = $annot->get_startline();
    $startline .= " ;; mfannot: $aa upstream: $alt_GTG" if $alt_GTG;
    $annot->set_startline($startline);
}

#------------------------------------#
# Subs for processing intronic ORFs  #
#------------------------------------#

sub AnnotateIntronicOrfs {
    my $contigs             = $pirmaster->get_contigs();
    my $minimumlengthorf_nt = $MINLENEMPTYORF;
    my $minimumlengthorf_aa = $minimumlengthorf_nt / 3;
    my $intronic_orfs;
    my $potential_intronic_orfs;
    
    foreach my $contig (@$contigs) {
        my $name       = $contig->get_name();
        my $annotation = $contig->get_annotations();
        my $seq        = $contig->get_sequence();
           $seq        =~ s/[^atcgATCGnN]//g;
        my $test_prot  = "";
        foreach my $annot (@$annotation) {
            my $type      = $annot->get_type();
            next if $type ne "I";
            my $direction = $annot->get_direction();
            my $start     = $annot->get_startpos();
            my $end       = $annot->get_endpos();
            my $startline = $annot->get_startline();
            my $endline   = $annot->get_endline();
            my ($prefix,$prot) = ("","");
            my @orf; 
            
               $prefix     = $1 if $endline   =~ /;\s+G-(\S+)/;
            my $num_intron = $2 if $startline =~ m#G-(\S+)-I(\d+)#;
            for (my $j = 0; $j < 3; $j++) {
                $start                 = $annot->get_startpos() + $j if $direction eq "==>";
                $start                 = $annot->get_startpos() - $j if $direction eq "<==";
                my $min_pos            = ($direction eq "==>" ? $start : $end );
                my $max_pos            = ($direction eq "==>" ? $end : $start );
                my $diff               = $max_pos - $min_pos + 1;
                my $intronic_sequence  = substr($seq, $min_pos -1, $diff);
                my $modulo             = length($intronic_sequence) % 3;
                $intronic_sequence     =~ tr/acgt/ACGT/;
                $intronic_sequence     =~ tr/ACGT/TGCA/ if $direction eq "<==";
                $intronic_sequence     = reverse $intronic_sequence if $direction eq "<==";
                $intronic_sequence     = substr($intronic_sequence,0, length($intronic_sequence)-$modulo);
                $intronic_sequence     =~ tr/a-z/A-Z/;
                my @pos_of_stop        = ();
                ($prot = $intronic_sequence ) =~ s/(...)/$CODON_TABLE->{$1}/ge;
                for (my $i = 0; $i <= length($intronic_sequence) - 3 ; $i += 3) {
                    my $orf;
                    my $strand_current_orf = $direction; 
                    my $nt = substr($intronic_sequence,$i,3);
                    my $aa = $CODON_TABLE->{$nt};
                    if ($aa eq "*") {
                        my $relative_pos_of_stop = $i + 3; # In order to include stop codon
                        push(@pos_of_stop, $relative_pos_of_stop);
                    } # if
                } # for
                unshift(@pos_of_stop, 0);
                for (my $i = 0; $i < @pos_of_stop - 1; $i++){
                    next if !( abs($pos_of_stop[$i+1] - $pos_of_stop[$i]) >= $minimumlengthorf_nt );
                    my $start_orf = $start + $pos_of_stop[$i]       if $direction eq "==>";
                       $start_orf = $start - $pos_of_stop[$i]       if $direction eq "<==";
                    my $end_orf   = $start + $pos_of_stop[$i+1] - 1 if $direction eq "==>";
                       $end_orf   = $start - $pos_of_stop[$i+1] + 1 if $direction eq "<==";

                    my $intronic_orf = new PirObject::EmptyOrf (
                                                                start      => $start_orf,
                                                                end        => $end_orf,
                                                                strand     => $direction,
                                                                contigname => $name,
                                                                intron     => $num_intron,
                                                                phase      => $j,
                                                                prefix     => $prefix
                                                               );
                    push (@$intronic_orfs, $intronic_orf);
                } # for $i
            } # for $j
        } # foreach annot
    } # foreach contig
        
    foreach my $intronic_orf (@$intronic_orfs) {
        my $annotIsOk         = 0;
        my $start_orf         = $intronic_orf->get_start();
        my $end_orf           = $intronic_orf->get_end();
        my $direction         = $intronic_orf->get_strand();
        my $contigname        = $intronic_orf->get_contigname();
        my $prefix            = $intronic_orf->get_prefix(); 
        my $contig            = $pirmaster->GetContigByName($contigname) or die "Can't get contig by name in AnnotateIntronicOrfs\n";
        my $seq               = $contig->sequence;              # Get the sequence
           $seq               =~ s/!//g;                        # Remove ! from the sequence
        my $annot_who_overlap = &WhatOverlapsThis($start_orf,$end_orf,$contig);
        my $isInPhase         = &IsInPhase($intronic_orf,@$annot_who_overlap);
        my $isMinus           = ($direction eq "==>" ? 0 : 1);
        my $posOffset         = ($isMinus ? -3 : 3);

        for (;;$start_orf += $posOffset) {
            last if $start_orf >= $end_orf   && !$isMinus;
            last if $end_orf   >= $start_orf && $isMinus;
            last if  (($end_orf - $start_orf + 1 ) < $minimumlengthorf_nt) && !$isMinus;
            last if  (($start_orf - $end_orf + 1 ) < $minimumlengthorf_nt) &&  $isMinus;  #  Size verification 
    
            my $codon = uc (substr($seq, $start_orf - 1, 3)) if !$isMinus;
               $codon = uc (substr($seq, $start_orf - 3, 3)) if $isMinus;
               $codon =~ tr/ACGT/TGCA/ if $isMinus;
               $codon = reverse $codon if $isMinus;
               if ($isInPhase) {
                   my $aa = $CODON_TABLE->{$codon};
                   $intronic_orf->set_firstAA($aa);
                   $codon = "ATG" if $isInPhase;
               }
  
            next unless defined($CODON_TABLE->{$codon})  && $CODON_TABLE->{$codon} eq "M";
            $annotIsOk = 1;
            last;
        }
 
        next if !( $annotIsOk == 1);
        # Creating an annotation object for storing in the masterfile
        my $orfsize = ($end_orf - $start_orf + 1)/3  if  !$isMinus;
           $orfsize = ($start_orf - $end_orf + 1)/3  if   $isMinus;
           $orfsize--; # Minus 1 for the stop codon
        my $GenenameORF = "orf". $orfsize;
  
        my $diff_nt = $end_orf - $start_orf + 1 if $direction eq "==>";
           $diff_nt = $start_orf - $end_orf + 1 if $direction eq "<==";
   
        my $seq_orf_nt = substr($seq, $start_orf - 1, $diff_nt) if $direction eq "==>";
           $seq_orf_nt = substr($seq, $end_orf - 1 , $diff_nt)  if $direction eq "<==";
           $seq_orf_nt =~ tr/ACGT/TGCA/                         if $direction eq "<==";
           $seq_orf_nt = reverse $seq_orf_nt                    if $direction eq "<==";
           $seq_orf_nt =~ tr/a-z/A-Z/;
  
        my $seq_orf_aa = "";
        ($seq_orf_aa = $seq_orf_nt ) =~ s/(...)/$CODON_TABLE->{$1}/ge;

        my $potential_intronic_orf = new PirObject::EmptyOrf (
                                                              start      => $start_orf,
                                                              end        => $end_orf,
                                                              strand     => $direction,
                                                              contigname => $contigname,
                                                              intron     => $intronic_orf->get_intron(),
                                                              phase      => $intronic_orf->get_phase(),
                                                              prefix     => $prefix,
                                                              size       => $orfsize,
                                                              seq        => $seq_orf_aa,
                                                              firstAA   => $intronic_orf->get_firstAA()
                                                             );
        push (@$potential_intronic_orfs, $potential_intronic_orf);
    }
    
    my %no_annotation;
    return if !$potential_intronic_orfs;
    for (my $i = 0; $i < @$potential_intronic_orfs; $i++) {
        my $start_orf_1     = @$potential_intronic_orfs[$i]->get_start();
        my $end_orf_1       = @$potential_intronic_orfs[$i]->get_end();
        my $direction_orf_1 = @$potential_intronic_orfs[$i]->get_strand();
        my $contig_orf_1    = @$potential_intronic_orfs[$i]->get_contigname();
        my $min_pos_orf_1   = ($direction_orf_1 eq "==>" ? $start_orf_1 : $end_orf_1);
        my $max_pos_orf_1   = ($direction_orf_1 eq "==>" ? $end_orf_1   : $start_orf_1);
        my @tab_for_choose_intron;
        my $selected_orf    = "";
        push(@tab_for_choose_intron, [$i, @$potential_intronic_orfs[$i]]); 
        for (my $j = 0; $j < @$potential_intronic_orfs; $j++) {
            next if !($j != $i);
            my $contig_orf_2    = @$potential_intronic_orfs[$j]->get_contigname();
            next if ($contig_orf_1 ne $contig_orf_2);
            my $start_orf_2     = @$potential_intronic_orfs[$j]->get_start();
            my $end_orf_2       = @$potential_intronic_orfs[$j]->get_end();
            my $direction_orf_2 = @$potential_intronic_orfs[$j]->get_strand();
            my $min_pos_orf_2   = ($direction_orf_2 eq "==>" ? $start_orf_2 : $end_orf_2 );
            my $max_pos_orf_2   = ($direction_orf_2 eq "==>" ? $end_orf_2   : $start_orf_2);
            next if !(!($max_pos_orf_1 < $min_pos_orf_2 || $max_pos_orf_2 < $min_pos_orf_1));
            push(@tab_for_choose_intron, [$j, @$potential_intronic_orfs[$j]]); 
         }

        if (@tab_for_choose_intron > 1) {
            my $num_selected_orf = &choice_orf(\@tab_for_choose_intron);
            $selected_orf = @$potential_intronic_orfs[$i] if $num_selected_orf == $i;
        }
        else {
            $selected_orf = @$potential_intronic_orfs[$i];
        }

        next if !($selected_orf ne "");
        #  Treatment to add a number after the genename #
        my $GenenameORF = "orf".$selected_orf->get_size();
        my $direction   = $selected_orf->get_strand();
        my $prefix      = $selected_orf->get_prefix(); 
        my $contigname  = $selected_orf->get_contigname();
        my $first_aa    = $selected_orf->get_firstAA();
        my $startline   = ";     G-$GenenameORF $direction start";
        if ($prefix ne "") {
           $startline   = $first_aa ? ";     G-$prefix-"."$GenenameORF $direction start /first_aa=$first_aa"
                                    : ";     G-$prefix-"."$GenenameORF $direction start";
        }
        my $endline     = ";     G-$GenenameORF $direction end";
           $endline     = ";     G-$prefix-"."$GenenameORF $direction end" if $prefix ne "";
        
        #  Treatment to add a number after the genename #
        my $orfannot = new PirObject::AnnotPair(
                                                type      => "O",  
                                                genename  => $GenenameORF,
                                                startpos  => $selected_orf->get_start(),
                                                endpos    => $selected_orf->get_end(),
                                                direction => $direction,
                                                startline => $startline,
                                                endline   => $endline,
                                               );

        # Put into the table containing all of the masterfile annotations
        # So before, being put in the masterfile (means in a first time in the annotation table), there are some verification
        &AddAnnotToPirMaster($contigname,$orfannot);
    } # End for
} # End sub

sub choice_orf {
    my $orfs = shift;  # Ref to array of pairs [ idx, Orf_object ]
    
    if (!(-e "$TMPDIR/fdb_intronic_orf.log")) {
        my $LIB = new IO::File "$intronic_lib" || die ("Can not open the library for intronic orfs");
        while (<$LIB>) {
            next if !($_ =~ /^>/);
            die "The file $intronic_lib haven't the good syntax\nThe line who haven't the good syntax is $_"
                if (!($_ =~ /\s*([\S]*)\s*;/));
        }
        $LIB->close();
    
        my $command      = "$FORMATDBPATH -p 'T' -t banque -i $intronic_lib -n $TMPDIR/mf_intronic_orf -l $TMPDIR/fdb_intronic_orf.log >/dev/null 2>/dev/null";
        print "$command\n" if $DEBUG;
        my $resformatdb  = system($command);
    }
    
    foreach my $orf ( @$orfs ) {
        my $name_of_file = "$TMPDIR/orf_".$orf->[0];
        my $orf_seq      = $orf->[1]->get_seq();
        my $orf_num      = $orf->[0];
        my $output       = "$TMPDIR/blastoutput_orf_".$orf->[0];
        my $type         = 'PROT';
        if (!(-e "$name_of_file")){
            my $ORFFILE = new IO::File ">$name_of_file" or die "Can not open the orffile";
            print $ORFFILE ">ORF_$orf_num\n";
            print $ORFFILE $orf_seq;
            $ORFFILE->close();
            
            # RUN FOR BLAST : run blast with the db created and the flip results        
            my $cmdblast = "$BLASTPATH -m 7 -p blastp -M $MATRIX -d $TMPDIR/mf_intronic_orf -i $name_of_file -D $GENCODE -o $output 2> $TMPDIR/blasterr_1.txt";
            print "$cmdblast\n" if $DEBUG;
            my $resblast = system ($cmdblast);
        }
        
        my $searchfh = new IO::File "<$output"
           or die "Error: can't find $type report from blastall ?!?\n";
        my @results = PirObject::BlastOutput->FileHandleToObject($searchfh);
        $searchfh->close();

        my $num    = @results;
        die "We have more than 1 blast result for 1 orf\n" if $num > 1;

        $orf->[1]->set_evalue(9999);                # Really bad evalue by default

        my $iters  = $results[0]->BlastOutput_iterations() || next;
        next if @$iters == 0;
        my $hits   = $iters->[0]->Iteration_hits();
        next if !@$hits;
        my $best_evalue = $hits->[0]->significance();

        $orf->[1]->set_evalue($best_evalue);
    }
    
    my @orfs_sorted = sort{ &CompareHighPrecisionFloats($a->[1]->get_evalue(),$b->[1]->get_evalue())
                                                  ||
                            $b->[1]->get_size()  <=>  $a->[1]->get_size() } @$orfs;
    
    return $orfs_sorted[0]->[0];
} # End sub

sub IsInPhase {
    my ($intronic_orf,$annot_who_overlap) = @_;
    
    my $strand_orf     = $intronic_orf->get_strand();
    my $start_orf      = $intronic_orf->get_start();
    my $phase_orf      = $intronic_orf->get_phase();
    my $num_intron     = $intronic_orf->get_intron();
    my ($length_add,$distance_inf_3) = (0,0);
    
    foreach my $features_who_overlap (@$annot_who_overlap) {
        my $feature     = $features_who_overlap->[2];
        my $f_type      = $feature->get_type();    
        my $f_start     = $feature->get_startpos();
        my $f_end       = $feature->get_endpos();
        my $f_direction = $feature->get_direction();
        my $f_startline = $feature->get_startline();
        next if !($f_type eq "E");
        $f_startline =~ m#G-(\S+)-E(\d+)#;
        my $num_exon       = $2;
        my $min_pos        = ($f_direction eq "==>" ? $f_start : $f_end );
        my $max_pos        = ($f_direction eq "==>" ? $f_end   : $f_start );
        if ($num_exon == $num_intron) {
            $distance_inf_3 = 1 if $f_direction eq "==>" && $start_orf - $f_end <= 3; 
            $distance_inf_3 = 1 if $f_direction eq "<==" && $f_end - $start_orf <= 3;
        }
        if ($num_exon <= $num_intron) {
            my $length   = $max_pos - $min_pos + 1;
            $length_add += $length;
        }
    } # End foreach $features_who_overlap
    $length_add += $phase_orf;
    return 1 if ($length_add % 3 == 0 && $distance_inf_3 == 1);
    return 0;
} # End sub

#--------------------------------------------------#
# Subs used for check Multicomments And Lc Introns #
#--------------------------------------------------#

sub MulticommentConfidence {
    my $contigs   = $pirmaster->get_contigs();
    
    foreach my $contig (@$contigs) {
        my $annotations = $contig->get_annotations();
        foreach my $annot (@$annotations) {
            my $startmulticomments = $annot->get_startmulticomment();
            my $endmulticomments   = $annot->get_endmulticomment();
            next if !$startmulticomments->[0] && !$endmulticomments->[0];
            
            if ($startmulticomments->[0]) {
                my $startline = $annot->get_startline();
                   $startline =~ s/\s*\\?\s*$/ \\/ ;
                   $annot->set_startline($startline);
                foreach my $line (@$startmulticomments) {
                    last if $line eq $startmulticomments->[-1];
                    $line      =~ s/\s*\\?\s*$/ \\/;
                }
            }
            
            if ($endmulticomments->[0]) {
                my $endline = $annot->get_endline();
                   $endline =~ s/\s*\\?\s*$/ \\/;
                   $annot->set_endline($endline);
                foreach my $line (@$endmulticomments) {
                    last if $line eq $endmulticomments->[-1];
                    $line    =~ s/\s*\\?\s*$/ \\/;
                }
            }
        }
    }
}

sub LcIntrons {
    my $contigs   = $pirmaster->get_contigs();
    
    foreach my $contig (@$contigs) {
        # my $name   = $contig->get_name();
        # my $header = $CONTIG->{"$name"};
        # $contig->set_name($header);
        my $seq = $contig->get_sequence();
           $seq =~ s/!//g;
        my $annotations = $contig->get_annotations();
        foreach my $annot (@$annotations) {
            my $type = $annot->get_type();
            next if $type ne "I";
            my $intron_type = $annot->get_introntype();
            next if $intron_type && $intron_type =~ m/,/;
            &LCIntronInSeqContig($annot->get_startpos(),$annot->get_endpos(),$contig);
        }
        foreach my $annot (@$annotations) {
            my $genename = $annot->get_genename();
            next if !$genename || $genename ne "comment";
            my $start_line = $annot->get_startline();
            next if $start_line !~ m/group=/;
            &LCIntronInSeqContig($annot->get_startpos(),$annot->get_endpos(),$contig);
        }
    }
}

sub LCIntronInSeqContig {
    my ($AP_start,$AP_end,$contig) = @_;
    
    my $seq = $contig->get_sequence();
    my ($AP_min,$AP_max) = $AP_start < $AP_end ? ($AP_start,$AP_end) : ($AP_end,$AP_start);
    my $intron_seq = lc(substr($seq,$AP_min-1,$AP_max-$AP_min+1));
    substr($seq,$AP_min-1,length($intron_seq),$intron_seq);
    $contig->set_sequence($seq);
}

sub ReplaceCgName {
    my $contigs   = $pirmaster->get_contigs();
    
    foreach my $contig (@$contigs) {
        my $name   = $contig->get_name();
        my $header = $CONTIG->{"$name"};
        $contig->set_name($header);
    }
}

#---------------------------------#
# Subs for processing motifs      #
#---------------------------------#

sub read_pat_file{
    my $pfile = shift;

    my($name, $regexp);
    
    my $infh  = new IO::File "<$pfile"
        or die "Can't read from file '$pfile': $!\n";
    my $list_of_mot = ();
    
	while( <$infh> ){
	    chomp;
        my $line = $_;
	    next if $line =~ m/^\s*$/ || $line =~ m/^#/ ; # skip blank lines
	    # A pattern line
        if ( $line =~ m/^\s*\S+\s+(\S+)\s+(\S+)\s*$/ ){
            ($name, $regexp) = ($1,$2);
            die "Multiple pattern have same name $name,please fixed that in $pfile"
                if $list_of_mot->{$name};
            $name =~ s/^\s*//, $name =~ s/\s*$//;
            # Validate name.
            &PrintError("name",$name,$pfile) if ( $name =~ /\s/ or !$name ); 
            # Validate regexp.
            my $invalid_pat = 0;
            $regexp =~ s/\s//g;
            &PrintError("regexp",$regexp,$pfile) if $regexp eq '';
            &PrintError("regexp",$regexp,$pfile) if $regexp =~ /[^ a c g t n { } \d \[ \] ( ) , \* \? \+ .]/i;
            eval "'' =~ /$regexp/";
            &PrintError("regexp",$regexp,$pfile) if $@;
            &PrintError("regexp",$regexp,$pfile) if '' =~ /$regexp/;
            &PrintError("regexp",$regexp,$pfile) if $regexp =~ / \*\? | \}\? | \+\? | \?\? /x;
            $list_of_mot->{$name} = $regexp;
	    }
	    # Line is invalid
	    else{
            print "File $pfile contains syntax errors on line $..\n";
		    print "Please correct them and rerun $BASENAME.\n";
		    return 1;
	    }
	}
    $infh->close();
    return $list_of_mot;
}

sub PrintError {
    my ($isInvalid,$name,$pfile) = @_;
    
    print "Invalid $isInvalid '$name' found in file $pfile\n";
    print "Please correct $pfile and rerun $BASENAME.\n";
}

sub SearchMotAndMakeAP {
    
    foreach my $name (keys %$LISTPAT) {
        my $pat = $LISTPAT->{$name};
    
        my $rev_pat = $pat;
           $rev_pat =~ tr/ACGT/TGCA/;
           $rev_pat = reverse $rev_pat;
        my $isPal   = $pat eq $rev_pat && $pat =~ /^[a_zA-Z]+$/ ? 1 : 0;
        
        foreach my $contig ( @$contigs) {
            my $contigname = $contig->get_name();
            
            my $seq     = uc($contig->sequence());
               $seq     =~ s/!//g;
            my $rev_seq = $seq;
               $rev_seq =~ tr/ACGT/TGCA/;
               $rev_seq = reverse $rev_seq;
            my $len_seq = length ($seq);
            
            for(;;){
                # Forward
                my ($start,$end,$prev_start) = (0,0,0);
                my $sub_seq      = $seq;
                for (;;) {
                    last if ($sub_seq !~ /(?i)$pat/ );
                    $start       = length($`) + $prev_start ;
                    $end         = $start + length($&);
                    
                    my $mot = new PirObject::AnnotPair(
                                                     type      => "S",
                                                     genename  => $name,
                                                     startpos  => $start + 1,
                                                     endpos    => $end,
                                                     direction => "==>",
                                                     startline => "; G-Sig-$name ==> start",
                                                     endline   => "; G-Sig-$name ==> end",
                                                     );
                    &AddAnnotToPirMaster($contigname,$mot);
                    
                    $prev_start      = $start + 1;
                    $sub_seq = substr($seq, $prev_start);
                }
                
                # Backward
                ($start,$end,$prev_start) = (0,0,0);
                $sub_seq      = $rev_seq;
                for (;;) {
                    last if $isPal;
                    last if ($sub_seq !~ /(?i)$pat/ );
                    $start       = length($`) + $prev_start ;
                    $end         = $start + length($&);
                    
                    my $mot = new PirObject::AnnotPair(
                                                     type      => "S",
                                                     genename  => $name,
                                                     startpos  => $len_seq - $start,
                                                     endpos    => $len_seq - $end + 1,
                                                     direction => "<==",
                                                     startline => "; G-Sig-$name <== start",
                                                     endline   => "; G-Sig-$name <== end",
                                                     );
                    &AddAnnotToPirMaster($contigname,$mot);
                    $prev_start      = $start + 1;
                    $sub_seq = substr($rev_seq, $prev_start);
                }
                last;
            }
        }
    }
}


#------------------------------------------#
# Subs used at different times in Mfannot  #
#------------------------------------------#

sub AddAnnotToPirMaster {
    # Meaning code for this function
    # return 1 means ok, it has been added
    # return 0 means function quit before the end, => rediscovered 
    my $contigname  = shift;
    my $annot       = shift;
    my $contig      = $pirmaster->GetContigByName($contigname) or die "Can't get contig by name in AddAnnotToPirMaster\n";
    my $annotations = $contig->get_annotations;
    
    # Here we compare all the annotations, with the one we try to add
    if (scalar(@$annotations) != 0 && $annot->type ne "S") {
        my $return_val = &CompareAllAnnot($annotations,$annot);
        return $return_val if $return_val != -1;
    }
    
    push (@$annotations, $annot) if ($annot->type eq "C");
    return 1                     if ($annot->type eq "C");
     
    # It mean, this annotation has already been seen
    return 0 if (&AnnotAlreadyAtSamePlace($annotations, $annot->startpos, $annot->endpos, $annot->genename,$annot->type,$annot->direction));
    
    push (@$annotations, $annot) if ($annot->type eq "S");
    return 1                     if ($annot->type eq "S");
    
    #  It means, force annot but this annotations doesn't seems to have an other copy
    $ANNOT_STATS->{'Added'}->{$annot->genename} ||= {  'I' => 0, 'E' => 0, } if ($annot->genename ne "comment");
    push (@$annotations, $annot);
    return 1;
}

sub CompareAllAnnot {
    my ($annotations,$annot) = @_;
    
    foreach my $annotation (@$annotations) {
        my $annotname  = $annotation->get_genename(); 
        my $annottype  = $annotation->get_type() || "C";
        my $annotstart = $annotation->get_startpos();
        my $annotend   = $annotation->get_endpos();
        my $annotdir   = $annotation->get_direction();
        $annotname     = "comment" if (!defined  ($annotname));
        $annotstart    = -1        if (!defined  ($annotstart));
        $annotend      = -1        if (!defined  ($annotend));
        
        # First case : if both are same comment on the same line 
        if (($annottype eq "C") and ($annot->type eq "C") and
            ($annot->startpos == $annotstart) and ($annot->startline eq $annotation->startline)) {
            # Nothing is done in this case,
            return 0;
        }

        # Second case : No comment, both have same start end, and genename;
        return 0 if (($annottype ne "C") and ($annotname eq $annot->genename) and
                     ($annotstart == $annot->startpos) and ($annotend == $annot->endpos)
                     and $annotdir eq $annot->get_direction());

        # Third case : Exons
        if ($annot->type eq "E") { 
            # It's an exon. The protein has normally already been added
            $ANNOT_STATS->{'Added'}->{$annot->genename}->{'E'} ++ if (defined ($annot->genename));
            push (@$annotations, $annot);
            return 1;
        }

        # 4th case : Introns
        if ($annot->type eq "I") { 
            # it's an intron. The protein has normally already been added
            $ANNOT_STATS->{'Added'}->{$annot->genename}->{'I'} ++ if (defined ($annot->genename));
            push (@$annotations, $annot);
            return 1;
        }
    }
    return -1;
}

sub AnnotAlreadyAtSamePlace {
    my ($annotations,$start,$end,$name,$type,$dir) = @_;
    
    return if $name =~ /^!/;
    ($start,$end) = ($end,$start) if $start > $end;
    $name =~ s/_\d+$//;

    foreach my $annotation (@$annotations) {
        next if $annotation->type eq "C";
        next if $annotation->genename =~ /^!/;
        my $annot_name  = $annotation->genename;
        my $annot_start = $annotation->startpos;
        my $annot_end   = $annotation->endpos;
        my $annot_dir   = $annotation->direction();
        if ($type ne "S") {
            $annot_name     =~ s/_\d+$//;  
            ($annot_start,$annot_end) = ($annot_end,$annot_start) if $annot_start > $annot_end; 
            return 1 if ( (!($end < $annot_start || $annot_end < $start)) && $name eq $annot_name);
        }
        else {
            ($annot_start,$annot_end) = ($annot_end,$annot_start) if $annot_start > $annot_end; 
            return 1 if $start == $annot_start && $end == $annot_end && $name eq $annot_name && $dir eq $annot_dir;
        }
    } # End foreach $annot
    return 0;
} # End sub

sub WhatOverlapsThis {
    my $wstart     = shift;
    my $wend       = shift;
    my $contig     = shift;

    my $contiglen  = $contig->get_sequencelength();
    my $annotlist  = $contig->get_annotations() || [];
    
    ($wstart, $wend) = ($wend, $wstart) if $wend < $wstart;

    my @GEI_annots = grep( $_->get_type() =~ m#^[GEIO]$# , @$annotlist);
    my %RanksGEI   = ( G => 0, E => 1, I => 2, O => 3 );
    @GEI_annots    = sort { $a->get_genename() cmp $b->get_genename()
                                                or
                     $RanksGEI{$a->get_type()} <=> $RanksGEI{$b->get_type()}
                                                or
                            $a->get_startpos() <=> $b->get_startpos();
                           } @GEI_annots;

    my $groups = [];
    foreach my $annotation (@GEI_annots) {
        my $genename  = $annotation->get_genename(); # Does NOT contain the _1
        my $type      = $annotation->get_type();
        my $startline = $annotation->get_startline();
        my $start     = $annotation->get_startpos();
        my $end       = $annotation->get_endpos();
        my $dir       = $annotation->get_direction() || "==>";

        my ($ostart,$oend) = ($start,$end); # Strandless interval
           ($ostart,$oend) = ($end,$start) if $end < $start;

        if ($type eq "G" || $type eq "O") {
            next unless # No overlap? next
                &OverlappingRegions($contiglen,$start,$end,$dir,$wstart,$wend,">"); # Real dir of orf not important
            push(@$groups, [ [ $ostart, $oend, $annotation ] ] );
            next;
        }

        # For introns and exons
        foreach my $group (@$groups) {
            my $geneinfo = $group->[0]; # First entry of group is always a gene object
            my $gi_name  = $geneinfo->[2]->get_genename();
            next unless $gi_name eq $genename;
            my $gstart = $geneinfo->[2]->get_startpos();
            my $gend   = $geneinfo->[2]->get_endpos();
            my $gdir   = $geneinfo->[2]->get_direction();
            next unless # if E or I is outside of gene
                &OverlappingRegions($contiglen,$start,$end,$dir,$gstart,$gend,$gdir);
            push(@$group, [ $ostart, $oend, $annotation ] );
            #  last; # commented out in case for some reason an exon overlap multiple genes with the same names!
        } # End foreach $group
    } # End foreach $annotation

    # Now, flag the first and last exon of each group in field ->[3] of each group
    foreach my $group (@$groups) {
        $group->[0]->[3] = "";  # Flag set to false for first entry
        if (@$group == 1) {     # Gene with no introns
            $group->[0]->[3] = "YES";
            next;
        }
        my $maxexnum=0;
        my $maxexinfo="";
        for (my $i=1;$i<@$group;$i++) {
            my $info = $group->[$i];
            $info->[3] = "";  # Flag set to false
            next unless $info->[2]->get_type() eq "E";
            my $startline = $info->[2]->get_startline() || "";
            next unless $startline =~ m#G-(\S+)-E(\d+)#;
            my $exnum = $2;
            $info->[3] = "YES"   if $exnum == 1; # First exon flaged
            $info->[4] = "FIRST" if $exnum == 1; # First exon flaged
            $info->[4] = ""      if $exnum != 1; # First exon flaged
            if ($exnum > $maxexnum) {
                $maxexnum = $exnum;
                $maxexinfo = $info;
            }
        }
        if ($maxexinfo) {             # Should always be true here
            $maxexinfo->[3] = "YES";  # This is the last exon of the group
            $maxexinfo->[4] = "LAST"; # This is the last exon of the group
        }
    }
    $groups;
} # End sub

sub OverlappingRegions {
    # Works even for circular genomes and regions that span the gap
    my ($seqlen,$start1,$end1,$dir1,$start2,$end2,$dir2) = @_;

    my $spansgap1 = (($dir1 =~ m#>#) xor ($start1 <= $end1)); # true means spans the gap
    my $spansgap2 = (($dir2 =~ m#>#) xor ($start2 <= $end2)); # true means spans the gap

    if ($spansgap1) {
        if ($dir1 =~ m#>#) {
            $end1 += $seqlen;
        } 
        else {
            $start1 += $seqlen;
        }
    }

    if ($spansgap2) {
        if ($dir2 =~ m#>#) {
            $end2 += $seqlen;
        }
        else {
            $start2 += $seqlen;
        }
    }

    ($start1,$end1) = ($end1,$start1) if $start1 > $end1;
    ($start2,$end2) = ($end2,$start2) if $start2 > $end2;

    # Test for overlap
    return 1 if ! ($end1 < $start2 || $start1 > $end2);
    return 0 if $spansgap1 == $spansgap2; # same spanning sit -> we're done

    if (! $spansgap1) {
        $start1 += $seqlen;
        $end1   += $seqlen;
    }

    if (! $spansgap2) {
        $start2 += $seqlen;
        $end2   += $seqlen;
    }

    # Test for overlap again, new situation
    return 1 if ! ($end1 < $start2 || $start1 > $end2);
    return 0; # really, no overlap
} # End sub

sub WhichPhase {
    # In order to know the phase of the intron
    my ($annot,$num_intron,$contig) = @_;
    
    my $annot_who_overlap = &WhatOverlapsThis($annot->startpos(),$annot->endpos(),$contig);
    
    my $nb_nt = 0;     # Length of all exon before the intron who studies
    foreach my $annotation_who_overlap (@$annot_who_overlap){
        foreach my $feature_who_overlap (@$annotation_who_overlap) {
            my $feature_min = @$feature_who_overlap[0];
            my $feature_max = @$feature_who_overlap[1];
            my $feature     = @$feature_who_overlap[2];
            next if !($feature->get_startline() =~ m#;\s+G-.+E(\d+).+#);
            my $number = $1 if $feature->get_startline() =~ m#;\s+G-.+E(\d+).+#;
            $nb_nt += abs($feature_max - $feature_min + 1 ) if $1 <= $num_intron;
        } # End foreach $feature_who_overlap
    } # End foreach $annotation_who_overlap
    my $phase = $nb_nt % 3 ;
} # End sub

sub Length_annot {
    # Just in order to calculate the length of annot
    my $annot = shift;
    
    my $start = $annot->startpos();
    my $end   = $annot->endpos();
    ($start,$end) = ($end,$start) if $annot->direction() eq "<=="; 
    my $length = ($end - $start + 1);
    return $length;
} # End sub


sub AddCommentToAnnotField {
    # Sub used to add comments at the end of annotation
    my ($annot,$method,$comment) = @_;
    
    my $line_to_modify  = $annot->$method();
    $line_to_modify .= " $comment" if ($line_to_modify !~ m#\Q$comment\E#);
    $annot->$method($line_to_modify);
} # End sub 

sub TranslateInProt {
    my $nt_seq = shift;
    
    my $prot_seq = "";
    foreach (my $i = 0; $i <= length($nt_seq) - 3; $i += 3) {
        my $tri_nt = uc (substr($nt_seq, $i , 3));
           $prot_seq .= $CODON_TABLE->{$tri_nt} || "X";
    }
    return $prot_seq;
}

sub ApPosStrandFW {
    my ($ap,$len_seq) = @_;

    my $apMinus  = ($ap->get_direction() eq "==>" ? 0 : 1);
    my $ap_start = $apMinus ? $len_seq + 1 - $ap->get_startpos() : $ap->get_startpos();
    my $ap_end   = $apMinus ? $len_seq + 1 - $ap->get_endpos()   : $ap->get_endpos() ;
    return ($ap_start,$ap_end);
}

#---------------------------------#
# Subs used at the end of Mfannot # 
#---------------------------------#

sub RenumberFeatures {
    # Post-processing: renumber gene names with unique
    # extensions such as _1, _2 etc. The original mechanism
    # that was trying to do this using %ANNOTSEEN is
    # broken, this routine does a better job.
    my %genename2suffix = (); # cox3 => { _1 => [ [ obj obj ] [ obj ] ], "" => [ [ obj obj ] [ obj ] ] }

    my $contigs = $pirmaster->get_contigs(); # Get the masterfiles contigs

    foreach my $contig (@$contigs) {         # Parse all the contig
        my $contiglen = $contig->get_sequencelength();

        my $annotations = $contig->get_annotations();
        my @GEI_annots = grep( $_->get_type() =~ m#^[GEIOS]$# , @$annotations);
        my %RanksGEI = ( G => 0, E => 1, I => 2, O => 3, S => 4);
        @GEI_annots = sort { $RanksGEI{$a->get_type()} <=> $RanksGEI{$b->get_type()}
                                                        or
                                    &IsIntronicOrf($a) <=> &IsIntronicOrf($b)
                                                        or
                                    $a->get_startpos() <=> $b->get_startpos();
                           } @GEI_annots;

        my %local_genename2suffix = (); # the %genename2suffix local to the current contig.
        foreach my $annotation (@GEI_annots) {
            my $genename  = $annotation->get_genename(); # Does NOT contain the _1
            my $type      = $annotation->get_type();
            my $startline = $annotation->get_startline() || "";
            my $start     = $annotation->get_startpos();
            my $end       = $annotation->get_endpos();
            my $dir       = $annotation->get_direction() || "==>";
            next if $type ne "S" && $LVL_MOT == 1;

            # We need to override for G-cox1_3-I4-orf34 for instance We want cox1 not orf34
            $genename = $2 if ($startline =~ m#G-(Sig)?-?([^\-\s]+)#);
            my ($IntronicORF,$orfname)  = (1,$1) if  ($startline =~ m#G-.+-I\d+-(orf\d+)#);
            $genename =~ s/_\d+$//; # Make sure
            
            my %genenames = ();
            my $suffix = "";
               $suffix = $1 if $startline =~ m#(_\d+)# && !$IntronicORF;
            $genenames{$genename} = $suffix;
            
               $suffix = "";
               $suffix = $1 if $startline =~ m#orf\d+(_\d+)#;
            $genenames{$orfname} = $suffix if defined $orfname;
            
            foreach my $name (keys %genenames) {
                $suffix = $genenames{$name};
                my $local_suffix2groups = $local_genename2suffix{$name} ||= {};
                my $groups              = $local_suffix2groups->{$suffix}   ||= [];
                my $addedToExistingGroup = 0;
                foreach my $group (@$groups) {
                    my $firstfeat = $group->[0];
                    my $ffstart   = $firstfeat->get_startpos();
                    my $ffend     = $firstfeat->get_endpos();
                    my $ffdir     = $firstfeat->get_direction() || "==>";
                    my $fftype    = $firstfeat->get_type();
                    next if $fftype eq "C";
    
                    if (&OverlappingRegions($contiglen,$start,$end,$dir,$ffstart,$ffend,$ffdir)) {
                        push(@$group,$annotation);
                        $addedToExistingGroup=1;
                        last;
                    }
                }
            my $comment = &ModifCommentForFirstStart($annotation,$annotations) if $annotation->get_type() eq "G";
            push(@$groups, [ $annotation ])           if (!$addedToExistingGroup) && !$comment;
            push(@$groups, [ $annotation ,$comment ]) if (!$addedToExistingGroup) &&  $comment;
            }
        } # End foreach annotation

        # Fusion %local_genename2suffix into the global %genename2suffix
        # We need to do this to keeps each contig's group separate
        foreach my $genename (keys %local_genename2suffix) {
            my $local_suffix2groups = $local_genename2suffix{$genename};
            my $suffix2groups       = $genename2suffix{$genename} ||= {};
            foreach my $suffix (keys %$local_suffix2groups) {
                my $local_groups = $local_suffix2groups->{$suffix};
                my $groups       = $suffix2groups->{$suffix} ||= [];
                push(@$groups, @$local_groups); # append to list
            }
        }
    } # End foreach contig
    
    # At this point, we've regrouped all G, E and I features in
    # overlapping groups based on their EXISTING suffixes. Now
    # let's fix these suffixes.

    foreach my $genename (keys %genename2suffix) {
        my $suffix2groups = $genename2suffix{$genename};
        my @suffixes = sort keys %$suffix2groups; # "" , _1, _2 etc etc

        next if ( @suffixes == 1 &&            # only one type of suffix found
                  $suffixes[0] eq "" &&        # case where only "genename" exists with no suffix
                  @{$suffix2groups->{""}} == 1 # a single instance? All ok.
                );

        # print "RENUMBER: $genename has duplicates: [",join("][",@suffixes),"]\n";
        # Ok, so we have a "" or _1 or _2 or _nn and/or a mix, we need to renumber
        my @keepnumbering=(); # We set aside those that need no renumbering; not used actually
        my @dorenumber=();    # These groups will be renumbered
        foreach my $suffix (@suffixes) {
            my $groups = $suffix2groups->{$suffix};
            if ($suffix eq "") {
                push(@dorenumber,@$groups); # All of them are renumbered
                next;
            }
            my $unchangedgroup = shift(@$groups); # Only first group KEEPS its number
            push(@keepnumbering,$unchangedgroup);
            push(@dorenumber,@$groups); # These get new numbers
        }

        # Renumber all annots of each group (each group gets a single new number)
        for (my $i = 1; @dorenumber > 0 ; $i++) {
            my $newsuf = "_$i";
            next if $suffix2groups->{$newsuf}; # Already used? try next suffix
            my $group = shift(@dorenumber);
            foreach my $annot (@$group) {
                my $origname  = $annot->get_genename();
                my $startline = $annot->get_startline();
                my $endline   = $annot->get_endline();
                my $type      = $annot->get_type();
                my $start     = $annot->get_startpos();
                my $end       = $annot->get_endpos();
                print "Warning: gene '$genename' ($start..$end) was renamed with suffix $newsuf to make it distinct.\n"
                    if ($type eq "G" || $type eq "O") && $origname eq $genename && $genename ne "comment"; # no warn if "cox1_1-I1-orf344"
                # print " -> To $newsuf : $startline ";
                $startline = &ReplaceNumber($startline,$newsuf,$genename,$annot);
                # print " -> $startline\n";
                $endline   = &ReplaceNumber($endline,$newsuf,$genename,$annot) if $endline;
                $annot->set_startline($startline);
                $annot->set_endline($endline);
            } # End foreach $annot
        } # End foreach $i
    } # End foreach $genename
} # End sub

# Substitutes, in a G- annotation line, the numbered suffix _1 _2 etc (which
# might not even be there) by a new suffix ($newsuf).
sub ReplaceNumber {
    my ($line,$newsuf,$genename,$annot) = @_;
    
    if ($genename =~ m/orf\d+/ && &IsIntronicOrf($annot)) {
        $line =~ s/(orf\d+)_*\d*/${1}${newsuf}/;  # Remove existing _1
    }
    else {
        $line =~ s/(G-[^_\s]+)_\d+/$1/  if !&IsIntronicOrf($annot);  # Remove existing _1
        $line =~ s/(G-[^_\s]+)_\d+-/$1/ if  &IsIntronicOrf($annot); # Remove existing _1
        if ($line =~ m#G-\S+-[EI]\d+#) { # Exon or intron ?
            $line =~ s/(-[EI]\d+)/$newsuf$1/;
        } 
        else {
            $line =~ s/(G-\S+)/$1$newsuf/;
        }
    }
    $line;
} # End sub

sub ModifCommentForFirstStart {
    my ($annotation,$annotations) = @_;
    
    my $AnnotationStart = $annotation->get_startpos();
    foreach my $annot (@$annotations){
        next if $annot->get_type() ne "C";
        my $startline = $annot->get_startline();
        next if $startline !~ m/First start found (\d+)/;
        my $AnnotStart = $1;
        next if $AnnotStart != $AnnotationStart;
        $startline =~ s/First start found (\d+)/First start found/;
        $annot->set_startline($startline);
        return $annot;
    }
}

sub IsIntronicOrf {
    # Returns 1 if annotation line is like G-gene-Inn-orfblahblah
    my $annot = shift;
    return 0 unless $annot->get_type() eq "O";
    my $startline = $annot->get_startline() || "";
    print "WARNING NO START LINE IN OBJ:\n",$annot->ObjectToXML() if !defined($startline); 
    $startline =~ m#G-\S+-I\d+-\S+#  ? return 1 : return 0;
} # End sub

sub LogInfo {
    # This function is supposed to add information
    # in the head of the masterfile such as
    # - the genes added (with exons)
    my $comment   = $pirmaster->get_comment();
    my $header    = [];
    my @report    = ();
    my $added     = $ANNOT_STATS->{'Added'};
    my @added     = sort keys %$added;
    my $comp_add  = 0;
    
    foreach my $genename (@added){ 
        $comp_add++ if ( $genename =~ /^!/);  
    }

    my $gene_add = scalar(@added) - $comp_add;
    push(@report, ";;    - Gene Totals: " . $gene_add,);
    push(@report, ";;    - List of genes added:",) if @added;

    my ($COLS,$cnt,$rep) = (3,0,"");

    print "Added : ", $gene_add, "\n" if $DEBUG;
    print $LOG_F "Added : ", $gene_add, "\n" if $ISLOGFILE;

    foreach my $genename (@added) {
        next if $genename !~ /^[^!]/;
        my($e,$i) = (($added->{$genename}->{'E'} || 0),($added->{$genename}->{'I'} || 0)); 
        $rep      = ";;     " if !$cnt;
        $rep     .= sprintf(" %-20s", ("$genename" . ($i >= 1 ? " ($i introns)" : "")));
        $cnt++;
        next if $cnt < $COLS;
        push(@report, $rep);
        $cnt  = 0;
    }
    push(@report, $rep) if $cnt;

    push(@$header, ";; Masterfile modified automatically by $BASENAME version $VERSION");
    push(@$header, ";; on " . scalar(localtime(time))  . " by user $USER on host " . hostname()) if !$MAIL;
    push(@$header, @report, ";;",);
    push(@$header, $add_text_in_header) if $add_text_in_header ne "";
    push(@$header, ";; end mfannot\n;;");
    push(@$header, @$comment);
    $pirmaster->set_header($header);
}

sub CreateTBLoutput {
    my $filename = shift;
    
    # Faire un premier tour dans mf2sqn pour faire le subInfo.
    my $initial_dir = getcwd;
    chdir("$TMPDIR");
    
    my $mf2sqnErr   = "$TMPDIR/mf2sqnErr1";
    my $mf2sqnOut   = "$TMPDIR/mf2sqnOut1";
    my $cmd = "mf2sqn -a generic -m $filename -t";
    print STDERR $cmd if $DEBUG;
  	my $ret = system("$cmd > $mf2sqnOut 2> $mf2sqnErr");
	
	if (($ret >> 8) > 1) {
	    print STDERR "There was an error running mf2sqn.\n";
		print STDERR "Content of STDERR output:\n";
		system("cat",$mf2sqnErr);
	}
    
    # Changed param into SubInfo.
    my $oldSubInfofh = new IO::File "<$filename.subInfo"
        or die "Can't open SubInfo file '$filename.subInfo': $!\n";
    
    my $newSubInfofh = new IO::File ">$filename.subInfo.new"
        or die "Can't open SubInfo file '$filename.subInfo.new': $!\n";
    
    while (my $line = <$oldSubInfofh>) {
        $line =~ s/'TOPOLOGY'     => 'C'/'TOPOLOGY'     => 'O'/;
        $line =~ s/'GENOME'       => 'M'/'GENOME'       => 'U'/;
        $line =~ s/'TITLE' => 'Dictyostelium discoideum mitochondrial DNA, complete sequence.'/'TITLE' => ''/;
        $line =~ s/'NUC_CODE'         => '1'/'NUC_CODE'         => '${GENCODE}'/;
        $line =~ s/'MIT_CODE'         => '1'/'MIT_CODE'         => '${GENCODE}'/;
        $line =~ s/'CITATION' => '10821186'/'CITATION' => ''/;
        print $newSubInfofh "$line";
    }
    $oldSubInfofh->close();
    $newSubInfofh->close();
    system("mv $filename.subInfo.new $filename.subInfo");
    
    # Re-run mf2sqn
    $mf2sqnErr   = "$TMPDIR/mf2sqnErr1";
    $mf2sqnOut   = "$TMPDIR/mf2sqnOut1";
    print STDERR $cmd if $DEBUG;
  	$ret = system("$cmd > $mf2sqnOut 2> $mf2sqnErr");
	
	if (($ret >> 8) > 1) {
	    print STDERR "There was an error running mf2sqn.\n";
		print STDERR "Content of STDERR output:\n";
		system("cat",$mf2sqnErr);
	}
    chdir("$initial_dir");
}

sub sendMail {
    my $filename = shift;
    
	my $subject   = "mfannot result on $filename";
    my $mail_file = "/services/WWW/cgi-bin/mfannot/mail_core";
    die "File for mail core doesn't exist" if !(-f "$mail_file");
    my $new_file  = "$TMPDIR/$filename";
    my $sqn_file  = "$TMPDIR/$filename.sqn";
	my $mailErr   = "$TMPDIR/mailErr";
	my $mailOut   = "$TMPDIR/mailOut";
	
    my $cmd = "perl /services/WWW/cgi-bin/RNAweasel/bin/sendmail.pl -f \'mfannot\@gmail.com\' -t \'$MAIL\' -s \'$subject\' -a \'$mail_file , $new_file , $sqn_file\'";
	print STDERR $cmd if $DEBUG;
	my $ret = system("$cmd 2> $mailErr");
	
	if (($ret >> 8) > 1) {
		print STDERR "There was an error sending mail.\n";
		print STDERR "Content of STDERR output:\n";
		system("cat",$mailErr);
	}
}

# End Of File. Or is it? What's beyond? Maybe the lost characters of all the sentences that were trunca

